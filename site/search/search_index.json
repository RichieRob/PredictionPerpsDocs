{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ExternalFunctions/","title":"External Functions","text":""},{"location":"ExternalFunctions/#amm-hook-contract","title":"AMM-Hook Contract","text":"<p>The AMM-Hook contract interfaces with the <code>MarketMakerLedger</code> to facilitate trading of back and lay tokens for market makers (MMs) and users.</p> <p>Hook: Called by the <code>PoolManager</code> for swap operations. AMM: Interfaces with the <code>MarketMakerLedger</code> to provide and manage tokens.</p>"},{"location":"ExternalFunctions/#afterswap","title":"afterSwap","text":""},{"location":"ExternalFunctions/#signature","title":"Signature","text":"<pre><code>//comment here\nfunction afterSwap(\n    address to,\n    PoolKey calldata poolKey,\n    SwapParams calldata poolParams,\n    int256 delta,\n    bytes calldata hookData\n) external returns (bytes4, int256);\n</code></pre>"},{"location":"ExternalFunctions/#details","title":"Details","text":""},{"location":"ExternalFunctions/#caller","title":"Caller","text":"<p><code>PoolManager</code></p>"},{"location":"ExternalFunctions/#role","title":"Role","text":"<p>Entry point for buy and sell flows, coordinating with the <code>MarketMakerLedger</code>.</p>"},{"location":"ExternalFunctions/#buy-flow","title":"Buy Flow","text":"<ol> <li>Transfers USDC from <code>PoolManager</code> to Hook (<code>USDC.transferFrom</code>).</li> <li>Computes output internally (<code>computeOutput</code>, not part of <code>MarketMakerLedger</code>).</li> <li>Calls <code>MarketMakerLedger.processBuy(to, marketId, mmId, positionId, isBack, usdcIn, tokensOut, minUSDCDeposited)</code>, receiving <code>recordedUSDC</code>.</li> <li>Returns <code>(selector, delta)</code> to <code>PoolManager</code>.</li> </ol>"},{"location":"ExternalFunctions/#sell-flow","title":"Sell Flow","text":"<ol> <li>Transfers <code>PositionToken</code> tokens from <code>PoolManager</code> to Hook (<code>PositionToken.transferFrom</code>).</li> <li>Computes output internally (<code>computeOutput</code>, not part of <code>MarketMakerLedger</code>).</li> <li>Calls <code>MarketMakerLedger.processSell(to, marketId, mmId, positionId, isBack, tokensIn, usdcOut)</code>.</li> <li>Returns <code>(selector, delta)</code> to <code>PoolManager</code>.</li> </ol>"},{"location":"ExternalFunctions/#userbuy","title":"userBuy","text":""},{"location":"ExternalFunctions/#signature_1","title":"Signature","text":"<pre><code>function userBuy(\n    address to,\n    address wantToken,\n    uint256 minWant,\n    uint256 usdcIn\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_1","title":"Details","text":""},{"location":"ExternalFunctions/#caller_1","title":"Caller","text":"<p>User</p>"},{"location":"ExternalFunctions/#role_1","title":"Role","text":"<p>Entry point for user-initiated buy flow, calls <code>MarketMakerLedger.processBuy</code> with appropriate <code>mmId</code>, <code>marketId</code>, <code>positionId</code>, and <code>isBack</code> derived from <code>wantToken</code>. Can mint tokens without USDC (<code>usdcIn = 0</code>).</p>"},{"location":"ExternalFunctions/#note","title":"Note","text":"<p>Assumes <code>wantToken</code> maps to a <code>PositionToken</code> (back or lay) for a specific <code>marketId</code> and <code>positionId</code>.</p>"},{"location":"ExternalFunctions/#usersell","title":"userSell","text":""},{"location":"ExternalFunctions/#signature_2","title":"Signature","text":"<pre><code>function userSell(\n    address to,\n    address dontWantToken,\n    uint256 dontWantIn,\n    uint256 minUsdcOut\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_2","title":"Details","text":""},{"location":"ExternalFunctions/#caller_2","title":"Caller","text":"<p>User</p>"},{"location":"ExternalFunctions/#role_2","title":"Role","text":"<p>Entry point for user-initiated sell flow, calls <code>MarketMakerLedger.processSell</code> with appropriate <code>mmId</code>, <code>marketId</code>, <code>positionId</code>, and <code>isBack</code> derived from <code>dontWantToken</code>. Can burn tokens without withdrawing USDC (<code>minUsdcOut = 0</code>).</p>"},{"location":"ExternalFunctions/#note_1","title":"Note","text":"<p>Assumes <code>dontWantToken</code> maps to a <code>PositionToken</code> (back or lay) for a specific <code>marketId</code> and <code>positionId</code>.</p>"},{"location":"ExternalFunctions/#transferliquidity","title":"transferLiquidity","text":""},{"location":"ExternalFunctions/#signature_3","title":"Signature","text":"<pre><code>function transferLiquidity(\n    uint256 mmId,\n    address newAddress\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_3","title":"Details","text":""},{"location":"ExternalFunctions/#caller_3","title":"Caller","text":"<p>Hook Owner or MM</p>"},{"location":"ExternalFunctions/#role_3","title":"Role","text":"<p>Transfers all liquidity for an <code>mmId</code> to a new address by updating the <code>mmIdToAddress</code> mapping in the <code>MarketMakerLedger</code>.</p>"},{"location":"ExternalFunctions/#flow","title":"Flow","text":"<ol> <li>Calls <code>MarketMakerLedger.transferLiquidity(mmId, newAddress)</code>.</li> </ol>"},{"location":"ExternalFunctions/#note_2","title":"Note","text":"<p>Restricted to the MM owning <code>mmId</code> or the Hook owner.</p>"},{"location":"ExternalFunctions/#depositusdc","title":"depositUsdc","text":""},{"location":"ExternalFunctions/#signature_4","title":"Signature","text":"<pre><code>function depositUsdc(\n    uint256 mmId,\n    uint256 amount,\n    uint256 minUSDCDeposited\n) external returns (uint256 recordedUSDC);\n</code></pre>"},{"location":"ExternalFunctions/#details_4","title":"Details","text":""},{"location":"ExternalFunctions/#caller_4","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_4","title":"Role","text":"<p>Calls <code>MarketMakerLedger.deposit</code> with <code>mmId</code>. Increases Hook\u2019s liquidity in the Ledger.</p>"},{"location":"ExternalFunctions/#withdrawusdc","title":"withdrawUsdc","text":""},{"location":"ExternalFunctions/#signature_5","title":"Signature","text":"<pre><code>function withdrawUsdc(\n    uint256 mmId,\n    uint256 amount\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_5","title":"Details","text":""},{"location":"ExternalFunctions/#caller_5","title":"Caller","text":"<p>Only Hook Owner or MM</p>"},{"location":"ExternalFunctions/#role_5","title":"Role","text":"<p>Calls <code>MarketMakerLedger.withdraw</code> with <code>mmId</code>. Decreases Hook\u2019s liquidity in the Ledger.</p>"},{"location":"ExternalFunctions/#ledger-vault-tokencontroller-contract-marketmakerledger","title":"Ledger-Vault-TokenController Contract (<code>MarketMakerLedger</code>)","text":"<p>The <code>MarketMakerLedger</code> contract manages a vault for aUSDC balances, individualizes balances for each market maker (MM) by <code>mmId</code>, and controls <code>PositionToken</code> contracts for minting/burning tokens.</p> <p>Vault: Tracks aUSDC balance supplied to Aave. Ledger: Manages individual MM balances (<code>mmCapitalization</code>, <code>freeCollateral</code>, <code>marketExposure</code>, <code>tilt</code>) by <code>mmId</code>. TokenController: Instructs <code>PositionToken</code> contracts to mint/burn tokens.</p>"},{"location":"ExternalFunctions/#registermarketmaker","title":"registerMarketMaker","text":""},{"location":"ExternalFunctions/#signature_6","title":"Signature","text":"<pre><code>function registerMarketMaker() external returns (uint256 mmId);\n</code></pre>"},{"location":"ExternalFunctions/#details_6","title":"Details","text":""},{"location":"ExternalFunctions/#caller_6","title":"Caller","text":"<p>Unrestricted (typically market makers)</p>"},{"location":"ExternalFunctions/#role_6","title":"Role","text":"<p>Registers a new market maker ID (<code>mmId</code>) for the caller\u2019s address, enabling discrete liquidity pools.</p>"},{"location":"ExternalFunctions/#flow_1","title":"Flow","text":"<ol> <li>Increments <code>nextMMId</code> and assigns <code>mmId</code> to <code>msg.sender</code> in <code>mmIdToAddress</code>.</li> <li>Emits <code>MarketMakerRegistered</code> event.</li> </ol>"},{"location":"ExternalFunctions/#createmarket","title":"createMarket","text":""},{"location":"ExternalFunctions/#signature_7","title":"Signature","text":"<pre><code>function createMarket(\n    string memory name,\n    string memory ticker\n) external returns (uint256 marketId);\n</code></pre>"},{"location":"ExternalFunctions/#details_7","title":"Details","text":""},{"location":"ExternalFunctions/#caller_7","title":"Caller","text":"<p>Owner (restricted by <code>onlyOwner</code>)</p>"},{"location":"ExternalFunctions/#role_7","title":"Role","text":"<p>Creates a new market with a name and ticker, assigning a unique <code>marketId</code>.</p>"},{"location":"ExternalFunctions/#flow_2","title":"Flow","text":"<ol> <li>Increments <code>nextMarketId</code> and stores <code>name</code> and <code>ticker</code> in storage.</li> <li>Adds <code>marketId</code> to <code>allMarkets</code> array.</li> <li>Emits <code>MarketCreated</code> event.</li> </ol>"},{"location":"ExternalFunctions/#note_3","title":"Note","text":"<p>Restricted to contract owner.</p>"},{"location":"ExternalFunctions/#createposition","title":"createPosition","text":""},{"location":"ExternalFunctions/#signature_8","title":"Signature","text":"<pre><code>function createPosition(\n    uint256 marketId,\n    string memory name,\n    string memory ticker\n) external returns (uint256 positionId);\n</code></pre>"},{"location":"ExternalFunctions/#details_8","title":"Details","text":""},{"location":"ExternalFunctions/#caller_8","title":"Caller","text":"<p>Owner (restricted by <code>onlyOwner</code>)</p>"},{"location":"ExternalFunctions/#role_8","title":"Role","text":"<p>Creates a new position in a market, deploying back and lay <code>PositionToken</code> contracts.</p>"},{"location":"ExternalFunctions/#flow_3","title":"Flow","text":"<ol> <li>Verifies <code>marketId</code> exists.</li> <li>Increments <code>nextPositionId[marketId]</code> and stores <code>name</code> and <code>ticker</code>.</li> <li>Adds <code>positionId</code> to <code>marketPositions[marketId]</code> array.</li> <li>Deploys <code>PositionToken</code> contracts for back and lay tokens.</li> <li>Stores token addresses in <code>tokenAddresses</code>.</li> <li>Emits <code>PositionCreated</code> event.</li> </ol>"},{"location":"ExternalFunctions/#note_4","title":"Note","text":"<p>Restricted to contract owner.</p>"},{"location":"ExternalFunctions/#deposit","title":"deposit","text":""},{"location":"ExternalFunctions/#signature_9","title":"Signature","text":"<pre><code>function deposit(\n    uint256 mmId,\n    uint256 amount,\n    uint256 minUSDCDeposited\n) external returns (uint256 recordedUSDC);\n</code></pre>"},{"location":"ExternalFunctions/#details_9","title":"Details","text":""},{"location":"ExternalFunctions/#caller_9","title":"Caller","text":"<p>Unrestricted (typically market makers)</p>"},{"location":"ExternalFunctions/#role_9","title":"Role","text":"<p>Deposits USDC to the MM\u2019s <code>freeCollateral</code> for <code>mmId</code>, supplies to Aave, updates capitalizations.</p>"},{"location":"ExternalFunctions/#flow_4","title":"Flow","text":"<ol> <li>Transfers USDC from the MM\u2019s address to contract (<code>USDC.transferFrom</code>).</li> <li>Supplies USDC to Aave, records aUSDC received.</li> <li>Ensures received aUSDC meets <code>minUSDCDeposited</code>.</li> <li>Updates <code>freeCollateral[mmId]</code>, <code>mmCapitalization[mmId]</code>, <code>globalCapitalization</code>.</li> <li>Emits <code>Deposited</code> event.</li> <li>Returns <code>recordedUSDC</code>.</li> </ol>"},{"location":"ExternalFunctions/#note_5","title":"Note","text":"<p>Caller must approve the contract to spend USDC.</p>"},{"location":"ExternalFunctions/#withdraw","title":"withdraw","text":""},{"location":"ExternalFunctions/#signature_10","title":"Signature","text":"<pre><code>function withdraw(\n    uint256 mmId,\n    uint256 amount\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_10","title":"Details","text":""},{"location":"ExternalFunctions/#caller_10","title":"Caller","text":"<p>MM or Hook Owner</p>"},{"location":"ExternalFunctions/#role_10","title":"Role","text":"<p>Withdraws USDC from the MM\u2019s <code>freeCollateral</code> for <code>mmId</code>, pulls from Aave, updates capitalizations.</p>"},{"location":"ExternalFunctions/#flow_5","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code>.</li> <li>Checks <code>freeCollateral[mmId]</code> and contract\u2019s USDC balance.</li> <li>Decrements <code>freeCollateral[mmId]</code>, <code>mmCapitalization[mmId]</code>, <code>globalCapitalization</code>.</li> <li>Calls Aave\u2019s <code>withdraw</code> to send USDC to MM.</li> <li>Emits <code>Withdrawn</code> event.</li> </ol>"},{"location":"ExternalFunctions/#withdrawinterest","title":"withdrawInterest","text":""},{"location":"ExternalFunctions/#signature_11","title":"Signature","text":"<pre><code>function withdrawInterest() external;\n</code></pre>"},{"location":"ExternalFunctions/#details_11","title":"Details","text":""},{"location":"ExternalFunctions/#caller_11","title":"Caller","text":"<p>Owner (restricted by <code>onlyOwner</code>)</p>"},{"location":"ExternalFunctions/#role_11","title":"Role","text":"<p>Withdraws accrued interest (<code>aUSDC.balanceOf - globalCapitalization</code>) to the owner.</p>"},{"location":"ExternalFunctions/#flow_6","title":"Flow","text":"<ol> <li>Calculates interest via <code>getInterest</code>.</li> <li>Calls Aave\u2019s <code>withdraw</code> to send USDC to owner.</li> <li>Transfers USDC to owner.</li> </ol>"},{"location":"ExternalFunctions/#transferliquidity_1","title":"transferLiquidity","text":""},{"location":"ExternalFunctions/#signature_12","title":"Signature","text":"<pre><code>function transferLiquidity(\n    uint256 mmId,\n    address newAddress\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_12","title":"Details","text":""},{"location":"ExternalFunctions/#caller_12","title":"Caller","text":"<p>MM or Owner</p>"},{"location":"ExternalFunctions/#role_12","title":"Role","text":"<p>Transfers all liquidity for an <code>mmId</code> to a new address by updating <code>mmIdToAddress</code>.</p>"},{"location":"ExternalFunctions/#flow_7","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code> or caller is owner.</li> <li>Updates <code>mmIdToAddress[mmId]</code> to <code>newAddress</code>.</li> <li>Emits <code>LiquidityTransferred</code> event.</li> </ol>"},{"location":"ExternalFunctions/#processbuy","title":"processBuy","text":""},{"location":"ExternalFunctions/#signature_13","title":"Signature","text":"<pre><code>function processBuy(\n    address to,\n    uint256 marketId,\n    uint256 mmId,\n    uint256 positionId,\n    bool isBack,\n    uint256 usdcIn,\n    uint256 tokensOut,\n    uint256 minUSDCDeposited\n) external returns (uint256 recordedUSDC);\n</code></pre>"},{"location":"ExternalFunctions/#details_13","title":"Details","text":""},{"location":"ExternalFunctions/#caller_13","title":"Caller","text":"<p>AMM-Hook</p>"},{"location":"ExternalFunctions/#role_13","title":"Role","text":"<p>Handles buy flow, depositing USDC to Aave and minting back or lay <code>PositionToken</code> tokens. Can mint tokens without USDC (<code>usdcIn = 0</code>).</p>"},{"location":"ExternalFunctions/#flow_8","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code>.</li> <li>If <code>usdcIn &gt; 0</code>, calls <code>deposit</code> with <code>mmId</code>, <code>usdcIn</code>, <code>minUSDCDeposited</code>.</li> <li>For back tokens:</li> <li>Calls <code>ensureSolvency</code>, updates <code>tilt</code> (negative), mints tokens.</li> <li>For lay tokens:</li> <li>Calls <code>ensureSolvency</code>, decrements <code>marketExposure[mmId]</code>, <code>mmCapitalization[mmId]</code>, <code>globalCapitalization</code>, updates <code>tilt</code> (positive), mints tokens.</li> <li>Emits <code>Bought</code> and <code>TiltUpdated</code> events.</li> <li>Returns <code>recordedUSDC</code>.</li> </ol>"},{"location":"ExternalFunctions/#note_6","title":"Note","text":"<p>Caller must approve USDC if <code>usdcIn &gt; 0</code>.</p>"},{"location":"ExternalFunctions/#processsell","title":"processSell","text":""},{"location":"ExternalFunctions/#signature_14","title":"Signature","text":"<pre><code>function processSell(\n    address to,\n    uint256 marketId,\n    uint256 mmId,\n    uint256 positionId,\n    bool isBack,\n    uint256 tokensIn,\n    uint256 usdcOut\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_14","title":"Details","text":""},{"location":"ExternalFunctions/#caller_14","title":"Caller","text":"<p>AMM-Hook</p>"},{"location":"ExternalFunctions/#role_14","title":"Role","text":"<p>Handles sell flow, burning back or lay <code>PositionToken</code> tokens and withdrawing USDC from Aave. Can burn tokens without withdrawing USDC (<code>usdcOut = 0</code>).</p>"},{"location":"ExternalFunctions/#flow_9","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code>.</li> <li>For back tokens:</li> <li>Updates <code>tilt</code> (positive), calls <code>deallocateExcess</code>, burns tokens.</li> <li>For lay tokens:</li> <li>Increments <code>marketExposure[mmId]</code>, <code>mmCapitalization[mmId]</code>, <code>globalCapitalization</code>, updates <code>tilt</code> (negative), calls <code>deallocateExcess</code>, burns tokens.</li> <li>If <code>usdcOut &gt; 0</code>, calls <code>withdraw</code> with <code>mmId</code>, <code>usdcOut</code>.</li> <li>Emits <code>Sold</code> and <code>TiltUpdated</code> events.</li> </ol>"},{"location":"ExternalFunctions/#note_7","title":"Note","text":"<p>Caller must approve <code>PositionToken</code> for burning.</p>"},{"location":"ExternalFunctions/#getpositionliquidity","title":"getPositionLiquidity","text":""},{"location":"ExternalFunctions/#signature_15","title":"Signature","text":"<pre><code>function getPositionLiquidity(\n    uint256 mmId,\n    uint256 marketId,\n    uint256 positionId\n) external view returns (\n    uint256 freeCollateral,\n    uint256 marketExposure,\n    int128 tilt\n);\n</code></pre>"},{"location":"ExternalFunctions/#details_15","title":"Details","text":""},{"location":"ExternalFunctions/#caller_15","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_15","title":"Role","text":"<p>Returns the MM\u2019s liquidity details (<code>freeCollateral</code>, <code>marketExposure</code>, <code>tilt</code>) for a specific position.</p>"},{"location":"ExternalFunctions/#note_8","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#getmintilt","title":"getMinTilt","text":""},{"location":"ExternalFunctions/#signature_16","title":"Signature","text":"<pre><code>function getMinTilt(\n    uint256 mmId,\n    uint256 marketId\n) external view returns (\n    int128 minTilt,\n    uint256 minPositionId\n);\n</code></pre>"},{"location":"ExternalFunctions/#details_16","title":"Details","text":""},{"location":"ExternalFunctions/#caller_16","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_16","title":"Role","text":"<p>Returns the minimum (most negative) tilt and its position ID for an MM in a market.</p>"},{"location":"ExternalFunctions/#note_9","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#getmmcapitalization","title":"getMMCapitalization","text":""},{"location":"ExternalFunctions/#signature_17","title":"Signature","text":"<pre><code>function getMMCapitalization(\n    uint256 mmId\n) external view returns (uint256);\n</code></pre>"},{"location":"ExternalFunctions/#details_17","title":"Details","text":""},{"location":"ExternalFunctions/#caller_17","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_17","title":"Role","text":"<p>Retrieves the MM\u2019s capitalization (<code>mmCapitalization[mmId]</code>).</p>"},{"location":"ExternalFunctions/#note_10","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#getinterest","title":"getInterest","text":""},{"location":"ExternalFunctions/#signature_18","title":"Signature","text":"<pre><code>function getInterest() external view returns (uint256);\n</code></pre>"},{"location":"ExternalFunctions/#details_18","title":"Details","text":""},{"location":"ExternalFunctions/#caller_18","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_18","title":"Role","text":"<p>Returns accrued interest (<code>aUSDC.balanceOf - globalCapitalization</code>).</p>"},{"location":"ExternalFunctions/#note_11","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#getmarkets","title":"getMarkets","text":""},{"location":"ExternalFunctions/#signature_19","title":"Signature","text":"<pre><code>function getMarkets() external view returns (uint256[] memory);\n</code></pre>"},{"location":"ExternalFunctions/#details_19","title":"Details","text":""},{"location":"ExternalFunctions/#caller_19","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_19","title":"Role","text":"<p>Returns an array of all market IDs.</p>"},{"location":"ExternalFunctions/#note_12","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#getmarketpositions","title":"getMarketPositions","text":""},{"location":"ExternalFunctions/#signature_20","title":"Signature","text":"<pre><code>function getMarketPositions(\n    uint256 marketId\n) external view returns (uint256[] memory);\n</code></pre>"},{"location":"ExternalFunctions/#details_20","title":"Details","text":""},{"location":"ExternalFunctions/#caller_20","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_20","title":"Role","text":"<p>Returns an array of position IDs for a given <code>marketId</code>.</p>"},{"location":"ExternalFunctions/#note_13","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#getmarketdetails","title":"getMarketDetails","text":""},{"location":"ExternalFunctions/#signature_21","title":"Signature","text":"<pre><code>function getMarketDetails(\n    uint256 marketId\n) external view returns (string memory name, string memory ticker);\n</code></pre>"},{"location":"ExternalFunctions/#details_21","title":"Details","text":""},{"location":"ExternalFunctions/#caller_21","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_21","title":"Role","text":"<p>Returns the name and ticker for a given <code>marketId</code>.</p>"},{"location":"ExternalFunctions/#note_14","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#getpositiondetails","title":"getPositionDetails","text":""},{"location":"ExternalFunctions/#signature_22","title":"Signature","text":"<pre><code>function getPositionDetails(\n    uint256 marketId,\n    uint256 positionId\n) external view returns (string memory name, string memory ticker, address backToken, address layToken);\n</code></pre>"},{"location":"ExternalFunctions/#details_22","title":"Details","text":""},{"location":"ExternalFunctions/#caller_22","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"ExternalFunctions/#role_22","title":"Role","text":"<p>Returns the name, ticker, and back/lay token addresses for a given <code>marketId</code> and <code>positionId</code>.</p>"},{"location":"ExternalFunctions/#note_15","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"ExternalFunctions/#positiontoken-contract","title":"PositionToken Contract","text":"<p><code>PositionToken</code> is an ERC20 contract deployed by <code>MarketMakerLedger</code> for each <code>(marketId, positionId)</code> pair (back and lay tokens). Access to minting and burning is restricted to the ledger.</p>"},{"location":"ExternalFunctions/#mint","title":"mint","text":""},{"location":"ExternalFunctions/#signature_23","title":"Signature","text":"<pre><code>function mint(\n    address to,\n    uint256 amount\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_23","title":"Details","text":""},{"location":"ExternalFunctions/#caller_23","title":"Caller","text":"<p><code>MarketMakerLedger</code> (via <code>processBuy</code>)</p>"},{"location":"ExternalFunctions/#role_23","title":"Role","text":"<p>Mints new <code>PositionToken</code> tokens.</p>"},{"location":"ExternalFunctions/#note_16","title":"Note","text":"<p>Restricted to <code>MarketMakerLedger</code> (via <code>onlyLedger</code> check).</p>"},{"location":"ExternalFunctions/#burnfrom","title":"burnFrom","text":""},{"location":"ExternalFunctions/#signature_24","title":"Signature","text":"<pre><code>function burnFrom(\n    address from,\n    uint256 amount\n) external;\n</code></pre>"},{"location":"ExternalFunctions/#details_24","title":"Details","text":""},{"location":"ExternalFunctions/#caller_24","title":"Caller","text":"<p><code>MarketMakerLedger</code> (via <code>processSell</code>)</p>"},{"location":"ExternalFunctions/#role_24","title":"Role","text":"<p>Burns <code>PositionToken</code> tokens from an account, checking allowance.</p>"},{"location":"ExternalFunctions/#note_17","title":"Note","text":"<p>Restricted to <code>MarketMakerLedger</code>. Caller must approve the ledger to burn tokens.</p>"},{"location":"ExternalFunctions/#standard-erc20-functions","title":"Standard ERC20 Functions","text":""},{"location":"ExternalFunctions/#transferfrom","title":"transferFrom","text":""},{"location":"ExternalFunctions/#signature_25","title":"Signature","text":"<pre><code>function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n) external returns (bool);\n</code></pre>"},{"location":"ExternalFunctions/#details_25","title":"Details","text":"<p>Standard ERC20 function for transferring tokens from one address to another.</p>"},{"location":"ExternalFunctions/#balanceof","title":"balanceOf","text":""},{"location":"ExternalFunctions/#signature_26","title":"Signature","text":"<pre><code>function balanceOf(\n    address account\n) external view returns (uint256);\n</code></pre>"},{"location":"ExternalFunctions/#details_26","title":"Details","text":"<p>Standard ERC20 function to retrieve the token balance of an account.</p>"},{"location":"ExternalFunctions/#totalsupply","title":"totalSupply","text":""},{"location":"ExternalFunctions/#signature_27","title":"Signature","text":"<pre><code>function totalSupply() external view returns (uint256);\n</code></pre>"},{"location":"ExternalFunctions/#details_27","title":"Details","text":"<p>Standard ERC20 function to retrieve the total token supply.</p>"},{"location":"ExternalFunctions/#approve","title":"approve","text":""},{"location":"ExternalFunctions/#signature_28","title":"Signature","text":"<pre><code>function approve(\n    address spender,\n    uint256 amount\n) external returns (bool);\n</code></pre>"},{"location":"ExternalFunctions/#details_28","title":"Details","text":"<p>Standard ERC20 function to approve a spender to transfer tokens on behalf of the owner.</p>"},{"location":"ExternalFunctions/#transfer","title":"transfer","text":""},{"location":"ExternalFunctions/#signature_29","title":"Signature","text":"<pre><code>function transfer(\n    address to,\n    uint256 amount\n) external returns (bool);\n</code></pre>"},{"location":"ExternalFunctions/#details_29","title":"Details","text":"<p>Standard ERC20 function to transfer tokens to a specified address.</p>"},{"location":"Ledger/","title":"Ledger Technical Details","text":""},{"location":"Ledger/#overview","title":"Overview","text":"<p>In traditional prediction markets like Polymarket, market makers deposit capital to mint an array of outcome shares explicitly. Creating positiosn requires splitting, merging, minting, and burning tokens. This process is gas-intensive, especially for markets with many outcomes, as operations scale with \\( O(n) \\), where \\( n \\) is the number of outcomes.</p> <p>The ledger takes a different approach, tracking virtual outcome shares internally without minting physical token arrays. This allows the Market Maker to have full flexibility in buying and selling positions, without the need to split and merge positions.</p> <ul> <li>Deposits and redemptions are \\( O(1) \\), minimizing gas costs.</li> <li>Outcome shares are virtualized, and tokens are minted only on demand.</li> <li>No splitting or merging is required.</li> </ul> <p>This means the central system is just adding up numbers and lazily minting tokens on demand.</p> <p>The Ledger is agnostic about pricing and all pricing is down to Market Makers.</p>"},{"location":"Ledger/#ledger-accounting","title":"Ledger Accounting","text":"<p>The ledger tracks virtual shares for each Market Maker (MM), ensuring each market maker keeps a non-negative balance per outcome (\\( H_k \\geq 0 \\)).</p>"},{"location":"Ledger/#key-components","title":"Key Components","text":""},{"location":"Ledger/#uniform-credit-v","title":"Uniform Credit (v)","text":"<ul> <li><code>int256 v</code>: Collateral in vUSDC, equivalent to holding \\( v \\) virtual shares for every outcome.</li> <li>Think of this as a balanced set of outcome shares.</li> </ul>"},{"location":"Ledger/#tilt-mapping","title":"Tilt Mapping","text":"<ul> <li><code>mapping(uint256 =&gt; int128) tilt</code>: Adjusts outcome shares per ID (\\( k \\)).</li> <li>Signed, so tilts can be positive or negative.</li> </ul>"},{"location":"Ledger/#effective-virtual-shares","title":"Effective Virtual Shares","text":"\\[ H_k = v + \\text{tilt}[k] \\] <p>Represents the effective virtual share balance for outcome \\( k \\).</p>"},{"location":"Ledger/#restraint","title":"Restraint","text":"<p>Each market maker must satisfy:</p> \\[ H_k \\geq 0 \\quad \\text{for all outcomes } k \\]"},{"location":"Ledger/#relationship-between-back-and-lay","title":"Relationship Between Back and Lay","text":"<p>The core principle governing Back and Lay tokens is explicitly defined as:</p> \\[ \\text{Back}(A) + \\text{Lay}(A) = 1 \\, \\text{vUSDC} \\] <p>This ensures that the sum of a Back token and its corresponding Lay token always equals 1 vUSDC, maintaining balance in the market.</p> <ul> <li>A Back token represents direct exposure to a specific outcome, denoted as \\(\\text{Back}(A)\\).</li> <li>A Lay token is its complement, explicitly defined by the equation:</li> </ul> \\[ \\text{Lay}(A) = 1 \\, \\text{vUSDC} - \\text{Back}(A) \\]"},{"location":"Ledger/#withdrawing-1-lay-a","title":"Withdrawing 1 Lay A","text":"<p>When the Market Maker (MM) withdraws 1 Lay A from the Ledger :</p> <p>Ledger Balance:</p> <ul> <li>down 1 vUSDC</li> <li>up 1 A</li> </ul>"},{"location":"Ledger/#depositing-1-lay-a","title":"Depositing 1 Lay A","text":"<p>Conversely, when the MM deposits 1 Lay A into the Ledger:</p> <p>Ledger Balance:</p> <ul> <li>up 1 vUSDC</li> <li>down 1 Back A</li> </ul>"},{"location":"Ledger/#operation-semantics-ledger-updates","title":"Operation Semantics (Ledger Updates)","text":"Operation Token Flow v update tilt<sub>k</sub> update Notes Deposit vUSDC MM -&gt; Ledger: u vUSDC v += u \u2014 Withdraw vUSDC Ledger -&gt; MM: u vUSDC v -= u \u2014 u &lt;= min<sub>k</sub> H<sub>k</sub>. Mint Back k Ledger -&gt; MM: q Back<sub>k</sub> \u2014 tilt<sub>k</sub> -= q Receive Back k MM -&gt; Ledger: q Back<sub>k</sub> \u2014 tilt<sub>k</sub> += q Mint Lay k Ledger -&gt; MM: q Lay<sub>k</sub> v -= q tilt<sub>k</sub> += q Because Lay = 1 - Back Receive Lay k MM -&gt; Ledger: q Lay<sub>k</sub> v += q tilt<sub>k</sub> -= q Because Lay = 1 - Back"},{"location":"Ledger/#example-trades","title":"Example Trades","text":"<p>Assume a market with positions A, B, C.</p>"},{"location":"Ledger/#initial-state-empty-ledger","title":"Initial State (Empty Ledger)","text":"v tilt<sub>A</sub> tilt<sub>B</sub> tilt<sub>C</sub> H<sub>A</sub> H<sub>B</sub> H<sub>C</sub> 0 0 0 0 0 0 0 <p>Ledger starts empty.</p>"},{"location":"Ledger/#1-balanced-deposit-100-vusdc","title":"1) Balanced Deposit (100 vUSDC)","text":"<p>Operation: MM deposits 100 vUSDC \u2192 <code>v += 100</code>.</p> v tilt<sub>A</sub> tilt<sub>B</sub> tilt<sub>C</sub> H<sub>A</sub> H<sub>B</sub> H<sub>C</sub> 100 0 0 0 100 100 100"},{"location":"Ledger/#2-issue-back-a-40-back-a-for-20-vusdc","title":"2) Issue Back A (40 Back A for 20 vUSDC)","text":"v tilt<sub>A</sub> tilt<sub>B</sub> tilt<sub>C</sub> H<sub>A</sub> H<sub>B</sub> H<sub>C</sub> 120 -40 0 0 80 120 120 <p>CMM mints 40 Back A and gives them to MM. Ledger rebalances.</p>"},{"location":"Ledger/#3-user-sells-50-back-b-mm-pays-10-vusdc","title":"3) User Sells 50 Back B (MM pays 10 vUSDC)","text":"v tilt<sub>A</sub> tilt<sub>B</sub> tilt<sub>C</sub> H<sub>A</sub> H<sub>B</sub> H<sub>C</sub> 110 -40 50 0 70 160 110 <p>CMM burns 50 Back B. MM receives 10 vUSDC.</p>"},{"location":"Ledger/#4-user-buys-9-lay-a-mm-pays-10-vusdc","title":"4) User Buys 9 Lay A (MM pays 10 vUSDC)","text":"v tilt<sub>A</sub> tilt<sub>B</sub> tilt<sub>C</sub> H<sub>A</sub> H<sub>B</sub> H<sub>C</sub> 111 -31 50 0 80 161 111 <ul> <li><code>v = v + 10 - 9</code> (collateral added, but liability for 9 Lay A).</li> <li><code>tilt&lt;sub&gt;A&lt;/sub&gt; = tilt&lt;sub&gt;A&lt;/sub&gt; + 9</code>.</li> </ul> <p>CMM mints 9 Lay A and sends them to MM.</p>"},{"location":"Ledger/#5-user-sells-2-lay-c-mm-pays-1-vusdc","title":"5) User Sells 2 Lay C (MM pays 1 vUSDC)","text":"v tilt<sub>A</sub> tilt<sub>B</sub> tilt<sub>C</sub> H<sub>A</sub> H<sub>B</sub> H<sub>C</sub> 112 -31 50 -2 81 162 110 <p>CMM burns 2 Lay C and gives 1 vUSDC to MM.</p>"},{"location":"Ledger/#6-balanced-redemption","title":"6) Balanced Redemption","text":"<ul> <li>Max redeemable = min<sub>k</sub> H<sub>k</sub>.</li> <li>Here, \\( \\min_k H_k = 81 \\).</li> <li>MM withdraws 81 vUSDC.</li> </ul> v tilt<sub>A</sub> tilt<sub>B</sub> tilt<sub>C</sub> H<sub>A</sub> H<sub>B</sub> H<sub>C</sub> 31 -31 50 -2 0 81 29 <p>CMM sends 81 vUSDC to MM. The MM still has B and C tokens they can sell or they can deposit additional tokens to recover more USDC. This ensures the ledger never allows full withdrawal unless all tilts are balanced.</p>"},{"location":"Ledger/#7-multiple-outcome-markets","title":"7) Multiple-Outcome Markets","text":"<p>So far, we have only looked at markets with one winner. For example, an election: one candidate wins, all others lose. In that case, solvency is simple \u2014 each effective balance \\( H_k = v + \\text{tilt}[k] \\) must be non-negative.  </p> <p>However we can equally apply this to events with multiple outcomes. </p> <p>A good example is the English Premier League relegation market, where exactly three clubs go down together.  </p>"},{"location":"Ledger/#step-1-what-changes-with-multiple-winners","title":"Step 1. What changes with multiple winners?","text":"<p>If three teams are relegated, the market maker must be able to pay all three at once. That means we can\u2019t just check a single team\u2019s balance. We need to look at the three weakest balances together.</p>"},{"location":"Ledger/#step-2-headroom-per-team","title":"Step 2. Headroom per team","text":"<p>As before, for each outcome \\( k \\):</p> \\[ H_k = v + \\text{tilt}[k] \\] <ul> <li>\\( v \\) is the uniform budget in vUSDC.  </li> <li>\\( \\text{tilt}[k] \\) tracks how much Back or Lay exposure you\u2019ve taken on outcome \\( k \\).  </li> <li>\\( H_k \\) is the \u201cheadroom\u201d \u2014 how much slack you have on that outcome.  </li> </ul> <p>Every team must still satisfy \\( H_k \\ge 0 \\). But with multiple winners, that\u2019s not enough.</p>"},{"location":"Ledger/#step-3-liability-if-three-teams-win","title":"Step 3. Liability if three teams win","text":"<p>Suppose \\( v = 10 \\). Balances are:</p> <ul> <li>\\( H_A = 7 \\) </li> <li>\\( H_B = 6 \\) </li> <li>\\( H_C = 9 \\) </li> <li>\\( H_D = 12 \\)</li> </ul> <p>The three smallest are \\( h_1 = 6, h_2 = 7, h_3 = 9 \\).</p> <p>If A, B, and C all get relegated: - Liability for A = \\( v - H_A = 10 - 7 = 3 \\) - Liability for B = \\( 10 - 6 = 4 \\) - Liability for C = \\( 10 - 9 = 1 \\) - Total liability = \\( 3 + 4 + 1 = 8 \\)</p> <p>Budget \\( v = 10 \\). Since \\( 8 \\le 10 \\), this is safe.</p>"},{"location":"Ledger/#step-4-general-formula","title":"Step 4. General formula","text":"<p>For \\( m \\) winners: - Worst case is the \\( m \\) smallest balances \\( h_1, h_2, \\dots, h_m \\). - Liability = \\( \\sum_{i=1}^m (v - h_i) = m v - (h_1 + h_2 + \\dots + h_m) \\). - This must be \u2264 budget \\( v \\).  </p> <p>So the condition is:</p> \\[ h_1 + h_2 + \\dots + h_m \\;\\;\\ge\\;\\; (m-1) v \\]"},{"location":"Ledger/#step-5-special-cases","title":"Step 5. Special cases","text":"<ul> <li>\\( m = 1 \\): \\( h_1 \\ge 0 \\) (the basic non-negative rule).  </li> <li>\\( m = 2 \\): \\( h_1 + h_2 \\ge v \\).  </li> <li>\\( m = 3 \\): \\( h_1 + h_2 + h_3 \\ge 2v \\).  </li> <li>\\( m = 4 \\): \\( h_1 + h_2 + h_3 + h_4 \\ge 3v \\).  </li> </ul> <p>And so on.</p>"},{"location":"Ledger/#step-6-implementation","title":"Step 6. Implementation","text":"<p>To enforce this in practice: - Track each \\( H_k \\) as usual. - Keep a cache of the smallest \\( m+1 \\) balances. - After any deposit, withdrawal, or mint/burn, update the changed \\( H_k \\). - Check the condition \\( h_1 + \\dots + h_m \\ge (m-1) v \\).  </p> <p>This way the ledger stays efficient \u2014 only one balance changes per operation \u2014 but it now works for multi-winner markets like EPL relegation.</p>"},{"location":"LedgerExternalFunctions/","title":"Ledger External Functions","text":"<p>This document outlines the external functions of the <code>MarketMakerLedger</code> contract, which manages a vault for aUSDC balances, individualizes balances for each market maker (MM) by <code>mmId</code>, and controls <code>PositionToken</code> contracts for minting/burning tokens.</p>"},{"location":"LedgerExternalFunctions/#market-maker-registration","title":"Market Maker Registration","text":""},{"location":"LedgerExternalFunctions/#registermarketmaker","title":"registerMarketMaker","text":""},{"location":"LedgerExternalFunctions/#signature","title":"Signature","text":"<pre><code>function registerMarketMaker()\n    external\n    returns (uint256 mmId);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller","title":"Caller","text":"<p>Unrestricted (typically market makers)</p>"},{"location":"LedgerExternalFunctions/#role","title":"Role","text":"<p>Registers a new market maker ID (<code>mmId</code>) for the caller\u2019s address, enabling discrete liquidity pools.</p>"},{"location":"LedgerExternalFunctions/#flow","title":"Flow","text":"<ol> <li>Increments <code>nextMMId</code> and assigns <code>mmId</code> to <code>msg.sender</code> in <code>mmIdToAddress</code>.</li> <li>Emits <code>MarketMakerRegistered</code> event with the caller\u2019s address and <code>mmId</code>.</li> </ol>"},{"location":"LedgerExternalFunctions/#returns","title":"Returns","text":"<ul> <li><code>mmId</code>: The assigned market maker ID.</li> </ul>"},{"location":"LedgerExternalFunctions/#admin-operations-marketposition-creation","title":"Admin Operations (Market/Position Creation)","text":""},{"location":"LedgerExternalFunctions/#createmarket","title":"createMarket","text":""},{"location":"LedgerExternalFunctions/#signature_1","title":"Signature","text":"<pre><code>function createMarket(\n    string memory name,\n    string memory ticker\n)\n    external\n    returns (uint256 marketId);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_1","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_1","title":"Caller","text":"<p>Owner (restricted by <code>onlyOwner</code>)</p>"},{"location":"LedgerExternalFunctions/#role_1","title":"Role","text":"<p>Creates a new market with a name and ticker, assigning a unique <code>marketId</code>.</p>"},{"location":"LedgerExternalFunctions/#flow_1","title":"Flow","text":"<ol> <li>Increments <code>nextMarketId</code> and stores <code>name</code> and <code>ticker</code> in storage.</li> <li>Adds <code>marketId</code> to <code>allMarkets</code> array.</li> <li>Emits <code>MarketCreated</code> event.</li> </ol>"},{"location":"LedgerExternalFunctions/#returns_1","title":"Returns","text":"<ul> <li><code>marketId</code>: The assigned market ID.</li> </ul>"},{"location":"LedgerExternalFunctions/#note","title":"Note","text":"<p>Restricted to contract owner.</p>"},{"location":"LedgerExternalFunctions/#createposition","title":"createPosition","text":""},{"location":"LedgerExternalFunctions/#signature_2","title":"Signature","text":"<pre><code>function createPosition(\n    uint256 marketId,\n    string memory name,\n    string memory ticker\n)\n    external\n    returns (uint256 positionId);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_2","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_2","title":"Caller","text":"<p>Owner (restricted by <code>onlyOwner</code>)</p>"},{"location":"LedgerExternalFunctions/#role_2","title":"Role","text":"<p>Creates a new position in a market, deploying back and lay <code>PositionToken</code> contracts.</p>"},{"location":"LedgerExternalFunctions/#flow_2","title":"Flow","text":"<ol> <li>Verifies <code>marketId</code> exists.</li> <li>Increments <code>nextPositionId[marketId]</code> and stores <code>name</code> and <code>ticker</code>.</li> <li>Adds <code>positionId</code> to <code>marketPositions[marketId]</code> array.</li> <li>Deploys <code>PositionToken</code> contracts for back and lay tokens.</li> <li>Stores token addresses in <code>tokenAddresses</code>.</li> <li>Emits <code>PositionCreated</code> event.</li> </ol>"},{"location":"LedgerExternalFunctions/#returns_2","title":"Returns","text":"<ul> <li><code>positionId</code>: The assigned position ID.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_1","title":"Note","text":"<p>Restricted to contract owner.</p>"},{"location":"LedgerExternalFunctions/#depositwithdraw-operations","title":"Deposit/Withdraw Operations","text":""},{"location":"LedgerExternalFunctions/#deposit","title":"deposit","text":""},{"location":"LedgerExternalFunctions/#signature_3","title":"Signature","text":"<pre><code>function deposit(\n    uint256 mmId,\n    uint256 amount,\n    uint256 minUSDCDeposited\n)\n    external\n    returns (uint256 recordedUSDC);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_3","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_3","title":"Caller","text":"<p>Unrestricted (typically market makers)</p>"},{"location":"LedgerExternalFunctions/#role_3","title":"Role","text":"<p>Deposits USDC to the MM\u2019s <code>freeCollateral</code> for <code>mmId</code>, supplies to Aave, and updates capitalizations.</p>"},{"location":"LedgerExternalFunctions/#flow_3","title":"Flow","text":"<ol> <li>Transfers USDC from the MM\u2019s address to the contract (<code>USDC.transferFrom</code>).</li> <li>Supplies USDC to Aave, records aUSDC received.</li> <li>Ensures received aUSDC meets <code>minUSDCDeposited</code>.</li> <li>Updates <code>freeCollateral[mmId]</code>, <code>mmCapitalization[mmId]</code>, and <code>globalCapitalization</code>.</li> <li>Emits <code>Deposited</code> event with <code>mmId</code> and <code>recordedUSDC</code>.</li> </ol>"},{"location":"LedgerExternalFunctions/#returns_3","title":"Returns","text":"<ul> <li><code>recordedUSDC</code>: The actual aUSDC amount recorded.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_2","title":"Note","text":"<p>Caller must approve the contract to spend USDC.</p>"},{"location":"LedgerExternalFunctions/#withdraw","title":"withdraw","text":""},{"location":"LedgerExternalFunctions/#signature_4","title":"Signature","text":"<pre><code>function withdraw(\n    uint256 mmId,\n    uint256 amount\n)\n    external;\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_4","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_4","title":"Caller","text":"<p>MM or Hook Owner</p>"},{"location":"LedgerExternalFunctions/#role_4","title":"Role","text":"<p>Withdraws USDC from the MM\u2019s <code>freeCollateral</code> for <code>mmId</code>, pulls from Aave, and updates capitalizations.</p>"},{"location":"LedgerExternalFunctions/#flow_4","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code> or caller is owner.</li> <li>Checks <code>freeCollateral[mmId]</code> and contract\u2019s USDC balance.</li> <li>Decrements <code>freeCollateral[mmId]</code>, <code>mmCapitalization[mmId]</code>, and <code>globalCapitalization</code>.</li> <li>Calls Aave\u2019s <code>withdraw</code> to send USDC to MM.</li> <li>Emits <code>Withdrawn</code> event with <code>mmId</code> and <code>amount</code>.</li> </ol>"},{"location":"LedgerExternalFunctions/#withdrawinterest","title":"withdrawInterest","text":""},{"location":"LedgerExternalFunctions/#signature_5","title":"Signature","text":"<pre><code>function withdrawInterest()\n    external;\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_5","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_5","title":"Caller","text":"<p>Owner (restricted by <code>onlyOwner</code>)</p>"},{"location":"LedgerExternalFunctions/#role_5","title":"Role","text":"<p>Withdraws accrued interest (<code>aUSDC.balanceOf - globalCapitalization</code>) to the owner.</p>"},{"location":"LedgerExternalFunctions/#flow_5","title":"Flow","text":"<ol> <li>Calculates interest via <code>getInterest</code>.</li> <li>Calls Aave\u2019s <code>withdraw</code> to send USDC to owner.</li> <li>Transfers USDC to owner.</li> </ol>"},{"location":"LedgerExternalFunctions/#trading-operations","title":"Trading Operations","text":""},{"location":"LedgerExternalFunctions/#processbuy","title":"processBuy","text":""},{"location":"LedgerExternalFunctions/#signature_6","title":"Signature","text":"<pre><code>function processBuy(\n    address to,\n    uint256 marketId,\n    uint256 mmId,\n    uint256 positionId,\n    bool isBack,\n    uint256 usdcIn,\n    uint256 tokensOut,\n    uint256 minUSDCDeposited\n)\n    external\n    returns (uint256 recordedUSDC);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_6","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_6","title":"Caller","text":"<p>AMM-Hook</p>"},{"location":"LedgerExternalFunctions/#role_6","title":"Role","text":"<p>Handles buy flow, depositing USDC to Aave and minting back or lay <code>PositionToken</code> tokens. Can mint tokens without USDC (<code>usdcIn = 0</code>).</p>"},{"location":"LedgerExternalFunctions/#flow_6","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code>.</li> <li>If <code>usdcIn &gt; 0</code>, calls <code>deposit</code> with <code>mmId</code>, <code>usdcIn</code>, and <code>minUSDCDeposited</code>.</li> <li>For back tokens:</li> <li>Calls <code>ensureSolvency</code>, updates <code>tilt</code> (negative), mints tokens.</li> <li>For lay tokens:</li> <li>Calls <code>ensureSolvency</code>, decrements <code>marketExposure[mmId]</code>, <code>mmCapitalization[mmId]</code>, <code>globalCapitalization</code>, updates <code>tilt</code> (positive), mints tokens.</li> <li>Emits <code>Bought</code> event with <code>mmId</code>, <code>marketId</code>, <code>positionId</code>, <code>isBack</code>, <code>tokensOut</code>, <code>usdcIn</code>, and <code>recordedUSDC</code>.</li> <li>Emits <code>TiltUpdated</code> event with <code>mmId</code>, <code>marketId</code>, <code>positionId</code>, <code>freeCollateral</code>, <code>marketExposure</code>, and <code>newTilt</code>.</li> </ol>"},{"location":"LedgerExternalFunctions/#returns_4","title":"Returns","text":"<ul> <li><code>recordedUSDC</code>: The actual aUSDC amount recorded.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_3","title":"Note","text":"<p>Caller must approve USDC if <code>usdcIn &gt; 0</code>.</p>"},{"location":"LedgerExternalFunctions/#processsell","title":"processSell","text":""},{"location":"LedgerExternalFunctions/#signature_7","title":"Signature","text":"<pre><code>function processSell(\n    address to,\n    uint256 marketId,\n    uint256 mmId,\n    uint256 positionId,\n    bool isBack,\n    uint256 tokensIn,\n    uint256 usdcOut\n)\n    external;\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_7","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_7","title":"Caller","text":"<p>AMM-Hook</p>"},{"location":"LedgerExternalFunctions/#role_7","title":"Role","text":"<p>Handles sell flow, burning back or lay <code>PositionToken</code> tokens and withdrawing USDC from Aave. Can burn tokens without withdrawing USDC (<code>usdcOut = 0</code>).</p>"},{"location":"LedgerExternalFunctions/#flow_7","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code>.</li> <li>For back tokens:</li> <li>Updates <code>tilt</code> (positive), calls <code>deallocateExcess</code>, burns tokens.</li> <li>For lay tokens:</li> <li>Increments <code>marketExposure[mmId]</code>, <code>mmCapitalization[mmId]</code>, <code>globalCapitalization</code>, updates <code>tilt</code> (negative), calls <code>deallocateExcess</code>, burns tokens.</li> <li>If <code>usdcOut &gt; 0</code>, calls <code>withdraw</code> with <code>mmId</code> and <code>usdcOut</code>.</li> <li>Emits <code>Sold</code> event with <code>mmId</code>, <code>marketId</code>, <code>positionId</code>, <code>isBack</code>, <code>tokensIn</code>, and <code>usdcOut</code>.</li> <li>Emits <code>TiltUpdated</code> event with <code>mmId</code>, <code>marketId</code>, <code>positionId</code>, <code>freeCollateral</code>, <code>marketExposure</code>, and <code>newTilt</code>.</li> </ol>"},{"location":"LedgerExternalFunctions/#note_4","title":"Note","text":"<p>Caller must approve <code>PositionToken</code> for burning.</p>"},{"location":"LedgerExternalFunctions/#liquidity-operations","title":"Liquidity Operations","text":""},{"location":"LedgerExternalFunctions/#transferliquidity","title":"transferLiquidity","text":""},{"location":"LedgerExternalFunctions/#signature_8","title":"Signature","text":"<pre><code>function transferLiquidity(\n    uint256 mmId,\n    address newAddress\n)\n    external;\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_8","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_8","title":"Caller","text":"<p>MM or Owner</p>"},{"location":"LedgerExternalFunctions/#role_8","title":"Role","text":"<p>Transfers all liquidity for an <code>mmId</code> to a new address by updating <code>mmIdToAddress</code>.</p>"},{"location":"LedgerExternalFunctions/#flow_8","title":"Flow","text":"<ol> <li>Verifies <code>mmIdToAddress[mmId] == msg.sender</code> or caller is owner.</li> <li>Updates <code>mmIdToAddress[mmId]</code> to <code>newAddress</code>.</li> <li>Emits <code>LiquidityTransferred</code> event with <code>mmId</code>, <code>msg.sender</code>, and <code>newAddress</code>.</li> </ol>"},{"location":"LedgerExternalFunctions/#getter-functions","title":"Getter Functions","text":""},{"location":"LedgerExternalFunctions/#getpositionliquidity","title":"getPositionLiquidity","text":""},{"location":"LedgerExternalFunctions/#signature_9","title":"Signature","text":"<pre><code>function getPositionLiquidity(\n    uint256 mmId,\n    uint256 marketId,\n    uint256 positionId\n)\n    external\n    view\n    returns (\n        uint256 freeCollateral,\n        uint256 marketExposure,\n        int128 tilt\n    );\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_9","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_9","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_9","title":"Role","text":"<p>Returns the MM\u2019s liquidity details (<code>freeCollateral</code>, <code>marketExposure</code>, <code>tilt</code>) for a specific position.</p>"},{"location":"LedgerExternalFunctions/#returns_5","title":"Returns","text":"<ul> <li><code>freeCollateral</code>: The MM\u2019s free USDC.</li> <li><code>marketExposure</code>: The MM\u2019s exposure in the market.</li> <li><code>tilt</code>: The MM\u2019s tilt for the position.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_5","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"LedgerExternalFunctions/#getmintilt","title":"getMinTilt","text":""},{"location":"LedgerExternalFunctions/#signature_10","title":"Signature","text":"<pre><code>function getMinTilt(\n    uint256 mmId,\n    uint256 marketId\n)\n    external\n    view\n    returns (\n        int128 minTilt,\n        uint256 minPositionId\n    );\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_10","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_10","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_10","title":"Role","text":"<p>Returns the minimum (most negative) tilt and its position ID for an MM in a market.</p>"},{"location":"LedgerExternalFunctions/#returns_6","title":"Returns","text":"<ul> <li><code>minTilt</code>: The minimum (most negative) tilt value.</li> <li><code>minPositionId</code>: The position ID with the minimum tilt.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_6","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"LedgerExternalFunctions/#getmmcapitalization","title":"getMMCapitalization","text":""},{"location":"LedgerExternalFunctions/#signature_11","title":"Signature","text":"<pre><code>function getMMCapitalization(\n    uint256 mmId\n)\n    external\n    view\n    returns (uint256);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_11","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_11","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_11","title":"Role","text":"<p>Retrieves the MM\u2019s capitalization (<code>mmCapitalization[mmId]</code>).</p>"},{"location":"LedgerExternalFunctions/#returns_7","title":"Returns","text":"<ul> <li>The MM\u2019s capitalization for the given <code>mmId</code>.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_7","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"LedgerExternalFunctions/#getinterest","title":"getInterest","text":""},{"location":"LedgerExternalFunctions/#signature_12","title":"Signature","text":"<pre><code>function getInterest()\n    external\n    view\n    returns (uint256);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_12","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_12","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_12","title":"Role","text":"<p>Returns accrued interest (<code>aUSDC.balanceOf - globalCapitalization</code>).</p>"},{"location":"LedgerExternalFunctions/#returns_8","title":"Returns","text":"<ul> <li>The accrued interest amount.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_8","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"LedgerExternalFunctions/#getmarkets","title":"getMarkets","text":""},{"location":"LedgerExternalFunctions/#signature_13","title":"Signature","text":"<pre><code>function getMarkets()\n    external\n    view\n    returns (uint256[] memory);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_13","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_13","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_13","title":"Role","text":"<p>Returns an array of all market IDs.</p>"},{"location":"LedgerExternalFunctions/#returns_9","title":"Returns","text":"<ul> <li>An array of all <code>marketId</code> values.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_9","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"LedgerExternalFunctions/#getmarketpositions","title":"getMarketPositions","text":""},{"location":"LedgerExternalFunctions/#signature_14","title":"Signature","text":"<pre><code>function getMarketPositions(\n    uint256 marketId\n)\n    external\n    view\n    returns (uint256[] memory);\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_14","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_14","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_14","title":"Role","text":"<p>Returns an array of position IDs for a given <code>marketId</code>.</p>"},{"location":"LedgerExternalFunctions/#returns_10","title":"Returns","text":"<ul> <li>An array of <code>positionId</code> values for the specified <code>marketId</code>.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_10","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"LedgerExternalFunctions/#getmarketdetails","title":"getMarketDetails","text":""},{"location":"LedgerExternalFunctions/#signature_15","title":"Signature","text":"<pre><code>function getMarketDetails(\n    uint256 marketId\n)\n    external\n    view\n    returns (\n        string memory name,\n        string memory ticker\n    );\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_15","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_15","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_15","title":"Role","text":"<p>Returns the name and ticker for a given <code>marketId</code>.</p>"},{"location":"LedgerExternalFunctions/#returns_11","title":"Returns","text":"<ul> <li><code>name</code>: The market\u2019s name.</li> <li><code>ticker</code>: The market\u2019s ticker.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_11","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"LedgerExternalFunctions/#getpositiondetails","title":"getPositionDetails","text":""},{"location":"LedgerExternalFunctions/#signature_16","title":"Signature","text":"<pre><code>function getPositionDetails(\n    uint256 marketId,\n    uint256 positionId\n)\n    external\n    view\n    returns (\n        string memory name,\n        string memory ticker,\n        address backToken,\n        address layToken\n    );\n</code></pre>"},{"location":"LedgerExternalFunctions/#details_16","title":"Details","text":""},{"location":"LedgerExternalFunctions/#caller_16","title":"Caller","text":"<p>Unrestricted</p>"},{"location":"LedgerExternalFunctions/#role_16","title":"Role","text":"<p>Returns the name, ticker, and back/lay token addresses for a given <code>marketId</code> and <code>positionId</code>.</p>"},{"location":"LedgerExternalFunctions/#returns_12","title":"Returns","text":"<ul> <li><code>name</code>: The position\u2019s name.</li> <li><code>ticker</code>: The position\u2019s ticker.</li> <li><code>backToken</code>: The address of the back <code>PositionToken</code>.</li> <li><code>layToken</code>: The address of the lay <code>PositionToken</code>.</li> </ul>"},{"location":"LedgerExternalFunctions/#note_12","title":"Note","text":"<p>View function, no state changes.</p>"},{"location":"TransactionFlowChart/","title":"TransactionFlowChart","text":""},{"location":"TransactionFlowChart/#function-shapes","title":"Function Shapes","text":"<p>The following are the key function signatures involved in the buy and sell flows and liquidity transfer:</p> <pre><code>// Hook \u2190 PoolManager (afterSwap entry, Uniswap V4 standard)\nfunction afterSwap(\n  address to,\n  PoolKey calldata poolKey,\n  SwapParams calldata swapParams,\n  int256 delta,\n  bytes calldata hookData\n) external returns (bytes4, int256);\n\n// Hook \u2192 Ledger (processes buy flow: USDC to Aave, compute delta, mint tokens)\nfunction processBuy(\n  address to,\n  uint256 marketId,\n  uint256 AMMId,\n  uint256 tokenId,\n  uint256 usdcIn,\n  uint256 tokensOut\n) external;\n\n// Hook \u2192 Ledger (processes sell flow: burn tokens, withdraw USDC from Aave)\nfunction processSell(\n  address to,\n  uint256 marketId,\n  uint256 AMMId,\n  uint256 tokenId,\n  uint256 tokensIn,\n  uint256 usdcOut\n) external;\n\n// Hook (transfer liquidity ownership, called by owner)\nfunction transferLiquidity(\n  uint256 marketId,\n  address newAddress,\n) external;\n\n\n//Ledger - Read Balances\nfucntion readBalances(\n  uint256 marketId\n  uint256 AMMId\n) view\n\n// Ledger \u2192 PositionToken (mint tokens for buy flow)\nfunction mint(\n  address to,\n  uint256 marketId,\n  uint266 AMMId,\n  uint256 tokenId,\n  uint256 amount\n) external;\n\n// Ledger \u2192 PositionToken (burn tokens for sell flow)\nfunction burn(\n  address from,\n  uint256 marketId,\n  uint256 AMMId,\n  uint256 tokenId,\n  uint256 amount\n) external;\n\n// Ledger (update liquidity ownership, called by Hook)\nfunction transferLiquidity(\n  address newAddress,\n  uint256 marketId,\n  uint256 AMMId,\n) external;\n\n// Ledger (internal, consolidates delta computation and state updates)\nfunction updateBalances(\n\n) internal;\n\n// --- Types ---\nstruct PoolKey {\n  address token0;\n  address token1;\n  uint24 fee;\n  int24 tickSpacing;\n  address hooks;\n}\n\nstruct SwapParams {\n  bool zeroForOne;\n  int256 amountSpecified;\n  uint160 sqrtPriceLimitX96;\n}\n</code></pre>"},{"location":"TransactionFlowChart/#buy-flow-usdc-token","title":"Buy Flow (USDC \u2192 Token)","text":"<ol> <li>PoolManager \u2192 Hook: <code>afterSwap(to, poolKey, swapParams, delta, hookData)</code></li> <li>Hook \u2192 USDC: <code>transferFrom(PoolManager, Hook, usdcIn)</code> </li> <li>Hook \u2192 Ledger: <code>readBalances(marketId, AMMId)</code> </li> <li>Hook (internal): <code>computeOutput</code> </li> <li>Ledger \u2192 USDC: <code>transferFrom(Hook, Ledger, usdcIn)</code></li> <li>Hook \u2192 Ledger: <code>processBuy(to, marketId, AMMId, tokenId, usdcIn, tokensOut)</code> </li> <li>Ledger \u2192 AavePool: <code>supply(USDC, usdcIn, onBehalfOf = Ledger)</code> </li> <li>AavePool \u2192 USDC: <code>transferFrom(Ledger, Aave, usdcIn)</code></li> <li>AavePool \u2192 aUSDC: <code>mint(Ledger, minted)</code></li> <li>Ledger (internal): <code>updateBalances()</code> </li> <li>Ledger \u2192 PositionToken: <code>mint(to, marketId, AMMId, tokenId, tokensOut)</code> </li> <li>Hook \u2192 PoolManager: <code>return (selector, delta)</code></li> </ol>"},{"location":"TransactionFlowChart/#sell-flow-token-usdc","title":"Sell Flow (Token \u2192 USDC)","text":"<ol> <li>PoolManager \u2192 Hook: <code>afterSwap(to, poolKey, swapParams, delta, hookData)</code> </li> <li>Hook \u2192 PositionToken: <code>transferFrom(PoolManager, Hook, tokensIn)</code> </li> <li>Hook \u2192 Ledger: <code>readBalances(marketId, AMMId)</code> </li> <li>Hook (internal): <code>computeOutput</code></li> <li>Hook \u2192 Ledger: <code>processSell(to, marketId, AMMId, tokenId, tokensIn, usdcOut)</code></li> <li>Ledger \u2192 PositionToken: <code>burn(Hook, marketId, AMMId, tokenId, tokensIn)</code> </li> <li>Ledger \u2192 AavePool: <code>withdraw(USDC, usdcOut, to)</code> </li> <li>AavePool \u2192 aUSDC: <code>burn(Ledger, usdcOut)</code> </li> <li>AavePool \u2192 USDC: <code>transfer(to, usdcOut)</code></li> <li>Ledger (internal): <code>updateBalances()</code> </li> <li>Hook \u2192 PoolManager: <code>return (selector, delta)</code></li> </ol>"},{"location":"TransactionFlowChart/#liquidity-transfer","title":"Liquidity Transfer","text":"<ol> <li>Hook Owner \u2192 Hook: <code>transferLiquidity(newAddress, marketId, tokenId)</code></li> <li>Hook \u2192 Ledger: <code>transferLiquidity(newAddress, marketId, tokenId)</code></li> <li>Ledger (internal): Update liquidity ownership from Hook to <code>newAddress</code> for <code>(marketId, tokenId)</code></li> </ol>"},{"location":"TransactionFlowChart/#sequence-diagram-buy-flow-usdc-token","title":"Sequence Diagram - Buy Flow (USDC \u2192 Token)","text":"%%{init: {\"sequence\": {\"actorMargin\": 8, \"messageMargin\": 6, \"diagramPadding\": 2, \"mirrorActors\": false}}}%% sequenceDiagram     autonumber     participant PM as PoolManager      box rgb(255, 251, 224)       participant H as AMM -Hook       participant LG as Ledger       participant PT as PosToken     end      participant AV as Aave     participant aU as aUSDC     participant USD as USDC      PM-&gt;&gt;H: afterSwap     H-&gt;&gt;USD: transferFrom     H-&gt;&gt;LG: readBalances     H-&gt;&gt;H: computeOutput (Run AMM)     H-&gt;&gt;LG: processBuy     LG-&gt;&gt;USD: transferFrom     LG-&gt;&gt;AV: supply     AV-&gt;&gt;USD: transfer     AV-&gt;&gt;aU: mint      LG-&gt;&gt;LG: updateBalances      LG-&gt;&gt;PT: mint     H-&gt;&gt;PM: return"},{"location":"TransactionFlowChart/#sequence-diagram-sell-flow-token-usdc","title":"Sequence Diagram - Sell Flow (Token \u2192 USDC)","text":"%%{init: {\"sequence\": {\"actorMargin\": 8, \"messageMargin\": 6, \"diagramPadding\": 2, \"mirrorActors\": false}}}%% sequenceDiagram     autonumber     participant PM as PoolManager      box rgb(255, 251, 224)       participant H as AMM-Hook       participant LG as Ledger       participant PT as PosToken     end      participant AV as Aave     participant aU as aUSDC     participant USD as USDC      PM-&gt;&gt;H: afterSwap     H-&gt;&gt;PT: transferFrom     H-&gt;&gt;LG: readBalances     H-&gt;&gt;H: computeOutput (Run AMM)     H-&gt;&gt;LG: processSell     LG-&gt;&gt;PT: burn     LG-&gt;&gt;AV: withdraw     AV-&gt;&gt;aU: burn     AV-&gt;&gt;USD: transfer     LG-&gt;&gt;LG: updateBalances      H-&gt;&gt;PM: return"},{"location":"TransactionFlowChart/#_1","title":"TransactionFlowChart","text":""},{"location":"test/","title":"Test Solidity Highlighting","text":"<p>As cat &gt; ~/Projects/PredictionPerpsDocs/docs/test.md &lt;&lt;'MD'</p>"},{"location":"test/#test-solidity-highlightingsoliditycontract-c","title":"Test Solidity Highlightingsoliditycontract C {","text":"<pre><code>function f(address a) external view returns (uint256) {\n    uint x = 0;\n}\n</code></pre> <p>}</p>"},{"location":"images/CMC/","title":"Composite Market Controller Contract Design","text":""},{"location":"images/CMC/#overview","title":"Overview","text":"<p>The Composite Market Controller contract serves as the central manager for a prediction market system.</p>"},{"location":"images/CMC/#market-control-responsibilities","title":"Market Control Responsibilities","text":"<p>This contract handles creating, minting, and burning ERC-20 tokens for \"back\" (betting on an outcome) and \"lay\" (betting against an outcome) positions.</p>"},{"location":"images/CMC/#ledger-management-responsibilities","title":"Ledger Management Responsibilities","text":"<p>An internal ledger tracks positions for each market maker, ensuring non negative collateralization.</p> <p>The contract supports dynamic or unknown numbers of outcomes (\\( n \\)) without requiring \\( O(n) \\) operations. It employs a gas-efficient ledger for position tracking and token issuance.</p>"},{"location":"images/CMC/#key-features-and-advantages","title":"Key Features and Advantages","text":""},{"location":"images/CMC/#ledger-based-accounting","title":"Ledger-Based Accounting","text":"<p>Virtualizes market maker positions to reduce gas costs, with lazy minting/burning of ERC-20 tokens performed only when requested by the market maker. This approach minimizes unnecessary token operations - splits, merges, batch minting, leading to lower transaction fees and faster processing, and more flexibility for market makers.</p>"},{"location":"images/CMC/#dynamic-outcomes","title":"Dynamic Outcomes","text":"<p>The contract accommodates arbitrary or expanding number of positions (or outcomes) without a predefined \\( n \\), utilizing sparse storage. This flexibility allows the system to handle evolving markets, such as those with user-generated outcomes, without performance degradation.</p>"},{"location":"images/CMC/#gas-efficiency","title":"Gas Efficiency","text":"<p>Core operations (deposits, redemptions, mints, burns) are \\( O(1) \\), typically consuming ~15k\u201330k gas. Such efficiency makes the contract suitable for high-frequency trading environments, and for markets with many positions.</p>"},{"location":"images/CMC/#non-negative-collateralization","title":"Non negative Collateralization","text":"<p>Guarantees market is fully colaterarised through guaranteeing each market maker's ledger is non negative. This ensures the system's financial integrity.</p> <p>This design promotes scalability for large or unknown \\( n \\), optimizes gas usage, and upholds positive collateralization (\\( v &gt; 0 \\)), effectively controlling the market and tracking CAMM positions.</p>"},{"location":"newOld/Libraries.sol/","title":"Libraries.sol","text":"<pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// === Types and Constants ===\nlibrary Types {\n    uint256 constant BLOCK_SIZE = 16;\n\n    struct BlockData {\n        uint256 minId; // Position ID of minimum tilt\n        int128 minVal; // Minimum tilt value\n        int128 secondMinVal; // Second minimum tilt value\n    }\n}\n\n// === Storage Management ===\nlibrary StorageLib {\n    struct Storage {\n        IERC20 usdc;\n        IERC20 aUSDC;\n        IAavePool aavePool;\n        address owner;\n        uint256 globalCapitalization; // Sum of all mmCapitalization\n        mapping(uint256 =&gt; address) mmIdToAddress; // MMId -&gt; MM address\n        uint256 nextMMId; // Next available MMId\n        mapping(uint256 =&gt; uint256) freeCollateral; // MMId -&gt; free USDC\n        mapping(uint256 =&gt; mapping(uint256 =&gt; uint256)) marketExposure; // MMId -&gt; market_id -&gt; USDC\n        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; int128))) tilt; // MMId -&gt; market_id -&gt; position_id -&gt; tilt\n        mapping(uint256 =&gt; uint256) mmCapitalization; // MMId -&gt; freeCollateral + sum(marketExposure)\n        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(bool =&gt; address))) tokenAddresses; // market_id -&gt; position_id -&gt; isBack -&gt; token address\n        mapping(uint256 =&gt; mapping(uint256 =&gt; mapping(uint256 =&gt; Types.BlockData))) blockData; // MMId -&gt; market_id -&gt; block_id -&gt; BlockData\n        mapping(uint256 =&gt; mapping(uint256 =&gt; uint256[])) topHeap; // MMId -&gt; market_id -&gt; heap of block indices\n        uint256 nextMarketId;\n        uint256[] allMarkets;\n        mapping(uint256 =&gt; string) marketNames;\n        mapping(uint256 =&gt; string) marketTickers;\n        mapping(uint256 =&gt; uint256) nextPositionId; // marketId -&gt; next positionId\n        mapping(uint256 =&gt; uint256[]) marketPositions; // marketId -&gt; list of positionIds\n        mapping(uint256 =&gt; mapping(uint256 =&gt; string)) positionNames; // marketId -&gt; positionId -&gt; name\n        mapping(uint256 =&gt; mapping(uint256 =&gt; string)) positionTickers; // marketId -&gt; positionId -&gt; ticker\n    }\n\n    function getStorage() internal pure returns (Storage storage s) {\n        bytes32 position = keccak256(\"MarketMakerLedger.storage\");\n        assembly {\n            s.slot := position\n        }\n    }\n}\n\n// === Deposit and Withdraw Operations ===\nlibrary DepositWithdrawLib {\n    //region DepositWithdraw\n    /// @notice Deposits USDC to MM's freeCollateral, supplies to Aave, updates capitalizations\n    /// @param mmId The market maker's ID\n    /// @param amount The intended USDC deposit amount\n    /// @param minUSDCDeposited The minimum USDC amount to record (optional, 0 if not enforced)\n    /// @return recordedAmount The actual aUSDC amount received and recorded\n    function deposit(uint256 mmId, uint256 amount, uint256 minUSDCDeposited) internal returns (uint256 recordedAmount) {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        require(s.usdc.transferFrom(s.mmIdToAddress[mmId], address(this), amount), \"Transfer failed\");\n        s.usdc.approve(address(s.aavePool), amount);\n\n        uint256 aUSDCBefore = s.aUSDC.balanceOf(address(this));\n        s.aavePool.supply(address(s.usdc), amount, address(this), 0);\n        uint256 aUSDCAfter = s.aUSDC.balanceOf(address(this));\n        recordedAmount = aUSDCAfter - aUSDCBefore;\n\n        require(recordedAmount &gt;= minUSDCDeposited, \"Deposit below minimum\");\n        s.freeCollateral[mmId] += recordedAmount;\n        s.mmCapitalization[mmId] += recordedAmount;\n        s.globalCapitalization += recordedAmount;\n    }\n\n    /// @notice Withdraws USDC from MM's freeCollateral, pulls from Aave, updates capitalizations\n    /// @param mmId The market maker's ID\n    /// @param amount The USDC amount to withdraw\n    function withdraw(uint256 mmId, uint256 amount) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        require(s.mmIdToAddress[mmId] == msg.sender, \"Invalid MMId\");\n        require(s.freeCollateral[mmId] &gt;= amount, \"Insufficient free collateral\");\n        require(s.usdc.balanceOf(address(this)) &gt;= amount, \"Insufficient contract balance\");\n        s.freeCollateral[mmId] -= amount;\n        s.mmCapitalization[mmId] -= amount;\n        s.globalCapitalization -= amount;\n        s.aavePool.withdraw(address(s.usdc), amount, s.mmIdToAddress[mmId]);\n    }\n\n    /// @notice Withdraws accrued interest (aUSDC.balance - globalCapitalization) to owner\n    function withdrawInterest(address sender) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        require(sender == s.owner, \"Only owner\");\n        uint256 interest = getInterest();\n        if (interest &gt; 0) {\n            s.aavePool.withdraw(address(s.usdc), interest, s.owner);\n            require(s.usdc.transfer(s.owner, interest), \"Transfer failed\");\n        }\n    }\n\n    /// @notice Returns current interest accrued\n    function getInterest() internal view returns (uint256) {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        return s.aUSDC.balanceOf(address(this)) - s.globalCapitalization;\n    }\n    //endregion DepositWithdraw\n}\n\n// === Token Emission and Burning Operations ===\nlibrary TokenOpsLib {\n    //region TokenOps\n    /// @notice Mints Back or Lay tokens for marketId, positionId, isBack to address to\n    function mintToken(uint256 marketId, uint256 positionId, bool isBack, uint256 amount, address to) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        address token = s.tokenAddresses[marketId][positionId][isBack];\n        require(token != address(0), \"Invalid token address\");\n        IPositionToken(token).mint(to, amount);\n    }\n\n    /// @notice Burns Back or Lay tokens for marketId, positionId, isBack from address from (requires approval)\n    function burnToken(uint256 marketId, uint256 positionId, bool isBack, uint256 amount, address from) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        address token = s.tokenAddresses[marketId][positionId][isBack];\n        require(token != address(0), \"Invalid token address\");\n        IPositionToken(token).burnFrom(from, amount);\n    }\n\n    // Add new token-related functions here, e.g., batch minting, token address updates\n    //endregion TokenOps\n}\n\n// === Solvency Management ===\nlibrary SolvencyLib {\n    //region Solvency\n    /// @notice Ensures H_k &gt;= 0 after tilt/exposure change, pulling from freeCollateral if needed\n    function ensureSolvency(uint256 mmId, uint256 marketId, uint256 positionId, int128 tiltChange, int128 exposureChange) internal {\n        (int128 minVal, ) = HeapLib.getMinTilt(mmId, marketId);\n        int128 minH_k = minVal + exposureChange;\n        if (tiltChange &gt; 0 &amp;&amp; positionId == HeapLib.getMinTiltPosition(mmId, marketId)) {\n            minH_k = minH_k &lt; tiltChange ? minH_k : tiltChange;\n        }\n        if (minH_k &lt; 0) {\n            StorageLib.Storage storage s = StorageLib.getStorage();\n            uint256 shortfall = uint256(-minH_k);\n            require(s.freeCollateral[mmId] &gt;= shortfall, \"Insufficient free collateral\");\n            s.freeCollateral[mmId] -= shortfall;\n            s.marketExposure[mmId][marketId] += shortfall;\n        }\n    }\n\n    /// @notice Deallocates excess marketExposure to freeCollateral based on min H_k\n    function deallocateExcess(uint256 mmId, uint256 marketId) internal {\n        (int128 minVal, ) = HeapLib.getMinTilt(mmId, marketId);\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        uint256 amount = uint256(int256(s.marketExposure[mmId][marketId]) + minVal);\n        if (amount &gt; 0 &amp;&amp; amount &lt;= s.marketExposure[mmId][marketId]) {\n            s.marketExposure[mmId][marketId] -= amount;\n            s.freeCollateral[mmId] += amount;\n        }\n    }\n\n    // Add new solvency-related functions here, e.g., bulk solvency checks\n    //endregion Solvency\n}\n\n// === Heap and Tilt Management ===\nlibrary HeapLib {\n    //region Tilt Management\n    /// @notice Updates tilt and block-min + top-heap for position k by delta\n    function updateTilt(uint256 mmId, uint256 marketId, uint256 positionId, int128 delta) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        uint256 blockId = positionId / Types.BLOCK_SIZE;\n        Types.BlockData storage block = s.blockData[mmId][marketId][blockId];\n        int128 newTilt = s.tilt[mmId][marketId][positionId] + delta;\n        s.tilt[mmId][marketId][positionId] = newTilt;\n\n        if (positionId != block.minId &amp;&amp; newTilt &gt;= block.secondMinVal) return;\n        if (positionId != block.minId &amp;&amp; newTilt &lt; block.minVal) {\n            block.secondMinVal = block.minVal;\n            block.minVal = newTilt;\n            block.minId = positionId;\n            updateTopHeap(mmId, marketId, blockId);\n            return;\n        }\n        if (positionId == block.minId) {\n            if (newTilt &lt;= block.minVal) {\n                block.minVal = newTilt;\n                updateTopHeap(mmId, marketId, blockId);\n                return;\n            }\n            rescanBlock(mmId, marketId, blockId);\n        }\n    }\n    //endregion Tilt Management\n\n    //region Block Scanning\n    /// @notice Rescans block to update minId, minVal, secondMinVal\n    function rescanBlock(uint256 mmId, uint256 marketId, uint256 blockId) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        uint256 start = blockId * Types.BLOCK_SIZE;\n        uint256 end = start + Types.BLOCK_SIZE;\n        uint256[] memory positions = MarketManagementLib.getMarketPositions(marketId);\n        if (end &gt; positions.length) end = positions.length;\n\n        int128 minVal = type(int128).max;\n        int128 secondMinVal = type(int128).max;\n        uint256 minId = 0;\n        for (uint256 i = start; i &lt; end; i++) {\n            uint256 k = positions[i];\n            int128 val = s.tilt[mmId][marketId][k];\n            if (val &lt; minVal) {\n                secondMinVal = minVal;\n                minVal = val;\n                minId = k;\n            } else if (val &lt; secondMinVal) {\n                secondMinVal = val;\n            }\n        }\n\n        Types.BlockData storage block = s.blockData[mmId][marketId][blockId];\n        block.minVal = minVal;\n        block.minId = minId;\n        block.secondMinVal = secondMinVal;\n        updateTopHeap(mmId, marketId, blockId);\n    }\n    //endregion Block Scanning\n\n    //region Heap Operations\n    /// @notice Updates top-heap for blockId (4-ary heap)\n    function updateTopHeap(uint256 mmId, uint256 marketId, uint256 blockId) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        uint256[] storage heap = s.topHeap[mmId][marketId];\n        uint256 index = findHeapIndex(heap, blockId);\n        int128 newVal = s.blockData[mmId][marketId][blockId].minVal;\n\n        bubbleUp(heap, index, newVal, mmId, marketId);\n        bubbleDown(heap, index, newVal, mmId, marketId);\n        heap[index] = blockId;\n    }\n\n    /// @notice Finds the index of blockId in the heap\n    function findHeapIndex(uint256[] storage heap, uint256 blockId) private view returns (uint256) {\n        for (uint256 i = 0; i &lt; heap.length; i++) {\n            if (heap[i] == blockId) return i;\n        }\n        return 0; // Default to root if not found\n    }\n\n    /// @notice Bubbles up the heap to maintain min-heap property\n    function bubbleUp(uint256[] storage heap, uint256 index, int128 newVal, uint256 mmId, uint256 marketId) private {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        while (index &gt; 0) {\n            uint256 parent = (index - 1) / 4;\n            if (s.blockData[mmId][marketId][heap[parent]].minVal &lt;= newVal) break;\n            heap[index] = heap[parent];\n            index = parent;\n        }\n    }\n\n    /// @notice Bubbles down the heap to maintain min-heap property\n    function bubbleDown(uint256[] storage heap, uint256 index, int128 newVal, uint256 mmId, uint256 marketId) private {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        while (true) {\n            uint256 minChild = index;\n            int128 minChildVal = newVal;\n            for (uint256 i = 1; i &lt;= 4; i++) {\n                uint256 child = index * 4 + i;\n                if (child &gt;= heap.length) break;\n                if (s.blockData[mmId][marketId][heap[child]].minVal &lt; minChildVal) {\n                    minChild = child;\n                    minChildVal = s.blockData[mmId][marketId][heap[child]].minVal;\n                }\n            }\n            if (minChild == index) break;\n            heap[index] = heap[minChild];\n            index = minChild;\n        }\n    }\n    //endregion Heap Operations\n\n    //region Getters\n    /// @notice Returns (minVal, minId) for MM's market\n    function getMinTilt(uint256 mmId, uint256 marketId) internal view returns (int128, uint256) {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        uint256[] memory heap = s.topHeap[mmId][marketId];\n        if (heap.length == 0) return (0, 0);\n        uint256 blockId = heap[0];\n        Types.BlockData memory block = s.blockData[mmId][marketId][blockId];\n        return (block.minVal, block.minId);\n    }\n\n    /// @notice Returns positionId of min tilt\n    function getMinTiltPosition(uint256 mmId, uint256 marketId) internal view returns (uint256) {\n        (, uint256 minId) = getMinTilt(mmId, marketId);\n        return minId;\n    }\n    //endregion Getters\n\n    //region Future Extensions\n    // Add new heap-related functions here, e.g., bulk tilt updates, heap initialization\n    //endregion Future Extensions\n}\n\n// === Market and Position Management ===\nlibrary MarketManagementLib {\n    //region MarketManagement\n    event MarketCreated(uint256 indexed marketId, string name, string ticker);\n    event PositionCreated(uint256 indexed marketId, uint256 indexed positionId, string name, string ticker);\n\n    /// @notice Creates a new market with name and ticker\n    function createMarket(string memory name, string memory ticker) internal returns (uint256 marketId) {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        marketId = s.nextMarketId++;\n        s.marketNames[marketId] = name;\n        s.marketTickers[marketId] = ticker;\n        s.allMarkets.push(marketId);\n        emit MarketCreated(marketId, name, ticker);\n    }\n\n    /// @notice Creates a new position in a market with name and ticker, deploys back/lay ERC20 tokens\n    function createPosition(uint256 marketId, string memory name, string memory ticker) internal returns (uint256 positionId) {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        require(bytes(s.marketNames[marketId]).length &gt; 0, \"Market does not exist\");\n        positionId = s.nextPositionId[marketId]++;\n        s.positionNames[marketId][positionId] = name;\n        s.positionTickers[marketId][positionId] = ticker;\n        s.marketPositions[marketId].push(positionId);\n\n        // Deploy back token with name \"Back [nameOfPosition] [nameOfMarket]\" and ticker \"B[positionTicker][marketTicker]\"\n        PositionToken backToken = new PositionToken(\n            string.concat(\"Back \", name, \" \", s.marketNames[marketId]),\n            string.concat(\"B\", ticker, s.marketTickers[marketId]),\n            address(this)\n        );\n        s.tokenAddresses[marketId][positionId][true] = address(backToken);\n\n        // Deploy lay token with name \"Lay [nameOfPosition] [nameOfMarket]\" and ticker \"L[positionTicker][marketTicker]\"\n        PositionToken layToken = new PositionToken(\n            string.concat(\"Lay \", name, \" \", s.marketNames[marketId]),\n            string.concat(\"L\", ticker, s.marketTickers[marketId]),\n            address(this)\n        );\n        s.tokenAddresses[marketId][positionId][false] = address(layToken);\n\n        emit PositionCreated(marketId, positionId, name, ticker);\n    }\n\n    /// @notice Returns list of position IDs for a market\n    function getMarketPositions(uint256 marketId) internal view returns (uint256[] memory) {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        return s.marketPositions[marketId];\n    }\n\n    /// @notice Returns list of all market IDs\n    function getMarkets() internal view returns (uint256[] memory) {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        return s.allMarkets;\n    }\n\n    // Add new market/position functions here, e.g., updateMarketName, settleMarket, deletePosition\n    //endregion MarketManagement\n}\n\n// === Liquidity Management ===\nlibrary LiquidityLib {\n    //region Liquidity\n    /// @notice Transfers all liquidity for an MMId to a new address\n    /// @param mmId The market maker's ID\n    /// @param newAddress The new address to own the MMId\n    function transferLiquidity(uint256 mmId, address newAddress) internal {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        require(s.mmIdToAddress[mmId] == msg.sender || msg.sender == s.owner, \"Unauthorized\");\n        require(newAddress != address(0), \"Invalid address\");\n        s.mmIdToAddress[mmId] = newAddress;\n    }\n    //endregion Liquidity\n}\n\n// === Ledger Reading Operations ===\nlibrary LedgerLib {\n    //region Ledger\n    /// @notice Reads all MM balances across all markets\n    /// @param mmId The market maker's ID\n    /// @return freeCollateral The MM's free USDC\n    /// @return mmCapitalization The MM's total capitalization\n    /// @return marketIds Array of market IDs\n    /// @return marketExposures Array of exposure values for each market\n    /// @return positionIds Array of position IDs for each market\n    /// @return tilts Array of tilt arrays for each market's positions\n    function readAllBalances(uint256 mmId)\n        internal\n        view\n        returns (\n            uint256 freeCollateral,\n            uint256 mmCapitalization,\n            uint256[] memory marketIds,\n            uint256[] memory marketExposures,\n            uint256[][] memory positionIds,\n            int128[][] memory tilts\n        )\n    {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        freeCollateral = s.freeCollateral[mmId];\n        mmCapitalization = s.mmCapitalization[mmId];\n        marketIds = MarketManagementLib.getMarkets();\n        marketExposures = new uint256[](marketIds.length);\n        positionIds = new uint256[][](marketIds.length);\n        tilts = new int128[][](marketIds.length);\n\n        for (uint256 i = 0; i &lt; marketIds.length; i++) {\n            uint256 marketId = marketIds[i];\n            marketExposures[i] = s.marketExposure[mmId][marketId];\n            positionIds[i] = MarketManagementLib.getMarketPositions(marketId);\n            tilts[i] = new int128[](positionIds[i].length);\n            for (uint256 j = 0; j &lt; positionIds[i].length; j++) {\n                tilts[i][j] = s.tilt[mmId][marketId][positionIds[i][j]];\n            }\n        }\n    }\n\n    /// @notice Reads MM's balances for a specific market\n    /// @param mmId The market maker's ID\n    /// @param marketId The market ID\n    /// @return freeCollateral The MM's free USDC\n    /// @return mmCapitalization The MM's total capitalization\n    /// @return marketExposure The MM's exposure in the market\n    /// @return positionIds Array of position IDs in the market\n    /// @return tilts Array of tilt values for each position\n    function readBalances(uint256 mmId, uint256 marketId)\n        internal\n        view\n        returns (\n            uint256 freeCollateral,\n            uint256 mmCapitalization,\n            uint256 marketExposure,\n            uint256[] memory positionIds,\n            int128[] memory tilts\n        )\n    {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        freeCollateral = s.freeCollateral[mmId];\n        mmCapitalization = s.mmCapitalization[mmId];\n        marketExposure = s.marketExposure[mmId][marketId];\n        positionIds = MarketManagementLib.getMarketPositions(marketId);\n        tilts = new int128[](positionIds.length);\n        for (uint256 i = 0; i &lt; positionIds.length; i++) {\n            tilts[i] = s.tilt[mmId][marketId][positionIds[i]];\n        }\n    }\n\n    /// @notice Returns MM's free collateral\n    /// @param mmId The market maker's ID\n    /// @return The MM's free USDC\n    function getFreeCollateral(uint256 mmId) internal view returns (uint256) {\n        return StorageLib.getStorage().freeCollateral[mmId];\n    }\n\n    /// @notice Returns MM's exposure for a market\n    /// @param mmId The market maker's ID\n    /// @param marketId The market ID\n    /// @return The MM's exposure in the market\n    function getMarketExposure(uint256 mmId, uint256 marketId) internal view returns (uint256) {\n        return StorageLib.getStorage().marketExposure[mmId][marketId];\n    }\n\n    /// @notice Returns MM's tilt for a position\n    /// @param mmId The market maker's ID\n    /// @param marketId The market ID\n    /// @param positionId The position ID\n    /// @return The MM's tilt for the position\n    function getTilt(uint256 mmId, uint256 marketId, uint256 positionId) internal view returns (int128) {\n        return StorageLib.getStorage().tilt[mmId][marketId][positionId];\n    }\n\n    /// @notice Returns MM's liquidity details for a specific position\n    /// @param mmId The market maker's ID\n    /// @param marketId The market ID\n    /// @param positionId The position ID\n    /// @return freeCollateral The MM's free USDC\n    /// @return marketExposure The MM's exposure in the market\n    /// @return tilt The MM's tilt for the position\n    function getPositionLiquidity(uint256 mmId, uint256 marketId, uint256 positionId)\n        internal\n        view\n        returns (\n            uint256 freeCollateral,\n            uint256 marketExposure,\n            int128 tilt\n        )\n    {\n        StorageLib.Storage storage s = StorageLib.getStorage();\n        freeCollateral = s.freeCollateral[mmId];\n        marketExposure = s.marketExposure[mmId][marketId];\n        tilt = s.tilt[mmId][marketId][positionId];\n    }\n\n    /// @notice Returns the minimum tilt and its position ID for an MM in a market\n    /// @param mmId The market maker's ID\n    /// @param marketId The market ID\n    /// @return minTilt The minimum (most negative) tilt value\n    /// @return minPositionId The position ID with the minimum tilt\n    function getMinTilt(uint256 mmId, uint256 marketId) internal view returns (int128 minTilt, uint256 minPositionId) {\n        return HeapLib.getMinTilt(mmId, marketId);\n    }\n    //endregion Ledger\n}\n</code></pre>"},{"location":"old/","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"old/#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"old/#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"old/CAMMBehindHook/","title":"How to Implement a CAMM Behind a Uniswap V4 Hook","text":""},{"location":"old/CAMMBehindHook/#integration-mechanism","title":"Integration Mechanism","text":"<ul> <li>CAMM: Calculates buy and sell prices for all composite market tokens (e.g., BackLiverpool, LayLiverpool, BackManchesterCity) using a single pricing model (e.g., LMSR or custom). It manages liquidity to fulfill trades across the market, including token-to-token swaps.</li> <li>Uniswap V4 Hook: A smart contract linked to Uniswap V4 pools at creation, routing trade requests from each pool (e.g., USDC/BackLiverpool, BackLiverpool/BackManchesterCity) to the CAMM for pricing and fulfillment.</li> </ul>"},{"location":"old/CAMMBehindHook/#flow-usdc-composite-market-token-eg-backliverpool","title":"Flow: USDC \u2192 Composite Market Token (e.g., BackLiverpool)","text":"<ol> <li>A user sends USDC to a Uniswap pool to buy BackLiverpool tokens.</li> <li>The hook routes the trade details (USDC amount, requested token) to the CAMM.</li> <li>The CAMM calculates the price for BackLiverpool tokens and provides them from its liquidity.</li> <li>The CAMM sends BackLiverpool tokens to the hook.</li> <li>The hook settles the trade via Uniswap, delivering BackLiverpool tokens to the user.</li> </ol>"},{"location":"old/CAMMBehindHook/#flow-composite-market-token-usdc-eg-backliverpool","title":"Flow: Composite Market Token \u2192 USDC (e.g., BackLiverpool)","text":"<ol> <li>A user sends BackLiverpool tokens to a Uniswap pool to receive USDC.</li> <li>The hook routes the trade details (token amount, requested USDC) to the CAMM.</li> <li>The CAMM calculates the price for BackLiverpool tokens and provides USDC from its liquidity.</li> <li>The CAMM sends USDC to the hook.</li> <li>The hook settles the trade via Uniswap, delivering USDC to the user.</li> </ol>"},{"location":"old/CAMMBehindHook/#flow-composite-market-token-composite-market-token-eg-backliverpool-backmanchestercity","title":"Flow: Composite Market Token \u2192 Composite Market Token (e.g., BackLiverpool \u2192 BackManchesterCity)","text":"<ol> <li>A user sends BackLiverpool tokens to a Uniswap pool to receive BackManchesterCity tokens.</li> <li>The hook routes the trade details (input token amount, input token, output token) to the CAMM.</li> <li>The CAMM calculates the effective price between BackLiverpool and BackManchesterCity tokens and provides BackManchesterCity tokens from its liquidity.</li> <li>The CAMM sends BackManchesterCity tokens to the hook.</li> <li>The hook settles the trade via Uniswap, delivering BackManchesterCity tokens to the user.</li> </ol>"},{"location":"old/CAMMOptions/","title":"Composite AMM Pricing Overview","text":""},{"location":"old/CAMMOptions/#key-properties","title":"Key Properties","text":"<ul> <li> <p>Centralized Pricing   The CAMM sets prices for all outcomes in one place, ensuring consistency across the entire market.  </p> </li> <li> <p>Always-On Liquidity   Traders can buy or sell at any time without waiting for a counterparty.  </p> </li> <li> <p>Path Independence   The cost to move from one state to another depends only on the final state, not on the sequence of trades.  </p> </li> <li> <p>Bounded Risk by Design   The CAMM itself never takes uncollateralized exposure. All solvency rules are enforced by the MarketController, which ensures that every position is fully backed (<code>v &gt; 0</code>, <code>L_k \u2265 0</code>). The CAMM simply provides quotes within those bounds.  </p> </li> </ul>"},{"location":"old/CAMMOptions/#example-solutions","title":"Example Solutions","text":"<p>Different pricing rules can be plugged into the CAMM, depending on the desired trade-offs:</p> <ol> <li>Logarithmic Market Scoring Rule (LMSR) </li> <li>Smooth, continuous price adjustments.  </li> <li>Strong theoretical guarantees with bounded loss.  </li> <li>Widely used in prediction markets.  </li> <li> <p>References: </p> <ul> <li>Robin Hanson, Combinatorial Information Market Design (2003) </li> <li>Robin Hanson, Logarithmic Market Scoring Rules for Modular Combinatorial Information Aggregation (2007) </li> </ul> </li> <li> <p>Elliptical / Circle Cost Functions </p> </li> <li>Generalizations of constant-product AMMs (like Uniswap).  </li> <li>Symmetric, easy-to-compute pricing surfaces.  </li> <li>Gas-friendly for on-chain use.  </li> <li> <p>References: </p> <ul> <li>Yunhao Wang, Automated Market Makers for Decentralized Finance (2020) </li> <li>Yunhao Wang, Implementing Automated Market Makers with Constant Ellipse / Circle (2021) </li> </ul> </li> <li> <p>Custom Hybrid Models </p> </li> <li>Combine features of scoring rules and constant-product styles.  </li> <li>Tunable for different market types (e.g., sports, financial, multi-outcome).  </li> <li>References: <ul> <li>Othman et al., Practical Liquidity-Sensitive Automated Market Makers via Convex Risk Measures (2013) </li> <li>Uniswap V3 Core Docs \u2013 Concentrated Liquidity </li> </ul> </li> </ol>"},{"location":"old/CAMMOptions/#summary","title":"Summary","text":"<p>The CAMM is modular: - The MarketController guarantees solvency and collateralization. - The CAMM provides consistent and efficient pricing across all outcomes. - Pricing models (LMSR, ellipse, circle, hybrid) can be swapped in without affecting the underlying guarantees.  </p> <p>This separation of roles ensures bounded risk, scalable pricing, and flexibility to adapt to different market types.  </p>"},{"location":"old/CAMMRole/","title":"Composite Automated Market Maker (Composite AMM) Mechanism","text":""},{"location":"old/CAMMRole/#overview","title":"Overview","text":"<p>The Composite Automated Market Maker (Composite AMM) is a centralized pricing system that manages buy and sell prices for multiple outcomes within a prediction market. Each outcome (e.g., Outcome A, Outcome B, Outcome C) represents a possible resolution of the market event and is backed by a stable asset, vUSDC, ensuring full collateralization. The Composite AMM coordinates with a <code>Composite Market Controller</code> to manage collateral and token minting/burning, and with a <code>vUSDC Controller</code> to handle conversions between USDC and vUSDC at a 1:1 ratio.</p>"},{"location":"old/CAMMRole/#core-mechanism","title":"Core Mechanism","text":"<ul> <li>Composite AMM: Calculates buy and sell prices for all outcomes using a single pricing model (e.g., LMSR or a custom algorithm), ensuring consistency across the prediction market. It manages collateral by interacting with the <code>Composite Market Controller</code> for outcome token minting/burning and the <code>vUSDC Controller</code> for asset conversions.</li> <li>Composite Market Controller: Maintains a ledger to track all outcome positions in the prediction market, ensuring they are 100%+ collateralized with vUSDC. It handles minting or burning of outcome tokens and transfers vUSDC as requested by the Composite AMM, provided sufficient collateral is available.</li> <li>vUSDC Controller: Facilitates 1:1 conversions between USDC and vUSDC for the Composite AMM, enabling seamless asset management.</li> </ul>"},{"location":"old/CAMMRole/#flow-usdc-outcome-token","title":"Flow: USDC \u2192 Outcome Token","text":"<ol> <li>The Composite AMM receives USDC for a trade requesting tokens for a specific outcome (e.g., Outcome A).</li> <li>The Composite AMM sends the USDC to the <code>vUSDC Controller</code>, which converts it to vUSDC at a 1:1 ratio.</li> <li>The Composite AMM transfers the vUSDC to the <code>Composite Market Controller</code> and requests minting of Outcome A tokens.</li> <li>The <code>Composite Market Controller</code> verifies sufficient vUSDC collateral, mints the requested Outcome A tokens, sends them to the Composite AMM, and updates its ledger.</li> <li>The Composite AMM delivers the Outcome A tokens to complete the trade.</li> </ol>"},{"location":"old/CAMMRole/#flow-outcome-token-usdc","title":"Flow: Outcome Token \u2192 USDC","text":"<ol> <li>The Composite AMM receives Outcome A tokens for a trade requesting USDC.</li> <li>The Composite AMM sends the Outcome A tokens to the <code>Composite Market Controller</code> and requests vUSDC in return.</li> <li>The <code>Composite Market Controller</code> verifies the tokens and collateral state, burns the Outcome A tokens, sends vUSDC to the Composite AMM, and updates its ledger.</li> <li>The Composite AMM sends the vUSDC to the <code>vUSDC Controller</code>, which converts it to USDC at a 1:1 ratio.</li> <li>The Composite AMM delivers the USDC to complete the trade.</li> </ol>"},{"location":"old/CAMMRole/#key-points","title":"Key Points","text":"<ul> <li>Centralized Pricing: A single Composite AMM manages pricing for all outcomes in the prediction market, ensuring consistency and efficiency.</li> <li>Solvency: The <code>Composite Market Controller</code> guarantees that all outcome positions are fully collateralized with vUSDC.</li> <li>Scalability: The system supports dynamic outcomes, allowing for flexible expansion of the prediction market.</li> </ul> <p>This Composite AMM setup provides a secure and consistent pricing mechanism for prediction markets, with all collateral (vUSDC) managed by the <code>Composite Market Controller</code> to ensure system integrity.</p>"},{"location":"old/ConstantProduct/","title":"Fixed Product Market Maker (FPMM) for Prediction Markets","text":""},{"location":"old/ConstantProduct/#overview","title":"Overview","text":"<p>This Fixed Product Market Maker (FPMM) prices Back and Lay tokens for prediction market outcomes using an unweighted constant-product invariant, forked from Balancer\u2019s weighted pool math. It queries outcome reserves (\\(R_k = H_k = v + \\text{tilt}[k]\\)) and collateral (\\(R_v = \\min[H_k]\\)) from a ledger with a single market maker, maintaining \\(S = \\sum_j 1/R_j\\) and \\(\\alpha_{\\text{epoch}}\\) for O(1) pricing and updates. The AMM requests or deposits tokens via the ledger without modifying \\(v\\) or \\(\\text{tilt}[k]\\), using Balancer\u2019s exact algebraic swap formulas for efficiency.</p>"},{"location":"old/ConstantProduct/#balancer-math-outline","title":"Balancer Math Outline","text":"<p>Balancer\u2019s weighted pool math generalizes the constant-product AMM for multi-asset pools (up to 8 assets), using a weighted invariant. It supports pairwise swaps with exact algebraic formulas, optimized with fixed-point log/exp functions.</p>"},{"location":"old/ConstantProduct/#key-formulas","title":"Key Formulas","text":"<ul> <li>Invariant:</li> </ul> <p>$$   \\prod_i (R_i^{w_i}) = k   $$</p> <p>where \\(R_i\\) is the reserve of asset \\(i\\), and \\(w_i\\) is the normalized weight:</p> <p>$$   \\sum_i w_i = 1   $$</p> <ul> <li>Spot Price (asset \\(i\\) to \\(j\\)):</li> </ul> <p>$$   p_{i \\to j} = \\frac{w_j}{w_i} \\cdot \\frac{R_j}{R_i}   $$</p> <ul> <li>Swap Quantity Out (input \\(\\Delta A_{\\text{in}}\\) of asset A, output \\(\\Delta B_{\\text{out}}\\) of asset B, fee \\(\\gamma = 0.997\\)):</li> </ul> <p>$$   \\Delta B_{\\text{out}} = R_B \\cdot \\left( 1 - \\left( \\frac{R_A}{R_A + \\Delta A_{\\text{in}} \\cdot \\gamma} \\right)^{\\frac{w_A}{w_B}} \\right)   $$</p> <ul> <li>Swap Cost In (output \\(\\Delta B_{\\text{out}}\\)):</li> </ul> <p>$$   \\Delta A_{\\text{in}} = R_A \\cdot \\left( \\left( \\frac{R_B}{R_B - \\Delta B_{\\text{out}} \\cdot \\gamma} \\right)^{\\frac{w_A}{w_B}} - 1 \\right)   $$</p> <ul> <li> <p>Updates: Adjust reserves (\\(R_A += \\Delta A_{\\text{in}}\\), \\(R_B -= \\Delta B_{\\text{out}}\\)) to preserve \\(k\\).</p> </li> <li> <p>Optimizations: Uses log/exp via <code>FixedPoint.sol</code> for powers, ensuring O(1) swaps. Reserve updates may touch all assets (O(n) worst-case).</p> </li> <li> <p>Reference: Balancer Labs, \"Balancer V2 Whitepaper,\" 2021. docs.balancer.fi; <code>WeightedMath.sol</code> GitHub.</p> </li> </ul>"},{"location":"old/ConstantProduct/#unweighted-fpmm-math","title":"Unweighted FPMM Math","text":"<p>For the FPMM, we use equal weights (\\(w_k = 1/n\\)) to match the prediction market\u2019s uniform outcome structure, simplifying the invariant to the product of outcome reserves. Trades are against vUSDC (collateral \\(R_v = \\min[H_k]\\), weight \\(w_v = 1\\)), with \\(R_v\\) used for pricing but not in the invariant. Unweighted formulas:</p> <ul> <li>Invariant:</li> </ul> <p>$$   \\prod_j R_j = k   $$</p> <ul> <li> <p>Reserves:</p> </li> <li> <p>Outcome reserve \\(R_k\\):</p> \\[ R_k = H_k = v + \\text{tilt}[k] \\] <p>Queried from the ledger\u2019s \\(H_k\\) (effective virtual shares).</p> </li> <li> <p>vUSDC collateral \\(R_v\\):</p> \\[ R_v = \\min_k H_k \\] <p>Queried as the minimum \\(H_k\\) across outcomes (withdrawable collateral), used for pricing.</p> </li> <li> <p>Spot Price (Back \\(k\\) in vUSDC):</p> </li> </ul> <p>$$   p_k = \\frac{w_v}{w_k} \\cdot \\frac{R_v}{R_k} = n \\cdot \\frac{\\min[H_k]}{R_k}   $$</p> <p>Lay \\(k\\):</p> <p>$$   l_k = 1 - p_k   $$</p> <p>Matches \\(1 / (R_k \\cdot S)\\) when \\(\\min[H_k] \\cdot S \\approx 1/n\\), where:</p> <p>$$   S = \\sum_j \\frac{1}{R_j}   $$</p> <ul> <li>Quantity Out (buy \\(q\\) Back \\(k\\) with \\(\\Delta x_{\\text{in}}\\) vUSDC):</li> </ul> <p>$$   q = R_k \\cdot \\left( 1 - \\left( \\frac{\\min[H_k]}{\\min[H_k] + \\Delta x_{\\text{in}} \\cdot \\gamma} \\right)^n \\right)   $$</p> <ul> <li>Cost In (buy \\(q\\) Back \\(k\\)):</li> </ul> <p>$$   \\Delta x_{\\text{in}} = \\min[H_k] \\cdot \\left( \\left( \\frac{R_k}{R_k - q \\cdot \\gamma} \\right)^n - 1 \\right)   $$</p> <ul> <li>Lay k:</li> </ul> <p>$$   C_{\\text{lay}}(q) = q - C_{\\text{back}}(q)   $$</p> <ul> <li> <p>Updates:</p> </li> <li> <p>Query \\(R_k = H_k\\), \\(R_v = \\min[H_k]\\) from ledger.</p> </li> <li> <p>Update cached:</p> \\[ S = \\sum_j \\frac{1}{R_j} \\] <p>and scaling factor:</p> \\[ \\alpha_{\\text{epoch}} = \\alpha_{\\text{epoch}} \\cdot \\left( \\frac{R_{k,\\text{old}}}{R_{k,\\text{new}}} \\right)^{\\frac{1}{n-1}} \\] </li> <li> <p>O(1): Exact swaps use Balancer\u2019s log/exp, avoiding quadratic or numerical solves.</p> </li> </ul>"},{"location":"old/ConstantProduct/#forking-and-implementing-with-ledger","title":"Forking and Implementing with Ledger","text":"<p>Forking Balancer\u2019s <code>WeightedMath.sol</code> adapts its unweighted math to the FPMM. The ledger tracks \\(H_k = v + \\text{tilt}[k]\\) and \\(\\min[H_k]\\) for a single market maker, handling solvency and token minting, while the AMM computes prices and requests tokens.</p>"},{"location":"old/ConstantProduct/#forking-steps","title":"Forking Steps","text":"<ul> <li> <p>Source: Copy <code>WeightedMath.sol</code> for <code>_calcOutGivenIn</code> and <code>_calcInGivenOut</code>.</p> </li> <li> <p>Modify Weights: Set \\(w_v = 1\\) (vUSDC), \\(w_k = 1/n\\) (outcomes).</p> </li> <li> <p>Ledger Queries:</p> </li> <li> <p>\\(R_k = \\text{ledger.getH}(k)\\) for outcome reserves.</p> </li> <li> <p>\\(R_v = \\text{ledger.getMinH}()\\) for vUSDC collateral.</p> </li> <li> <p>Token Operations:</p> </li> <li> <p>Mint: <code>ledger.requestBack(k, q)</code>, <code>ledger.requestLay(k, q)</code>.</p> </li> <li> <p>Burn: <code>ledger.depositBack(k, q)</code>, <code>ledger.depositLay(k, q)</code>.</p> </li> <li> <p>Add State: Store \\(S\\) and \\(\\alpha_{\\text{epoch}}\\) in AMM for O(1) pricing and lazy scaling.</p> </li> <li> <p>Swap Logic:</p> </li> <li> <p>Back \\(k\\) trades: Use Balancer\u2019s formulas with \\(R_A = R_v\\), \\(R_B = R_k\\), \\(w_A = 1\\), \\(w_B = 1/n\\).</p> </li> <li> <p>Lay \\(k\\): \\(C_{\\text{lay}}(q) = q - C_{\\text{back}}(q)\\).</p> </li> <li> <p>Update:</p> \\[ S = S - \\frac{1}{R_{k,\\text{old}}} + \\frac{1}{R_{k,\\text{new}}} \\] \\[ \\alpha_{\\text{epoch}} = \\alpha_{\\text{epoch}} \\cdot \\left( \\frac{R_{k,\\text{old}}}{R_{k,\\text{new}}} \\right)^{\\frac{1}{n-1}} \\] </li> <li> <p>Solidity Changes:</p> </li> <li> <p>Remove reserve storage; use ledger queries.</p> </li> <li> <p>Keep <code>FixedPoint.sol</code> for log/exp powers.</p> </li> <li> <p>Add \\(S\\), \\(\\alpha_{\\text{epoch}}\\) for efficiency.</p> </li> </ul>"},{"location":"old/ConstantProduct/#solvency","title":"Solvency","text":"<p>Ledger enforces:</p> <p>$$   H_k \\geq 0   $$</p> <p>and multi-winner checks:</p> <p>$$   \\text{sum of } m \\text{ smallest } H_k \\geq (m-1) \\cdot v   $$</p>"},{"location":"old/ConstantProduct/#lay-price-impact","title":"Lay Price Impact","text":"<p>Buying \\(q\\) Lay \\(k\\) increases \\(R_k\\), reducing \\(S\\), increasing \\(p_i = 1/(R_i \\cdot S)\\) for \\(i \\neq k\\). Inherent to constant-product coupling.</p>"},{"location":"old/ConstantProduct/#implementation","title":"Implementation","text":"<pre><code>struct State {\n    uint256 S;           // S = sum(1/R_k)\n    uint256 alpha_epoch; // Cumulative scaling factor\n}\n\n// Query R_k from ledger\nfunction getReserve(uint256 k) internal view returns (uint256) {\n    return ledger.getH(k);\n}\n\n// Query R_v = min[H_k]\nfunction getRv() internal view returns (uint256) {\n    return ledger.getMinH();\n}\n\n// Spot price for Back k\nfunction spotPriceBack(uint256 k) public view returns (uint256) {\n    uint256 R_k = getReserve(k);\n    return (n * getRv()) / R_k; // Or 1 / (R_k * S)\n}\n\n// Spot price for Lay k\nfunction spotPriceLay(uint256 k) public view returns (uint256) {\n    return 1 - spotPriceBack(k);\n}\n\n// Exact cost for q Back k\nfunction costBackExact(uint256 k, uint256 q) public view returns (uint256) {\n    uint256 R_k = getReserve(k);\n    uint256 R_v = getRv();\n    uint256 factor = (R_k * 1e18) / (R_k - q * (1 - fee));\n    uint256 power = _pow(factor, n); // Balancer\u2019s FixedPoint.sol\n    return (R_v * (power - 1e18)) / 1e18;\n}\n\n// Exact quantity for \u0394x_in vUSDC\nfunction quantityBackExact(uint256 k, uint256 x_in) public view returns (uint256) {\n    uint256 R_k = getReserve(k);\n    uint256 R_v = getRv();\n    uint256 factor = (R_v * 1e18) / (R_v + x_in * (1 - fee));\n    uint256 power = _pow(factor, n);\n    return R_k * (1e18 - power) / 1e18;\n}\n\n// Update after Back k trade\nfunction updateAfterBack(uint256 k, uint256 q) internal {\n    uint256 R_old = getReserve(k);\n    ledger.requestBack(k, q);\n    uint256 R_new = getReserve(k);\n    S = S - (1e18 / R_old) + (1e18 / R_new);\n    alpha_epoch = (alpha_epoch * _pow((R_old * 1e18) / R_new, 1e18 / (n - 1))) / 1e18;\n}\n\n// Update after Lay k trade\nfunction updateAfterLay(uint256 k, uint256 q) internal {\n    uint256 R_old = getReserve(k);\n    ledger.requestLay(k, q);\n    uint256 R_new = getReserve(k);\n    S = S - (1e18 / R_old) + (1e18 / R_new);\n    alpha_epoch = (alpha_epoch * _pow((R_old * 1e18) / R_new, 1e18 / (n - 1))) / 1e18;\n}\n\n// Balancer\u2019s power function\nfunction _pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n    // Use FixedPoint.sol for exp(exp * log(base))\n}\n</code></pre>"},{"location":"old/ConstantProduct/#notes","title":"Notes","text":"<ul> <li> <p>Invariant: Excludes \\(R_v\\); uses \\(\\prod_j R_j = k\\) for outcome reserves only.</p> </li> <li> <p>R_v = \\min[H_k]: Queried via <code>ledger.getMinH()</code> for pricing, not invariant.</p> </li> <li> <p>Ledger: Queries only; no \\(v\\), \\(\\text{tilt}[k]\\) changes.</p> </li> <li> <p>Guards: Ledger ensures \\(H_k \\geq \\varepsilon\\) (0.001 vUSDC).</p> </li> <li> <p>Multi-Winner: Ledger enforces \\(\\text{sum of } m \\text{ smallest } H_k \\geq (m-1) \\cdot v\\).</p> </li> <li> <p>Performance: O(1) via Balancer\u2019s math; \\(S\\), \\(\\alpha_{\\text{epoch}}\\) optimize spot prices.</p> </li> </ul>"},{"location":"old/ConstantProduct/#references","title":"References","text":"<ul> <li> <p>Angeris, Chitra, et al., \"Constant Function Market Makers: Multi-asset Trades via Convex Optimization,\" 2021. arXiv:2107.12484</p> </li> <li> <p>Balancer Labs, \"Balancer V2 Whitepaper,\" 2021. docs.balancer.fi</p> </li> <li> <p>Balancer V2 Code, <code>WeightedMath.sol</code>. GitHub</p> </li> <li> <p>Omen (Gnosis) Documentation, \"Fixed Product Market Maker.\" omen.eth.link</p> </li> </ul>"},{"location":"old/ContractsOverview/","title":"Contracts","text":""},{"location":"old/ContractsOverview/#core-protocol","title":"Core Protocol","text":""},{"location":"old/ContractsOverview/#vault","title":"Vault","text":"<ul> <li>Holds aUSDC received from the Lending Controller.</li> <li>Keeps a record of the Ledger's deposits (principal) for tracking.</li> <li>Allows the Revenue Bucket to withdraw the interest generated from aUSDC.</li> <li>Sends USDC to and receives USDC from the Lending Controller.</li> <li>Receives USDC from the Ledger.</li> <li>Sends USDC to the Ledger.</li> <li>Receives aUSDC from the Lending Controller.</li> <li>Sends aUSDC to the Lending Controller to redeem USDC.</li> </ul>"},{"location":"old/ContractsOverview/#revenue-bucket","title":"Revenue Bucket","text":"<ul> <li>Collects and manages interest generated from aUSDC deposits.</li> <li>Withdraws interest from the Vault.</li> <li>Distributes profits under Governance control.</li> </ul>"},{"location":"old/ContractsOverview/#lending-controller","title":"Lending Controller","text":"<ul> <li>Deposits USDC into Aave to earn interest.</li> <li>Withdraws USDC from Aave when needed.</li> <li>Sends USDC to the Vault.</li> <li>Receives USDC from the Vault.</li> <li>Sends aUSDC to the Vault.</li> <li>Receives aUSDC from the Vault (for redemption purposes).</li> </ul>"},{"location":"old/ContractsOverview/#ledger","title":"Ledger","text":"<p>The Ledger manages the accounting system with these core functions: - Records USDC deposits for each market maker, tracking their principal. - Ensures all positions remain fully collateralized. - Triggers TokenManager to mint or burn position tokens only on demand. - Provides a transparent audit trail of all transactions. - Sends USDC to the Vault, which forwards it to the Lending Controller for Aave deposit. - Receives USDC from the Vault to reconcile deposit records after withdrawals or adjustments.</p>"},{"location":"old/ContractsOverview/#tokenmanager","title":"TokenManager","text":"<p>The TokenManager executes Ledger commands. - Mints, burns, and transfers position tokens. - Operates only under Ledger instructions.</p>"},{"location":"old/ContractsOverview/#position-tokens","title":"Position Tokens","text":"<ul> <li>Represent user positions within the system.</li> <li>Minted or burned on demand by the TokenManager.</li> <li>Implemented as ERC20 tokens.</li> </ul>"},{"location":"old/ContractsOverview/#periphery-contracts","title":"Periphery Contracts","text":""},{"location":"old/ContractsOverview/#uniswap-v4-hook","title":"Uniswap V4 Hook","text":"<ul> <li>Directs USDC flow via the PoolManager.</li> <li>Routes trades to the CAMM for pricing and settlement.</li> </ul>"},{"location":"old/ContractsOverview/#amm","title":"AMM","text":"<ul> <li>Implements the Composite AMM (CAMM) for pricing and liquidity.</li> <li>Provides constant liquidity using LMSR or elliptical curve models.</li> <li>Enables atomic swaps between USDC \u2194 tokens or token \u2194 token.</li> </ul>"},{"location":"old/ContractsOverview/#third-party-contracts","title":"Third Party Contracts","text":""},{"location":"old/ContractsOverview/#uniswap-poolmanager","title":"Uniswap PoolManager","text":"<ul> <li>Manages liquidity pools.</li> <li>Directs USDC flow based on Uniswap V4 Hook instructions.</li> </ul>"},{"location":"old/ContractsOverview/#aave","title":"Aave","text":"<ul> <li>Accepts USDC deposits and generates aUSDC with interest.</li> <li>Returns USDC to the Lending Controller upon withdrawal.</li> </ul>"},{"location":"old/ContractsOverview/#usdc","title":"USDC","text":"<ul> <li>Serves as the stablecoin for collateral and flow.</li> </ul>"},{"location":"old/ContractsOverview/#ausdc","title":"aUSDC","text":"<ul> <li>Aave\u2019s interest-bearing version of USDC, sent to the Vault.</li> </ul>"},{"location":"old/OpinionMarket/","title":"Opinion Market Overview","text":"<p>An opinion market is a platform where users can trade positions on subjective questions or topics, similar to prediction markets but without any resolution or final outcome. Instead, prices fluctuate based purely on public sentiment, popularity, and trading activity.</p>"},{"location":"old/OpinionMarket/#key-features","title":"Key Features","text":"<ul> <li>Market Examples: Questions like \"Which political party is most trusted to run the UK economy?\" or \"What is the most important political issue in the UK today?\" Users take positions (e.g., buying shares in \"Conservatives\" or \"Economy\" as the top issue).</li> <li>Trading Mechanics: Functions like a prediction market\u2014users buy/sell positions, and you can cash out at any time based on current market prices.</li> <li>No Resolution: Unlike traditional prediction markets, there's no end date or objective resolution; it's ongoing and driven by opinion shifts.</li> <li>Collateral: Positions are backed by an interest-bearing token (vUSDC), which represents 1 USDC deposited into Aave (a lending protocol) at market start. This allows:</li> <li>Holdings to appreciate over time due to accrued interest.</li> <li>Liquidity providers to avoid opportunity costs from forgone interest, as the collateral grows passively.</li> </ul> <p>In essence, it's a perpetual sentiment-trading system with built-in yield to encourage long-term participation and liquidity.</p>"},{"location":"old/PieMarket/","title":"PieMarket.fun","text":""},{"location":"old/PieMarket/#perpetual-prediction-pies","title":"Perpetual Prediction Pies","text":"<p>Get Your Slice of the Action! \ud83c\udf70</p> <p>Each pie is a market, divided into tradable slices that always sum to $1. Buying a slice increases its share of the pie, while other slices shrink proportionally.</p>"},{"location":"old/PieMarket/#crypto-influencer-pie","title":"Crypto Influencer PIE","text":"<p>Which X accounts are shaping the crypto world? \ud83d\udcc8</p> <ul> <li>Each slice represents a different X account:<ul> <li>@VitalikButerin</li> <li>@cz_binance</li> <li>@APompliano</li> <li>@aantonop</li> <li>@cobie</li> <li>etc...</li> </ul> </li> <li>Take a buy slices to speculate on someone\u2019s rising influence in crypto. \ud83d\ude80  </li> <li>Sell your slices when you think their influence has peaked. \ud83d\udcc9</li> </ul>"},{"location":"old/PieMarket/#visulisation-and-branding","title":"Visulisation and Branding","text":"<p>To represent varying slice sizes intuitively, we use a progressive visualization system based on percentage ranges. So its clear at a glance what percentage of the pie each position commands. The idea is that the branding will be attractive enough that peeople will be willing to share it and comment on it. These pictures just a brief mock up of some ideas, but will be designed with more taste!</p>"},{"location":"old/PieMarket/#full-pie-percentages-10","title":"Full Pie (Percentages &gt; 10%)","text":""},{"location":"old/PieMarket/#slice-proportion-percentages-110","title":"Slice Proportion (Percentages 1\u201310%)","text":""},{"location":"old/PieMarket/#cherry-proportion-percentages-011","title":"Cherry Proportion (Percentages 0.1\u20131%)","text":""},{"location":"old/PieMarket/#juice-drop-proportion-percentages-00101","title":"Juice Drop Proportion (Percentages 0.01\u20130.1%)","text":""},{"location":"old/PieMarket/#molecular-proportion-percentages-0001001","title":"Molecular Proportion (Percentages 0.001\u20130.01%)","text":""},{"location":"old/SentimentMarketOverview/","title":"Sentiment Market Overview","text":"<p>A sentiment market is a platform where users can trade positions on subjective questions or topics, similar to prediction markets but without any resolution or final outcome. Prices fluctuate based purely on public sentiment, popularity, and trading activity.</p>"},{"location":"old/SentimentMarketOverview/#key-features","title":"Key Features","text":""},{"location":"old/SentimentMarketOverview/#market-example-which-political-party-is-most-trusted-to-run-the-uk-economy-in-2025","title":"Market Example: \"Which political party is most trusted to run the UK economy in 2025?\"","text":"<p>Users can take positions on specific parties, such as:</p> <ul> <li>Conservative Party</li> <li>Labour Party</li> <li>Liberal Democrats</li> <li>Green Party</li> <li>Reform UK</li> <li>Scottish National Party (SNP)</li> <li>Plaid Cymru</li> <li>Democratic Unionist Party (DUP)</li> <li>Sinn F\u00e9in</li> <li>Social Democratic and Labour Party (SDLP)</li> <li>Alliance Party of Northern Ireland</li> </ul> <p>The sum of the implied probabilities of all back positions equals 1 iUSDC. Users can back or lay each position, and prices shift based on sentiment and trading volume.</p>"},{"location":"old/SentimentMarketOverview/#trading-mechanics","title":"Trading Mechanics","text":"<p>Functions like a prediction market\u2014users buy/sell positions, and you can cash out at any time based on current market prices.</p>"},{"location":"old/SentimentMarketOverview/#no-resolution","title":"No Resolution","text":"<p>Unlike traditional prediction markets, there's no end date or objective resolution; it's ongoing and driven by sentiment shifts.</p>"},{"location":"old/SentimentMarketOverview/#collateral","title":"Collateral","text":"<p>Positions are backed by an interest-bearing token (iUSDC), which represents 1 USDC deposited into Aave (a lending protocol) at the start of the market. This allows:</p> <ul> <li>Holdings to appreciate over time due to accrued interest.</li> <li>Liquidity providers to avoid opportunity costs from forgone interest, as the collateral grows passively.</li> </ul> <p>In essence, it's a perpetual sentiment-trading system with built-in yield to encourage long-term participation and liquidity.</p>"},{"location":"old/TechStackOverview/","title":"Perpetual Market System Outline","text":"<p>This system enables continuous trading on positions like opinions in markets that never close. All positions are backed by USDC deposited into Aave to earn interest, ensuring full collateralization and providing yield to token holders.  </p> <p>The current system is designed for not-pegged markets but small adjustments can be made to peg positions based on yield and outcomes.</p>"},{"location":"old/TechStackOverview/#system-components","title":"System Components","text":""},{"location":"old/TechStackOverview/#collateral-layer","title":"Collateral Layer","text":"<p>USDC is deposited into Aave, where it earns interest.  </p>"},{"location":"old/TechStackOverview/#yield-layer","title":"Yield Layer","text":"<p>Manages interest from Aave:  </p> <p>Yield flows directly to the treasury.  </p>"},{"location":"old/TechStackOverview/#governance-token-layer","title":"Governance Token Layer","text":"<p>The Governance Token Layer is concerned with the issuance and management of the governance token.  </p> <ul> <li>Handles issuance of governance tokens.  </li> </ul>"},{"location":"old/TechStackOverview/#governance-layer","title":"Governance Layer","text":"<p>The Governance Layer oversees how the protocol is governed.  </p> <ul> <li>Manages control of the protocol's received yield.  </li> </ul>"},{"location":"old/TechStackOverview/#ledger-layer","title":"Ledger Layer","text":"<p>The Ledger is the accounting brain.  </p> <ul> <li>Tracks deposits and positions for each market maker.  </li> <li>Keeps everything fully collateralized.  </li> <li>Only stores numbers \u2014 tokens are minted or burned on demand.  </li> <li>Works for multi-winner markets.  </li> </ul>"},{"location":"old/TechStackOverview/#tokenmanager-layer","title":"TokenManager Layer","text":"<p>The TokenManager is the executor, controlled entirely by the Ledger.  </p> <ul> <li>Handles minting, burning, and transfers of all position tokens.  </li> <li>Cannot act independently \u2014 it only follows Ledger instructions.  </li> <li>Ensures circulating tokens always match ledger records.  </li> </ul>"},{"location":"old/TechStackOverview/#pricing-layer","title":"Pricing Layer","text":"<p>The Composite AMM (CAMM) sets prices for all positions.  </p> <ul> <li>Provides constant liquidity using models such as LMSR or eliptical curve.</li> <li>Unified Liquidity across the whole composite market.</li> <li>CAMM can swap atomically between USDC \u2194 tokens or token \u2194 token.  </li> </ul>"},{"location":"old/TechStackOverview/#access-layer","title":"Access Layer","text":"<p>1) Bespoke front end 2) Uniswap V4 hooks.  </p> <ul> <li>Trades route to the CAMM for pricing.  </li> <li>Settlement is handled by the Ledger and TokenManager.  </li> <li>Simple Front End or Uniswap interface for user</li> </ul>"},{"location":"old/TechStackOverview/#market-layer","title":"Market Layer","text":"<p>Opinion markets, backed by iUSDC.  </p>"},{"location":"old/TechStackOverview/#user-interactions","title":"User Interactions","text":"<ul> <li>Users buy or sell position tokens (e.g., \u201cBack Liverpool\u201d) via Uniswap V4 pools.  </li> </ul>"},{"location":"old/TechStackOverview/#market-maker-interactions","title":"Market Maker Interactions","text":"<ul> <li>Market Makers deposit USDC to recieve iUSDC</li> <li>Market Makers deposit iUSDC into the Ledger.  </li> <li>Their balances are stored as virtual position shares, not physical tokens.  </li> <li>Market Maker sets their own parameters for liquidity.</li> <li>Users buy tokens from the market maker's liquidity.</li> <li>Tokens are minted or burned on demand by the TokenManager, under Ledger control.  </li> <li> <p>Market Makers collateral and effective positions always redeemable.   </p> </li> <li> <p>Market Maker rewards - market makers can be rewarded with Governance Token and USDC rewards</p> </li> </ul>"},{"location":"old/TechStackOverview/#innovations","title":"Innovations","text":"<p>1) Native yield generation USDC deposits all stored in aave to generate yield</p> <p>2) Lazy minting - liquidity providers dont need to mint any tokens, or manage splits and merges etc</p> <p>3) Expanding markets - Ledger allows markets to expand to an indefinite number of positions</p> <p>4) Flexible CAMMs - the market makers are not integral to the system so the liquidity provision and pricing dynamics can be adjusted</p> <p>5) Eash Market Making - market makers can choose a CAMM and passive market make without actively managing splitting and merging</p> <p>6) Clear auditting Ledger-Token Manager system ringfenced from the CAMMs. </p>"},{"location":"old/TokenManager/","title":"TokenManager Technical Details","text":""},{"location":"old/TokenManager/#overview","title":"Overview","text":"<p>The TokenManager creates an ERC-20 contract representing each back and lay position and acts as the controller of all ERC-20 token contracts in the composite market, minting and burning tokens lazily and only on demand.</p> <ul> <li>Acts as a subordinate to the ledger, executing token operations based on ledger directives.</li> </ul>"},{"location":"old/TokenManager/#token-structure","title":"Token Structure","text":"<p>The TokenManager creates and manages ERC-20 tokens, issuing them at the command of the ledger.</p>"},{"location":"old/TokenManager/#key-components","title":"Key Components","text":""},{"location":"old/TokenManager/#back-tokens","title":"Back Tokens","text":"<ul> <li>ERC-20 contracts (e.g., \"Back Position 1\") representing a position on the identifier.</li> <li>Minted lazily when requested.</li> </ul>"},{"location":"old/TokenManager/#lay-tokens","title":"Lay Tokens","text":"<ul> <li>ERC-20 contracts (e.g., \"Lay Position 1\") representing the inverse position.</li> <li>Minted lazily on ledger command.</li> </ul>"},{"location":"old/TokenManager/#storage","title":"Storage","text":"<ul> <li>Mappings from <code>positionId</code> (uint256) to contract addresses: <code>backTokens[positionId]</code> and <code>layTokens[positionId]</code>.</li> <li>Tokens are standard ERC-20, with the TokenManager as the sole minter/burner.</li> </ul>"},{"location":"old/TokenManager/#dynamic-position-support","title":"Dynamic Position Support","text":"<p>Positions can be added anytime via <code>addPosition(k)</code> on ledger directive, deploying new ERC20 contracts as needed. New tokens are ready for lazy minting on demand.</p>"},{"location":"old/UniswapHooks/","title":"Uniswap V4 Hooks: Quick Guide for V2 Users","text":""},{"location":"old/UniswapHooks/#overview","title":"Overview","text":"<p>Uniswap V2 uses a fixed formula (xy = k) for pools. Uniswap V4 adds hooks\u2014smart contracts that customize how pools work, keeping things flexible while feeling seamless for users.</p>"},{"location":"old/UniswapHooks/#what-are-hooks","title":"What Are Hooks?","text":"<p>Hooks are contracts linked to V4 pools at creation. They let developers add custom logic, so each pool can have unique features like dynamic fees or hedging. One hook can manage multiple pools.</p>"},{"location":"old/UniswapHooks/#tapping-on-chain-liquidity","title":"Tapping On-Chain Liquidity","text":"<p>Hooks let pools use liquidity from other on-chain sources (e.g., other DEXs or lending platforms like Aave) while users trade through a single Uniswap pool.</p> <ul> <li>How It Works: Hooks can pull funds from on-chain protocols to improve trade prices or depth, but users see it as one simple swap.</li> <li>Why It Matters: Users get better prices and more liquidity without juggling multiple platforms.</li> <li>Example Use Case: A hook can auto-hedge positions across two pools (e.g., buying in one pool triggers a balancing sell in another), managing risk seamlessly.</li> </ul> <p>V4 hooks make pools adaptable, blending on-chain liquidity and custom features into one smooth experience.</p>"},{"location":"older/BoundedPhenomena/","title":"Tokenizing Perpetual Bounded Phenomena","text":"<p>{!sections/1introduction.md!}</p> <p>{!sections/2phenomenon.md!}</p> <p>{!sections/3PBP_examples.md!}</p> <p>{!sections/4why_tokenize.md!}</p> <p>{!sections/5peg_mechanism.md!}</p> <p>{!sections/6applications.md!}</p> <p>{!sections/8new_ideas.md!}</p> <p>{!sections/9new_ideas2.md!}</p> <p>{!sections/10RebasingSketch.md!}</p>"},{"location":"older/CMCLedgerTechincal/","title":"CMC Ledger Technical Details","text":""},{"location":"older/CMCLedgerTechincal/#ledger-accounting","title":"Ledger Accounting","text":"<p>The internal ledger tracks positions for each Market Maker, ensuring non-negative posiitions are maintained per outcome (\\( L_k \\geq 0 \\)). </p>"},{"location":"older/CMCLedgerTechincal/#ledger-structure","title":"Ledger Structure","text":""},{"location":"older/CMCLedgerTechincal/#uniform-credit-v","title":"Uniform Credit (v)","text":"<p>\\( v \\) (<code>int256</code>): Represents vUSDC credit, providing a uniform position across all outcomes, similar to a balanced \"back all\" position. It is adjusted for lay positions to ensure uniform exposure to \"all other outcomes.\" For dynamic/expanding markets, \\( v &gt; 0 \\) must hold to guarantee positive claims for new outcomes. For finite markets, \\( v \\) can become negative after balanced redemptions, as the invariant prioritizes \\( L_k \\geq 0 \\) over uniform positivity. Using signed <code>int256</code> allows direct handling of negative \\( v \\) in finite cases without additional offsets.</p>"},{"location":"older/CMCLedgerTechincal/#tilt-mapping","title":"Tilt Mapping","text":"<p><code>tilt</code> (<code>mapping(uint256 =&gt; int128)</code>): Tracks signed deviations per outcome ID (\\( k \\)), allowing positive adjustments (for back positions, increasing exposure to \\( k \\)) or negative adjustments (for back or lay positions, reducing exposure to \\( k \\)). The use of signed <code>int128</code> enables precise tracking of deviations from the uniform credit \\( v \\). For lay positions, negative <code>tilt[k]</code> offsets the increase in \\( v \\), ensuring the claim on outcome \\( k \\) remains unchanged while increasing claims on all other outcomes, reflecting the complementary nature of lay bets.</p>"},{"location":"older/CMCLedgerTechincal/#effective-claim-per-outcome","title":"Effective Claim per Outcome","text":"<p>The effective claim for outcome \\( k \\) is \\( L_k = v + \\text{tilt}[k] \\geq 0 \\), an invariant enforced across all operations to ensure non-negative claims.</p>"},{"location":"older/CMCLedgerTechincal/#helpers-for-o1-checks","title":"Helpers for O(1) Checks","text":"<p><code>minLk</code> (<code>uint256</code>): Tracks the smallest \\( L_k \\) value.</p> <p><code>minLkId</code> (<code>uint256</code>): Identifies the outcome ID for <code>minLk</code>.</p> <p><code>secondMinLk</code> (<code>uint256</code>): Tracks the second-smallest \\( L_k \\) value.</p> <p><code>secondMinLkId</code> (<code>uint256</code>): Identifies the outcome ID for <code>secondMinLk</code>.</p> <p>These helpers are updated lazily when <code>tilt[k]</code> or \\( v \\) changes, avoiding \\( O(n) \\) scans and enabling fast validation against negative \\( L_k \\).</p>"},{"location":"older/CMCLedgerTechincal/#accounting-invariant","title":"Accounting Invariant","text":"<p>The sum of all \\( L_k \\) represents the CAMM\u2019s total claim. Operations like deposits, redemptions, mints, or burns preserve or adjust this sum in a controlled manner. All \\( L_k \\geq 0 \\) is the core invariant for collateralization.</p>"},{"location":"older/CMCLedgerTechincal/#handling-v-in-finite-vs-dynamic-markets","title":"Handling v in Finite vs. Dynamic Markets","text":"<p>For dynamic/expanding markets (unknown \\( n \\)), \\( v &gt; 0 \\) is strictly enforced to ensure new outcomes inherit a positive uniform claim (\\( L_k = v \\) for untouched tilts).</p> <p>For finite, non-expanding markets (known \\( n \\)), balanced redemptions allow withdrawal up to \\( U \\leq \\min L_k \\). This updates \\( v \\leftarrow v - U \\), which can make \\( v &lt; 0 \\) if prior burns created positive tilts (increasing some \\( L_k &gt; v \\)). However, new \\( L_k' = L_k - U \\geq 0 \\) holds, as \\( U \\leq \\min L_k \\). In code, with <code>v</code> as <code>int256</code>, negative values are directly supported. Example:</p> <ul> <li>Initial: \\( v = 10 \\), \\( \\text{tilt}[0] = 0 \\), \\( \\text{tilt}[1] = 0 \\), \\( L_0 = 10 \\), \\( L_1 = 10 \\), \\( \\min L_k = 10 \\).</li> <li>Burn back 0 (\\( Q = 3 \\)): \\( \\text{tilt}[0] += 3 = 3 \\), \\( L_0 = 13 \\), \\( L_1 = 10 \\), \\( \\min L_k = 10 \\).</li> <li>Burn back 1 (\\( Q = 4 \\)): \\( \\text{tilt}[1] += 4 = 4 \\), \\( L_0 = 13 \\), \\( L_1 = 14 \\), \\( \\min L_k = 13 \\).</li> <li>Redeem \\( U = 13 \\): \\( v = 10 - 13 = -3 \\), \\( L_0 = -3 + 3 = 0 \\), \\( L_1 = -3 + 4 = 1 \\) (both \\( \\geq 0 \\)).</li> </ul> <p>For dynamic \\( n \\), new outcomes default to \\( L_k = v \\) (with <code>tilt[k] = 0</code>), inheriting uniform credits without explicit updates.</p>"},{"location":"older/CMCTokenOperationsTechincal/","title":"CMC Token and Operations Technical Details","text":""},{"location":"older/CMCTokenOperationsTechincal/#erc-20-token-minting-and-creation","title":"ERC-20 Token Minting and Creation","text":"<p>The CMC is the sole minter and burner of ERC-20 tokens, using lazy minting to externalize ledger positions only when required.</p>"},{"location":"older/CMCTokenOperationsTechincal/#token-structure","title":"Token Structure","text":"<p>For each outcome ID (<code>uint256</code>):</p> <ul> <li>Back Token: An ERC-20 token (e.g., \"Back Outcome 1\") for betting on the outcome occurring.</li> <li>Lay Token: An ERC-20 token (e.g., \"Lay Outcome 1\") for betting against the outcome, effectively betting on all other outcomes.</li> </ul> <p>Storage uses mappings from <code>outcomeId</code> to ERC-20 contract addresses (e.g., <code>backTokens[outcomeId]</code>, <code>layTokens[outcomeId]</code>).</p>"},{"location":"older/CMCTokenOperationsTechincal/#creation-process","title":"Creation Process","text":""},{"location":"older/CMCTokenOperationsTechincal/#addoutcome-function","title":"addOutcome Function","text":"<p><code>addOutcome(uint256 outcomeId)</code>: Deploys or assigns new ERC-20 contracts for Back and Lay tokens (one-time, ~1M\u20132M gas per deployment). Initializes <code>tilt[outcomeId] = 0</code>. No ledger updates are needed for existing CAMMs; new outcomes inherit \\( v \\).</p>"},{"location":"older/CMCTokenOperationsTechincal/#dynamic-n-support","title":"Dynamic n Support","text":"<p>Outcomes can be added at any time (e.g., via admin or oracle), with no gas cost until traded.</p>"},{"location":"older/CMCTokenOperationsTechincal/#minting-and-burning-operations","title":"Minting and Burning Operations","text":""},{"location":"older/CMCTokenOperationsTechincal/#lazy-minting","title":"Lazy Minting","text":"<p>Tokens are minted only upon request, minimizing gas costs for internal operations.</p>"},{"location":"older/CMCTokenOperationsTechincal/#mint-back-k-q","title":"Mint Back k (Q)","text":"<p>Check: \\( L_k \\geq Q \\) (\\( v + \\text{tilt}[k] \\geq Q \\)).</p> <p>Update: <code>tilt[k] -= Q</code> (using signed <code>int128</code>, without modifying \\( v \\)).</p> <p>Helper Update: Adjust <code>minLk</code> if \\( k \\) was the min or second-min.</p> <p>Action: Mint \\( Q \\) ERC-20 Back \\( k \\) tokens.</p> <p>Gas: ~15k\u201320k (1 SSTORE for <code>tilt[k]</code>, ~5k; ERC-20 mint, ~10k\u201315k).</p>"},{"location":"older/CMCTokenOperationsTechincal/#burn-back-k-q","title":"Burn Back k (Q)","text":"<p>Action: Burn \\( Q \\) ERC-20 Back \\( k \\) tokens.</p> <p>Update: <code>tilt[k] += Q</code>.</p> <p>Helper Update: Adjust <code>minLk</code> if needed.</p> <p>Gas: ~15k\u201320k (1 SSTORE, ERC-20 burn).</p>"},{"location":"older/CMCTokenOperationsTechincal/#mint-lay-k-q","title":"Mint Lay k (Q)","text":"<p>Check: \\( L_k \\geq 0 \\) post-update (\\( v + Q + \\text{tilt}[k] - Q = v + \\text{tilt}[k] \\geq 0 \\), using <code>minLk</code> if \\( k \\) is min).</p> <p>Update: \\( v += Q \\), <code>tilt[k] -= Q</code> (increases claims by \\( Q \\) on all non-\\( k \\) outcomes, no net change on \\( k \\) relative to prior \\( L_k \\); ensures \\( v &gt; 0 \\) for dynamic markets).</p> <p>Helper Update: Adjust <code>minLk</code> if \\( k \\) was min or second-min.</p> <p>Action: Mint \\( Q \\) ERC-20 Lay \\( k \\) tokens.</p> <p>Gas: ~20k\u201325k (2 SSTOREs for \\( v \\), <code>tilt[k]</code>, ~10k; ERC-20 mint, ~10k\u201315k).</p>"},{"location":"older/CMCTokenOperationsTechincal/#burn-lay-k-q","title":"Burn Lay k (Q)","text":"<p>Action: Burn \\( Q \\) ERC-20 Lay \\( k \\) tokens.</p> <p>Update: \\( v -= Q \\), <code>tilt[k] += Q</code> (check \\( v &gt; 0 \\) for dynamic markets post-update).</p> <p>Check: \\( L_k \\geq 0 \\) (sparse, using <code>minLk</code>).</p> <p>Helper Update: Adjust <code>minLk</code> if needed.</p> <p>Gas: ~15k\u201320k (2 SSTOREs, ERC-20 burn).</p>"},{"location":"older/CMCTokenOperationsTechincal/#lay-adjustment-via-vusdc","title":"Lay Adjustment via vUSDC","text":"<p>For a lay position on outcome \\( k \\) with quantity \\( Q \\):</p> <ul> <li>Increase \\( v += Q \\) to uniformly boost all \\( L_k \\), exposing the lay to all other outcomes (including future, unconceived ones).</li> <li>Decrease <code>tilt[k] -= Q</code> to offset the increase for outcome \\( k \\), resulting in no net change to \\( L_k \\) but adding \\( Q \\) to all non-\\( k \\) outcomes.</li> </ul> <p>This approach works without knowing \\( n \\), as \\( v \\) is uniform and new outcomes inherit it. The sum of \\( L_k \\) increases by \\( (n-1) \\times Q \\). Burning reverses these updates, maintaining \\( O(1) \\) efficiency and avoiding \\( O(n) \\) adjustments for non-\\( k \\) outcomes.</p>"},{"location":"older/CMCTokenOperationsTechincal/#operations-and-gas-efficiency","title":"Operations and Gas Efficiency","text":"<p>All core operations are \\( O(1) \\), leveraging sparse mappings and helper variables. No full scans are required for dynamic \\( n \\), as helpers ensure rapid invariant checks.</p>"},{"location":"older/CMCTokenOperationsTechincal/#deposit-balanced-u-vusdc","title":"Deposit Balanced (U vUSDC)","text":"<p>Update: \\( v += U \\) (ensure \\( v &gt; 0 \\) for dynamic markets).</p> <p>Check: Verify <code>minLk</code>.</p> <p>Gas: ~20k\u201325k.</p>"},{"location":"older/CMCTokenOperationsTechincal/#redeem-balanced-u-vusdc","title":"Redeem Balanced (U vUSDC)","text":"<p>Check: \\( U \\leq \\text{minLk} \\).</p> <p>Update: \\( v -= U \\) (allow \\( v &lt; 0 \\) for finite markets; ensure \\( v &gt; 0 \\) for dynamic).</p> <p>Helper Update: Adjust <code>minLk</code>.</p> <p>Gas: ~24k\u201330k.</p>"},{"location":"older/CMCTokenOperationsTechincal/#add-new-outcome","title":"Add New Outcome","text":"<p>Storage: \\( O(1) \\), ~1M\u20132M gas if deploying ERC-20 contracts.</p>"},{"location":"older/CMCTokenOperationsTechincal/#update-helpers","title":"Update Helpers","text":"<p>Process: Lazy updates on changes to <code>tilt[k]</code> or \\( v \\); check for new <code>minLk</code> (\\( O(1) \\)).</p>"},{"location":"older/CircleAmm/","title":"CircleAmm","text":"<p>GROK</p>"},{"location":"older/CircleAmm/#elliptical-and-circle-automated-market-maker-amm-models","title":"Elliptical and Circle Automated Market Maker (AMM) Models","text":"<p>This document provides a high-level overview of the elliptical model AMM and its symmetric special case, the circle AMM. The models are described from a \"holdings\" perspective, where the AMM's state is defined by the current token reserves (holdings) \\( h_R \\) and \\( h_G \\) for two tokens (e.g., Red and Green). At initialization, holdings are assumed equal: \\( h_R = F \\), \\( h_G = F \\), where \\( F \\) is the initial funding amount. Fees are ignored in this model for simplicity.</p> <p>The elliptical AMM is based on the work of Wang, as detailed in the referenced paper. The circle AMM is a symmetric simplification of the elliptical model, ensuring equal treatment of both tokens.</p>"},{"location":"older/CircleAmm/#elliptical-model-amm","title":"Elliptical Model AMM","text":""},{"location":"older/CircleAmm/#overview","title":"Overview","text":"<p>The elliptical AMM uses a cost function or invariant shaped like an ellipse in the reserve space. This generalizes constant-product AMMs (like Uniswap) by allowing tilted or squeezed level sets while maintaining convexity on the feasible branch (typically the lower-left arc in the first quadrant). It provides efficient computation (additions, multiplications, and one square root for block trades) and supports asymmetric token treatment if needed.</p>"},{"location":"older/CircleAmm/#state-and-holdings","title":"State and Holdings","text":"<ul> <li>Holdings (Reserves): Let \\( h_R = x \\) and \\( h_G = y \\) represent the current holdings of the two tokens.</li> <li>Initialization: At genesis, \\( h_R = F \\), \\( h_G = F \\), ensuring symmetry unless parameters introduce bias.</li> </ul>"},{"location":"older/CircleAmm/#invariant-cost-function","title":"Invariant / Cost Function","text":"<p>The general constant-ellipse invariant proposed by Wang is:</p> \\[ C(h_R, h_G) = (h_R - a)^2 + (h_G - a)^2 + b \\cdot h_R \\cdot h_G, \\] <p>where:</p> <ul> <li>\\( a &gt; 0 \\) is a center parameter (related to the ellipse's offset),</li> <li>\\( b \\) is a tilting/squeezing parameter (controls asymmetry; \\( b \\neq 0 \\) tilts the ellipse).</li> </ul> <p>Trades occur along the level sets of \\( C \\) (constant \\( C = k \\)), specifically the convex lower-left branch in the first quadrant. The invariant ensures that after a trade, the new holdings satisfy \\( C(h_R', h_G') = C(h_R, h_G) \\).</p> <p>For \\( n=2 \\) tokens, this is convex and admits efficient arithmetic for swaps.</p>"},{"location":"older/CircleAmm/#exchange-rates-and-trades","title":"Exchange Rates and Trades","text":"<ul> <li>Instantaneous Rate: Derived from the tangent slope of the ellipse.</li> <li>Block Trades: Solve the quadratic equation from the invariant for the output amount, involving one square root.</li> </ul>"},{"location":"older/CircleAmm/#reference","title":"Reference","text":"<p>This model is from Wang's paper: \"Automated Market Makers Designs for Decentralized Finance\" (arXiv:2009.01676v3). See Sections 2\u20134 and 6 for the ellipse cost/invariant, price derivatives, and generalizations.</p>"},{"location":"older/CircleAmm/#circle-amm-symmetric-case","title":"Circle AMM (Symmetric Case)","text":""},{"location":"older/CircleAmm/#overview_1","title":"Overview","text":"<p>The circle AMM is a special case of the elliptical model where \\( b = 0 \\), reducing the invariant to a perfect circle. This ensures complete symmetry between the tokens (\\( h_R \\) and \\( h_G \\) are treated identically, with no tilting). It is \"normal\" and intuitive when no specific shape is preferred, and reserves start equal.</p>"},{"location":"older/CircleAmm/#state-and-holdings_1","title":"State and Holdings","text":"<ul> <li>Holdings (Reserves): \\( h_R = x \\), \\( h_G = y \\).</li> <li>Initialization: \\( h_R = F \\), \\( h_G = F \\).</li> <li>Parameters: Center \\( c &gt; 0 \\), fixed radius \\( r &gt; 0 \\). These can be pinned to match initial holdings (e.g., \\( c = F \\), \\( r = F\\sqrt{2} \\) so the initial point lies on the circle).</li> </ul>"},{"location":"older/CircleAmm/#geometry-and-invariant","title":"Geometry and Invariant","text":"<p>The AMM constrains holdings to the lower-left arc of the circle in the first quadrant. Two equivalent implementations:</p>"},{"location":"older/CircleAmm/#approach-i-scaled-circle","title":"Approach I: Scaled Circle","text":"<p>Use a scaling factor \\( \\mu &gt; 0 \\) to fit holdings to the circle:</p> \\[ (\\mu h_R - c)^2 + (\\mu h_G - c)^2 = r^2, \\] <p>with \\( \\mu h_R &lt; c \\), \\( \\mu h_G &lt; c \\) (ensuring the lower-left arc).</p>"},{"location":"older/CircleAmm/#approach-ii-cost-as-circle-no-scaling","title":"Approach II: Cost as Circle (No Scaling)","text":"<p>Define the cost function directly:</p> \\[ C(h_R, h_G) = (h_R - c)^2 + (h_G - c)^2 = k, \\] <p>where \\( k = r^2 \\). Trades move along constant-\\( C \\) level sets (convex branch).</p> <p>At initialization (\\( h_R = F \\), \\( h_G = F \\)):</p> \\[ (F - c)^2 + (F - c)^2 = r^2 \\implies 2(F - c)^2 = r^2. \\]"},{"location":"older/CircleAmm/#instantaneous-exchange-rate","title":"Instantaneous Exchange Rate","text":"<p>For the circle \\( u^2 + v^2 = r^2 \\) with \\( u = \\mu h_R - c \\), \\( v = \\mu h_G - c \\) (Approach I):</p> \\[ \\frac{d(\\mu h_G)}{d(\\mu h_R)} = -\\frac{c - \\mu h_R}{c - \\mu h_G} \\implies \\text{Rate (} h_G \\text{ per } h_R\\text{)} = \\frac{c - \\mu h_R}{c - \\mu h_G}. \\] <p>For infinitesimal input \\( dh_R &gt; 0 \\), output \\( dh_G = dh_R \\cdot \\frac{c - \\mu h_R}{c - \\mu h_G} \\).</p> <p>In Approach II (no \\( \\mu \\)):</p> \\[ \\text{Rate} = \\frac{c - h_R}{c - h_G}. \\] <p>As one holding approaches 0, the rate diverges, creating a natural barrier against depletion.</p>"},{"location":"older/CircleAmm/#block-trade-formulas","title":"Block-Trade Formulas","text":"<p>For a block trade input \\( \\Delta h_R &gt; 0 \\) (buy \\( h_G \\), sell \\( h_R \\); no fees):</p> <ul> <li>New holdings: \\( h_R' = h_R + \\Delta h_R \\), \\( h_G' = h_G - \\Delta h_G \\).</li> <li>Solve the invariant for \\( \\Delta h_G \\) (Approach I):</li> </ul> \\[ \\Delta h_G = h_G - \\frac{1}{\\mu} \\left[ c - \\sqrt{r^2 - (\\mu (h_R + \\Delta h_R) - c)^2} \\right]. \\] <p>Pick the lower-left branch (minus sign in square root).</p> <p>For Approach II (no \\( \\mu \\)):</p> \\[ \\Delta h_G = h_G - \\left[ c - \\sqrt{r^2 - (h_R + \\Delta h_R - c)^2} \\right]. \\] <p>Symmetry: Swap roles for the opposite direction.</p>"},{"location":"older/CircleAmm/#relation-to-elliptical-model","title":"Relation to Elliptical Model","text":"<p>Setting \\( b = 0 \\) in the elliptical invariant reduces to the circle, ensuring symmetry (\\( \\lambda_0 = \\lambda_1 = 1 \\)).</p>"},{"location":"older/CircleAmm/#implementation-considerations","title":"Implementation Considerations","text":""},{"location":"older/CircleAmm/#from-holdings-perspective","title":"From Holdings Perspective","text":"<p>The AMM operates directly on holdings \\( h_R, h_G \\):</p> <ul> <li>State: Store \\( h_R, h_G, c, r \\) (or \\( \\mu \\) if using Approach I).</li> <li>Initialization: Set \\( h_R = F \\), \\( h_G = F \\). Choose \\( c = F \\), \\( r = F\\sqrt{2} \\) to place the initial point on the circle.</li> <li>Quotes: For input \\( \\Delta h_R \\), compute \\( \\Delta h_G \\) using the block-trade formula (one square root; gas-efficient).</li> <li>Updates: After trade, update holdings: \\( h_R += \\Delta h_R \\), \\( h_G -= \\Delta h_G \\).</li> <li>Barrier: Rate explosion prevents holdings from reaching 0 with finite input.</li> <li>Symmetry: Circle ensures identical treatment of tokens.</li> </ul>"},{"location":"older/CircleAmm/#solidity-snippet-approach-ii-no-fees","title":"Solidity Snippet (Approach II, No Fees)","text":"<p>For reference, a simplified Solidity implementation for quoting (using fixed-point math and Babylonian square root):</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CircleAMM {\n    uint256 public hR; // Red holdings\n    uint256 public hG; // Green holdings\n    uint256 public c; // Center\n    uint256 public rSquared; // r^2\n    uint256 public constant PRECISION = 1e18;\n\n    constructor(uint256 F) {\n        hR = F;\n        hG = F;\n        c = F;\n        rSquared = 2 * F * F; // r^2 = 2 F^2\n    }\n\n    // Babylonian square root\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y &gt; 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x &lt; z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        return z;\n    }\n\n    // Quote output DeltaG for input DeltaR (buy G, sell R)\n    function quoteG(uint256 deltaR) public view returns (uint256 deltaG) {\n        uint256 newHR = hR + deltaR;\n        uint256 term = rSquared - (newHR - c) * (newHR - c);\n        require(term &gt;= 0, \"Trade exceeds circle\");\n        uint256 sqrtTerm = sqrt(term);\n        deltaG = hG - (c - sqrtTerm);\n        require(deltaG &lt;= hG, \"Insufficient holdings\");\n    }\n\n    // Execute trade (simplified)\n    function swapG(uint256 deltaR) external returns (uint256 deltaG) {\n        deltaG = quoteG(deltaR);\n        hR += deltaR;\n        hG -= deltaG;\n        // Token transfers omitted\n    }\n}\n</code></pre> <p>This uses holdings directly and assumes integer values (scale with PRECISION for decimals).</p>"},{"location":"older/CircleAmm/#citations","title":"Citations","text":"<ul> <li>Wang, 2020. \"Automated Market Makers Designs for Decentralized Finance.\" arXiv:2009.01676v3. (General ellipse model.)</li> <li>Wang, 2021. \"Implementation Notes on Constant Ellipse based AMMs.\" arXiv:2103.03699v1. (Circle implementation details.)</li> </ul>"},{"location":"older/CircleAmm2/","title":"CircleAmm2","text":"<p>Chat GPT</p>"},{"location":"older/CircleAmm2/#constant-ellipse-circle-cost-function-amm","title":"Constant Ellipse / Circle Cost-Function AMM","text":"<p>This page documents a constant-ellipse cost-function market maker (and its symmetric circle special case) and shows how to implement it as an AMM. We provide the general \\(n\\)-asset form and the binary specialization in terms of live balances \\(h_R,h_G\\). All formulas here are fee-free.</p>"},{"location":"older/CircleAmm2/#references","title":"References","text":"<ul> <li>Yunhao Wang (2020), Automated Market Makers for Decentralized Finance (DeFi), arXiv:2009.01676.</li> <li>Yunhao Wang (2021), Implementing Automated Market Makers with Constant Ellipse / Circle, arXiv:2103.03699.</li> </ul>"},{"location":"older/CircleAmm2/#1-elliptical-cost-function-general-n-assets","title":"1) Elliptical cost function (general \\(n\\) assets)","text":"<p>Let \\(q=(q_1,\\dots,q_n)\\) be the inventory vector. The constant-ellipse quadratic cost potential is</p> \\[ C(q) = \\sum_{i=1}^{n} (q_i-a)^2 + b \\sum_{i\\ne j} q_i q_j \\] <p>Trade cost for a state change \\(q\\to q'\\) is</p> \\[ \\text{cost}(q\\to q') = C(q') - C(q) \\] <p>Instantaneous (cash) price of asset \\(i\\) is the marginal</p> \\[ P_i(q) = \\frac{\\partial C}{\\partial q_i} \\] \\[ P_i(q) = 2(q_i-a) + b \\sum_{j\\ne i} q_j \\] <p>If you want probability-style quotes, normalize</p> \\[ \\pi_i(q) = \\frac{P_i(q)}{\\sum_{j=1}^{n} P_j(q)} \\] <p>Convexity (sketch) The Hessian is</p> \\[ H = 2 I + b\\left(\\mathbf{1}\\mathbf{1}^\\top - I\\right) \\] <p>For \\(n=2\\) the PSD condition is \\(-2 \\le b \\le 2\\).</p> <p>Block trade (exact) \u2014 buy \\(Q\\) of asset \\(k\\)</p> \\[ D_k(Q) = C(q + Q e_k) - C(q) \\] \\[ D_k(Q) = Q^2 + B_k Q \\] \\[ B_k = 2(q_k-a) + b \\sum_{j\\ne k} q_j \\] <p>Given a spend \\(D\\), the quantity is</p> \\[ Q_k(D) = \\frac{-B_k + \\sqrt{B_k^2 + 4D}}{2} \\] <p>These are add/mul plus one square root.</p>"},{"location":"older/CircleAmm2/#2-circle-implementation-symmetric-ellipse","title":"2) Circle implementation (symmetric ellipse)","text":"<p>Set \\(b=0\\) to obtain the circle. Two equivalent realizations are common.</p>"},{"location":"older/CircleAmm2/#a-invariant-form-approach-i","title":"(A) Invariant form (Approach I)","text":"<p>Keep the scaled reserves on a fixed circle</p> \\[ (\\mu x - c)^2 + (\\mu y - c)^2 = r^2 \\] <p>The instantaneous exchange rate on the lower-left arc is</p> \\[ \\frac{d(\\mu y)}{d(\\mu x)} = - \\frac{c - \\mu x}{c - \\mu y} \\] <p>A finite update \\(x\\to x' = x + \\Delta x\\) is projected back to the circle</p> \\[ y' = c - \\frac{1}{\\mu}\\sqrt{\\,r^2 - (\\mu x' - c)^2\\,} \\] \\[ \\Delta y = y - y' \\] <p>Choose the lower-left branch to keep \u201csupply \u2191 \u21d2 price \u2191\u201d.</p>"},{"location":"older/CircleAmm2/#b-cost-function-form-approach-ii","title":"(B) Cost-function form (Approach II)","text":"<p>Represent the circle as a cost</p> \\[ C(x,y) = (x - c)^2 + (y - c)^2 \\] <p>Spot prices are marginals</p> \\[ P_x = 2(x - c) \\] \\[ P_y = 2(y - c) \\] <p>A block trade has cost</p> \\[ \\text{cost} = C(\\text{after}) - C(\\text{before}) \\]"},{"location":"older/CircleAmm2/#3-amm-realization-with-balances","title":"3) AMM realization with balances","text":"<p>Two versions: general \\(n\\)-asset ellipse and the binary specialization.</p>"},{"location":"older/CircleAmm2/#31-general-n-asset-ellipse-amm","title":"3.1 General \\(n\\)-asset ellipse AMM","text":"<p>State is \\(q=(q_1,\\dots,q_n)\\).</p> <p>Cost is</p> \\[ C(q) = \\sum_{i=1}^{n} (q_i-a)^2 + b \\sum_{i\\ne j} q_i q_j \\] <p>Spot prices are</p> \\[ P_i(q) = 2(q_i-a) + b \\sum_{j\\ne i} q_j \\] <p>Block trade cost is</p> \\[ D_k(Q) = Q^2 + B_k Q \\] <p>Inverse (spend \u2192 quantity) is</p> \\[ Q_k(D) = \\frac{-B_k + \\sqrt{B_k^2 + 4D}}{2} \\] <p>Optional complementary prices use</p> \\[ \\pi_i(q) = \\frac{P_i(q)}{\\sum_{j=1}^{n} P_j(q)} \\] <p>Path independence is guaranteed by</p> \\[ \\text{cost}(q\\to q') = C(q') - C(q) \\]"},{"location":"older/CircleAmm2/#32-binary-specialization-h_rh_g","title":"3.2 Binary specialization \\((h_R,h_G)\\)","text":"<p>Identify \\(x=h_R\\) and \\(y=h_G\\). The ellipse cost is</p> \\[ C(h_R,h_G) = (h_R - a)^2 + (h_G - a)^2 + b\\, h_R h_G \\] <p>Spot prices are</p> \\[ P_R(h_R,h_G) = 2(h_R - a) + b\\, h_G \\] \\[ P_G(h_R,h_G) = 2(h_G - a) + b\\, h_R \\] <p>Buy \\(Q\\) Red with \\(h_G\\) fixed</p> \\[ D_R(Q) = Q^2 + \\left(2(h_R - a) + b\\, h_G\\right) Q \\] <p>Given spend \\(D\\), the quantity is</p> \\[ Q_R(D) = \\frac{-B + \\sqrt{B^2 + 4D}}{2} \\] \\[ B = 2(h_R - a) + b\\, h_G \\] <p>Buy \\(Q\\) Green by swapping \\(h_R \\leftrightarrow h_G\\).</p> <p>Optional complementary prices use</p> \\[ p_R = \\frac{P_R}{P_R + P_G} \\] \\[ p_G = 1 - p_R \\]"},{"location":"older/CircleAmm2/#33-binary-circle-perfect-symmetry","title":"3.3 Binary circle (perfect symmetry)","text":"<p>Approach I (invariant)</p> \\[ (\\mu h_R - c)^2 + (\\mu h_G - c)^2 = r^2 \\] \\[ \\frac{d(\\mu h_G)}{d(\\mu h_R)} = - \\frac{c - \\mu h_R}{c - \\mu h_G} \\] \\[ h_G' = c - \\frac{1}{\\mu}\\sqrt{\\,r^2 - (\\mu h_R' - c)^2\\,} \\] <p>Approach II (cost)</p> \\[ C(h_R,h_G) = (h_R - c)^2 + (h_G - c)^2 \\] \\[ P_R = 2(h_R - c) \\] \\[ P_G = 2(h_G - c) \\] \\[ \\text{cost} = C(\\text{after}) - C(\\text{before}) \\]"},{"location":"older/CircleAmm2/#notes-on-parameters","title":"Notes on parameters","text":"<p>Ellipse parameters are \\((a,b)\\). The center parameter \\(a\\) shifts the inventory baseline. The coupling parameter \\(b\\) controls curvature and cross-effect. For \\(n=2\\) the convex branch requires \\(-2 \\le b \\le 2\\).</p> <p>Circle parameters are \\((c,r)\\) and optionally \\(\\mu\\). Choose \\((c,r)\\) so the genesis point lies on the lower-left arc.</p>"},{"location":"older/FootballMarketOverview/","title":"Premier League Champion Market","text":"<p>The Premier League Champion Market is a perpetual prediction market where users trade tokens representing which club will win the Premier League. Unlike traditional markets, it never resolves\u2014instead, holders of the winning club\u2019s token inherit yield rights for the following season. </p>"},{"location":"older/FootballMarketOverview/#key-features","title":"Key Features","text":"<p>Market Example: \"Who will win the Premier League?\" Users can take positions on any Premier League club, such as: - Arsenal - Liverpool - Manchester City - Manchester United - Chelsea - Tottenham Hotspur - Newcastle United - Aston Villa - \u2026and all other Premier League clubs</p> <p>Each club has its own token (e.g., Liverpool Champion). Prices fluctuate based on trader sentiment and confidence.</p>"},{"location":"older/FootballMarketOverview/#collateral-minting-and-burning","title":"Collateral, Minting, and Burning","text":"<ul> <li>Collateral: The market uses USDC.</li> <li>Minting: Anyone can mint a complete set of team tokens (one for each club) by depositing 1 USDC.</li> <li>Yield: The 1 USDC is deposited into Aave, where it earns interest.</li> <li>Burning: A user with a complete set of tokens can burn them to redeem the 1 USDC principal.</li> </ul> <p>This ensures the system remains fully collateralized, and liquidity providers face no opportunity cost since collateral is always interest-bearing.</p>"},{"location":"older/FootballMarketOverview/#yield-rights-instead-of-resolution","title":"Yield Rights Instead of Resolution","text":"<ul> <li>Each Premier League season crowns one champion.</li> <li>Holders of the winning club\u2019s token receive:</li> <li>All Aave interest generated by the collateral during the following season.</li> <li>Other tokens remain tradable but do not earn yield.</li> </ul> <p>Example: - You mint a set of tokens with 1 USDC. - The USDC is deposited into Aave, generating interest. - If Liverpool win the 2028/29 season, holders of Liverpool Champion tokens control the yield rights for the 2029/30 season, receiving yield on that 1 USDC until a new champion is crowned.</p>"},{"location":"older/FootballMarketOverview/#trading-mechanics","title":"Trading Mechanics","text":"<ul> <li>Buy or sell team tokens anytime at current market prices.</li> <li>Exit early by selling tokens or burning a full set to recover the principal.</li> <li>If your team wins, your tokens grant yield rights for the next season.</li> </ul>"},{"location":"older/FootballMarketOverview/#tldr","title":"TL;DR","text":"<p>The Premier League Champion Market is a perpetual prediction market where users trade tokens on which club will win the Premier League. Mint a full set of team tokens with 1 USDC, which earns interest in Aave. Instead of resolving, holders of the winning club\u2019s token inherit the yield rights for the next season, while tokens remain tradable year-round.</p>"},{"location":"older/LMSR/","title":"Logarithmic Market Scoring Rule (LMSR) for Binary Prediction Markets","text":""},{"location":"older/LMSR/#introduction","title":"Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), developed by Robin Hanson, is a pricing mechanism for binary prediction markets with two outcomes (Yes or No, e.g., \"Will it rain?\"). It ensures traders can buy or sell shares anytime, with prices reflecting probabilities that sum to 100%. LMSR provides continuous liquidity and limits the market maker's financial risk while aggregating trader beliefs into accurate forecasts.</p>"},{"location":"older/LMSR/#key-terms-and-formulas","title":"Key Terms and Formulas","text":"<ul> <li>Yes Shares (\\(q_Y\\)): Total Yes shares held by users</li> <li>No Shares (\\(q_N\\)): Total No shares held by users</li> <li>Liquidity Parameter (\\(b\\)): A constant (e.g., 1000) set at market creation, controlling price sensitivity. Higher \\(b\\) means less price movement per trade, creating a deeper market.</li> <li>Maximum Liability: The market maker's worst-case loss, equal to \\(b \\cdot \\ln(2) \\approx 0.693b\\). For \\(b = 1000\\), max liability is \u2248 $693</li> <li>Cost Function (\\(C\\)): Tracks the total USDC committed to reach the current share distribution (\\(q_Y\\), \\(q_N\\)) and includes the liability of the AMM. </li> </ul> <p>The system's value excluding AMM liability is:</p> <p>$$ \\text{System Value} = C(q_Y, q_N) - C(0,0) $$</p> <p>where:</p> <p>$$ C(q_Y, q_N) = b \\cdot \\ln(e^{q_Y / b} + e^{q_N / b}) $$</p> <p>At \\(q_Y = q_N = 0\\), \\(C(0,0) = b \\cdot \\ln(2) \\approx 0.693b\\), the baseline equal to the maximum liability, setting fair initial prices.</p> <ul> <li> <p>Price of Yes (\\(p_Y\\)): Marginal cost of one additional Yes share for a user, defined as the partial derivative of the cost function with respect to \\(q_Y\\):   $$ p_Y = \\frac{\\partial C}{\\partial q_Y} = \\frac{e^{q_Y / b}}{e^{q_Y / b} + e^{q_N / b}} $$</p> </li> <li> <p>Price of No (\\(p_N\\)): Marginal cost of one additional No share for a user, defined as the partial derivative of the cost function with respect to \\(q_N\\):   $$ p_N = \\frac{\\partial C}{\\partial q_N} = \\frac{e^{q_N / b}}{e^{q_Y / b} + e^{q_N / b}} $$</p> </li> <li> <p>Complementary Pricing: \\(p_Y + p_N = 1\\)</p> </li> <li>Trade Cost: Cost of buying \\(\\Delta\\) Yes shares:</li> </ul> <p>$$ \\text{Cost} = C(q_Y + \\Delta, q_N) - C(q_Y, q_N) $$</p>"},{"location":"older/LMSR2/","title":"Logarithmic Market Scoring Rule (LMSR) for Binary Prediction Markets with Token Pair Minting","text":""},{"location":"older/LMSR2/#introduction","title":"Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), developed by Robin Hanson, is adapted here for a binary prediction market with two outcomes (Yes or No, e.g., \"Will it rain?\"). This version simplifies computations by minting Yes/No token pairs from the contract's funds, ensuring prices reflect probabilities summing to 100%. The contract is funded with its maximum liability, and tokens are minted dynamically to maintain liquidity while capping risk.</p>"},{"location":"older/LMSR2/#key-terms-and-concepts","title":"Key Terms and Concepts","text":"<ul> <li>Yes Shares (\\(q_Y\\)): Total Yes tokens held by users.</li> <li>No Shares (\\(q_N\\)): Total No tokens held by users.</li> <li>Contract Holdings (\\(h_Y\\), \\(h_N\\)): Yes and No tokens held by the contract, used to calculate prices and trade amounts.</li> <li>Liquidity Parameter (\\(b\\)): A constant (e.g., 1000) set at market creation, controlling price sensitivity. Higher \\(b\\) means less price movement per trade, creating a deeper market.</li> <li>Maximum Liability: The market maker's worst-case loss, funded upfront as \\(b \\cdot \\ln(2) \\approx 0.693b\\). For \\(b = 1000\\), max liability is \u2248 $693 USDC.</li> <li>System Value: The total USDC value of user-held tokens, derived from the contract's token holdings.</li> <li>Price Calculation: Prices are derived from the contract's holdings (\\(h_Y\\), \\(h_N\\)), ensuring computational simplicity and real-time updates.</li> </ul>"},{"location":"older/LMSR2/#mechanism","title":"Mechanism","text":"<p>The contract is initialized with \\(q_Y = q_N = 0\\), \\(h_Y = h_N = b\\), and funded with \\(b \\cdot \\ln(2)\\) USDC. Prices start at \\(p_Y = p_N = 0.5\\). When a user deposits USDC, the contract: 1. Mints equal Yes/No token pairs using its funds. 2. Sells the requested token type (Yes or No) to the user at a price derived from the updated holdings. 3. Adjusts \\(h_Y\\) and \\(h_N\\) based on the trade.</p>"},{"location":"older/LMSR2/#price-formulas","title":"Price Formulas","text":"<p>Prices are calculated based on the contract\u2019s token holdings: - Price of Yes (\\(p_Y\\)):   $$ p_Y = \\frac{h_N}{h_Y + h_N} $$ - Price of No (\\(p_N\\)):   $$ p_N = \\frac{h_Y}{h_Y + h_N} $$ - Complementary Pricing: \\(p_Y + p_N = 1\\), ensuring probability summation.</p>"},{"location":"older/LMSR2/#trade-process","title":"Trade Process","text":"<ul> <li>User Deposit: A user deposits \\(d\\) USDC to buy Yes or No tokens.</li> <li>Pair Minting: The contract mints \\(m\\) pairs of Yes/No tokens, where \\(m\\) is determined by the deposited USDC and current prices, ensuring the contract\u2019s liability remains within \\(b \\cdot \\ln(2)\\).</li> <li>Token Sale: The contract sells the requested tokens (e.g., \\(\\Delta\\) Yes tokens) to the user, updating \\(h_Y\\) and \\(h_N\\).</li> <li>Cost Calculation: The cost is the USDC spent (\\(d\\)), and the number of tokens received is based on the price at the time of the trade:   $$ \\Delta = \\frac{d}{p_Y} \\text{ (for Yes tokens)} \\text{ or } \\frac{d}{p_N} \\text{ (for No tokens)} $$</li> <li>Holdings Update: For \\(\\Delta\\) Yes tokens sold, \\(h_Y \\gets h_Y - \\Delta\\), \\(h_N \\gets h_N + \\Delta\\) (since pairs are minted).</li> </ul>"},{"location":"older/LMSR2/#liquidity-adjustment","title":"Liquidity Adjustment","text":"<p>The contract can increase liquidity by adding more USDC (increasing \\(b\\)) and minting additional Yes/No token pairs, proportionally increasing \\(h_Y\\) and \\(h_N\\). This maintains price stability and ensures the liability cap scales with \\(b \\cdot \\ln(2)\\).</p>"},{"location":"older/LMSR2/#example","title":"Example","text":"<p>For \\(b = 1000\\), initial state: \\(q_Y = q_N = 0\\), \\(h_Y = h_N = 1000\\), \\(p_Y = p_N = 0.5\\), contract funded with \u2248 \\(693.15 USDC. A user deposits 9.85 USDC to buy Yes tokens: - Contract mints \\(m\\) Yes/No pairs (e.g., \\(m = 10\\), adding 10 Yes and 10 No tokens, costing \u2248 (10 USDC at \\(p_Y = 0.5\\)). - Sells \u2248 19.7 Yes tokens (\\)9.85 / 0.5\\)) to the user. - Updates: \\(h_Y = 1000 - 19.7 = 980.3\\), \\(h_N = 1000 + 10 = 1010\\). - New prices: \\(p_Y = \\frac{1010}{980.3 + 1010} \\approx 0.507\\), \\(p_N = \\frac{980.3}{980.3 + 1010} \\approx 0.493\\). - System Value: Value of user-held tokens (19.7 Yes tokens at \\(p_Y \\approx 0.507\\)) \u2248 $9.85 USDC.</p>"},{"location":"older/LMSR2/#advantages","title":"Advantages","text":"<ul> <li>Simplified Computation: Prices are derived from token holdings (\\(h_Y\\), \\(h_N\\)), avoiding complex logarithmic calculations in real-time.</li> <li>Dynamic Liquidity: Minting pairs ensures continuous trading and allows liquidity increases without disrupting prices.</li> <li>Capped Risk: The contract\u2019s liability is always funded upfront at \\(b \\cdot \\ln(2)\\), ensuring no excess loss.</li> <li>Scalability: Liquidity can be increased by adding USDC and minting more pairs, adjusting \\(b\\) dynamically.</li> </ul>"},{"location":"older/LMSR2/#conclusion","title":"Conclusion","text":"<p>This LMSR variant uses token pair minting to simplify pricing and maintain liquidity in binary prediction markets. By calculating prices from contract holdings, it reduces computational overhead while ensuring fair pricing and capped risk at \\(b \\cdot \\ln(2)\\). The system value reflects trader investment, making it suitable for decentralized prediction markets.</p>"},{"location":"older/LMSR3/","title":"LSRM for Uniswap v4","text":""},{"location":"older/LMSR3/#1-introduction","title":"1. Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), introduced by Robin Hanson in 2003 (see: Combinatorial Information Market Design), is a market-making mechanism widely used in prediction markets.  </p> <p>This document adapts LMSR into a System Liquidity Provider (SLP) designed for use with Uniswap v4, where the SLP sits behind two liquidity pools(with no liquidity) as a hook called with every transaction.</p> <p>Features of the Uniswap v4 SLP</p> <ul> <li>Defined Risk</li> <li>Determinate Price</li> <li>Integrated complementary pricing between two pools</li> <li>Integrates with liquidity provided in any additional pools</li> <li>Easily add additional liquidity</li> </ul>"},{"location":"older/LMSR3/#2-key-concepts","title":"2. Key Concepts","text":"<ul> <li>Red Tokens (\\(R\\)): Represent one side of a binary market.</li> <li>Green Tokens (\\(G\\)): Represent the other side of a binary market.</li> <li>Holdings (\\(h_R, h_G\\)): Balances of Red and Green held by the market contract.</li> <li>Pairs: Always minted as 1 Red + 1 Green when USDC enters the system.</li> <li>Spot Price: Determined directly from holdings:</li> </ul> <p>$$   p_R = \\frac{h_G}{h_R + h_G}, \\quad p_G = \\frac{h_R}{h_R + h_G}   $$</p> <p>Prices are always complementary:</p> <p>$$   p_R + p_G = 1   $$</p>"},{"location":"older/LMSR3/#3-contract-roles","title":"3. Contract Roles","text":""},{"location":"older/LMSR3/#system-liquidity-provider-slp","title":"System Liquidity Provider (SLP)","text":"<ul> <li>Acts as the interface for traders to swap to and from USDC to market tokens.</li> <li>Holds Red and Green tokens as inventory.</li> <li>Computes trade amounts and transfers Red or Green tokens to traders based on the cost function.</li> </ul>"},{"location":"older/LMSR3/#market-controller","title":"Market Controller","text":"<ul> <li>Manages the Red ERC20 Contract and Green ERC20 Contract.</li> <li>Custodies vUSDC received from the Treasury for internal accounting.</li> <li>Mints Red and Green token pairs on deposits and sends them to the SLP.</li> <li>Burns Red and Green token pairs on redemptions and redeems vUSDC for USDC from treasury.</li> </ul>"},{"location":"older/LMSR3/#red-erc20-contract","title":"Red ERC20 Contract","text":"<ul> <li>Standard ERC20 contract representing Red tokens.</li> <li>Controlled by the Market Controller for minting and burning.</li> </ul>"},{"location":"older/LMSR3/#green-erc20-contract","title":"Green ERC20 Contract","text":"<ul> <li>Standard ERC20 contract representing Green tokens.</li> <li>Controlled by the Market Controller for minting and burning.</li> </ul>"},{"location":"older/LMSR3/#treasury-vusdc-controller","title":"Treasury (vUSDC controller)","text":"<ul> <li>Custodies all USDC, depositing it into Aave to earn yield (aUSDC).</li> <li>Mints vUSDC via the vUSDC Contract to track deposited USDC.</li> <li>Sends vUSDC to the Market Controller during the USDC and token flow routine.</li> <li>Handles withdrawals from Aave when redemptions occur.</li> </ul>"},{"location":"older/LMSR3/#vusdc-contract","title":"vUSDC Contract","text":"<ul> <li>Receipt token held by the Market Controller to facilitate internal accounting of USDC deposited in Aave.</li> <li>Minted and managed by the Treasury.</li> <li>Pegged 1:1 to USDC.</li> </ul>"},{"location":"older/LMSR3/#4-token-flow-implementation-with-easy-accounting-and-auditing","title":"4. Token Flow implementation with easy accounting and auditing","text":""},{"location":"older/LMSR3/#41-usdc-and-token-flow-routine","title":"4.1 USDC and Token Flow Routine","text":"<p>This routine describes how USDC moves up the chain and how vUSDC and token pairs move down:</p>"},{"location":"older/LMSR3/#usdc-upward-flow","title":"USDC Upward Flow","text":"<ul> <li>USDC is sent from the caller (market initiator or trader) to the SLP.</li> <li>SLP forwards the USDC to the Market Controller.</li> <li>Market Controller sends the USDC to the Treasury.</li> <li>Treasury deposits the USDC into Aave, receiving aUSDC (yield-bearing).</li> </ul>"},{"location":"older/LMSR3/#vusdc-and-token-pairs-downward-flow","title":"vUSDC and Token Pairs Downward Flow","text":"<ul> <li>Treasury mints vUSDC (a receipt token pegged 1:1 to USDC) via the vUSDC Contract and sends it to the Market Controller.</li> <li>Market Controller retains vUSDC for internal accounting and mints an equal amount of Red and Green token pairs via the Red ERC20 Contract and Green ERC20 Contract.</li> <li>Market Controller sends the Red and Green token pairs to the SLP.</li> <li>SLP holds the token pairs as inventory for trading.</li> </ul> <p>This routine ensures that all USDC is custodied in Aave and receipts are passed down the chain.</p>"},{"location":"older/LMSR3/#42-market-initiation-sequence","title":"4.2 Market Initiation Sequence","text":"<p>The market is initialized with an initial funding amount to bootstrap liquidity:</p> <ol> <li>The SLP is called with an <code>initialFund(uint)</code> function, specifying the initial USDC amount.</li> <li>The SLP pulls the specified USDC from the caller.</li> <li>The USDC and token flow routine is executed:<ul> <li>USDC is sent from SLP to Market Controller, then to Treasury, and deposited into Aave.</li> <li>Treasury mints vUSDC and sends it to the Market Controller.</li> <li>Market Controller mints Red and Green token pairs and sends them to the SLP.</li> </ul> </li> <li>The SLP is now initiated with Red and Green tokens in its inventory, ready for trading.</li> </ol>"},{"location":"older/LMSR3/#43-trading-sequence","title":"4.3 Trading Sequence","text":"<p>When a trader deposits \\(D\\) USDC to trade:</p> <ol> <li>The trader sends \\(D\\) USDC to the SLP.</li> <li>The USDC and token flow routine is executed:<ul> <li>USDC is sent from SLP to Market Controller, then to Treasury, and deposited into Aave.</li> <li>Treasury mints \\(D\\) vUSDC and sends it to the Market Controller.</li> <li>Market Controller mints \\(D\\) Red and \\(D\\) Green tokens and sends them to the SLP.</li> </ul> </li> <li>The SLP computes the number of Red (or Green) tokens to send to the trader using the cost function.</li> <li>Remaining tokens are left in the SLP\u2019s inventory, ensuring balances match the pricing function.</li> </ol> <p>This guarantees:</p> <ul> <li>Path invariance: Immediate deposit/withdraw cycles return the same USDC.  </li> <li>Finite liability: The Market Controller always has sufficient reserves.  </li> <li>Determinate state: Prices depend only on holdings. </li> <li>Auditable: Values of each contract clear.</li> </ul>"},{"location":"older/LMSR3/#5-pricing-and-trade-math-with-derivation","title":"5. Pricing and Trade Math (with Derivation)","text":"<p>We\u2019ll use Red (R) and Green (G) as the two sides of the market.</p> <p>SLP Starting Red Balance</p> \\[ h_R \\] <p>SLP Starting Green Balance</p> \\[ h_G \\] <p>Red Price</p> \\[ p_R = \\frac{h_G}{h_R + h_G}, \\] <p>Green Price</p> \\[ p_G = \\frac{h_R}{h_R + h_G}, \\] <p>Combined Price Invariant</p> \\[ p_R + p_G = 1. \\] <p>When a user buys Red with a deposit of \\(D\\) USDC, the SLP uses the USDC to mint \\(D\\) new pairs:</p> <p>SLP Post-Mint Red Balance</p> \\[ h_R' = h_R + D, \\] <p>SLP Post-Mint Green Balance</p> \\[ h_G' = h_G + D, \\] <p>SLP Post-Mint Combined Token Balance</p> \\[ S = h_R' + h_G' = (h_R + D) + (h_G + D). \\]"},{"location":"older/LMSR3/#step-1-marginal-price-curve","title":"Step 1. Marginal price curve","text":"<p>The instantaneous (marginal) price of Red, when selling \\(q\\) units from inventory, is given by:</p> \\[ p_R(q) = \\frac{h_G'}{S - q} \\] <p>where:</p> <ul> <li>\\(h_G' = h_G + D\\) (post-mint Green)  </li> <li>\\(S = h_R + h_G + 2D\\) (post-mint total)</li> </ul>"},{"location":"older/LMSR3/#step-2-total-spend","title":"Step 2. Total spend","text":"<p>To compute the total spend for buying \\(Q\\) Red tokens, integrate the marginal price along the fill path:</p> \\[ D(Q) = \\int_{0}^{Q} p_R(q)\\,dq \\] \\[ D(Q) = \\int_{0}^{Q} \\frac{h_G'}{S - q}\\,dq \\] \\[ D(Q) = -\\,h_G' \\cdot \\ln(S - q)\\;\\Big|_{0}^{Q} \\] \\[ D(Q) = h_G' \\cdot \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] <p>Expanding in terms of the initial balances:</p> \\[ D(Q) = (h_G + D) \\cdot \\ln\\!\\left(\\frac{\\,h_R + h_G + 2D\\,}{\\,h_R + h_G + 2D - Q\\,}\\right) \\]"},{"location":"older/LMSR3/#step-3-tokens-as-a-function-of-spend","title":"Step 3. Tokens as a function of spend","text":"<p>We now invert the above relation to solve for \\(Q\\) in terms of \\(D\\):</p> \\[ D(Q) = h_G' \\cdot \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ \\frac{D(Q)}{h_G'} = \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ e^{-D(Q)/h_G'} = \\frac{S - Q}{S} \\] \\[ Q(D) = S \\cdot \\left(1 - e^{-D/h_G'}\\right) \\] <p>with the natural restriction</p> \\[ 0 &lt; Q &lt; h_R' \\] <p>Substituting the intial variables gives</p> \\[ Q(D) = \\big(h_R + h_G + 2D\\big) \\cdot \\left(1 - e^{-\\,D/(h_G + D)}\\right) \\]"},{"location":"older/LMSR4/","title":"LSRM System Liquidity Provider (SLP)","text":""},{"location":"older/LMSR4/#1-introduction","title":"1. Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), introduced by Robin Hanson in 2003 (Combinatorial Information Market Design), is a market-making mechanism which is used in some prediction markets.  </p> <p>This document adapts LMSR into a System Liquidity Provider (SLP), where the SLP is the a liquidity source for two complementary tokens (Red and Green). </p> <p>The SLP mints new token pairs, prices them deterministically based on its inventory.</p> <p>The SLP is designed to feature as part of a Uniswap V4 hook, so it can dovetail with additional liquidity pools, and give a defined complementary price of Red and Green tokens.</p> <p>This document considers markets as binary, but there are no doubt extensions that can be made for multi directional markets.</p> <p>Features of the SLP:</p> <ul> <li>Defined maximum liability  </li> <li>Deterministic, path-invariant pricing  </li> <li>Complementary pricing between Red and Green  </li> <li>Simple accounting and auditable state  </li> </ul>"},{"location":"older/LMSR4/#2-key-concepts","title":"2. Key Concepts","text":"<ul> <li>Red Tokens (\\(R\\)): Represent one side of a binary market.  </li> <li>Green Tokens (\\(G\\)): Represent the other side.  </li> <li>Holdings (\\(h_R, h_G\\)): Balances of Red and Green held by the SLP.  </li> <li>Pairs: Always minted as 1 Red + 1 Green when USDC enters.  </li> <li>Spot Price: Determined directly from holdings:</li> </ul> <p>$$   p_R = \\frac{h_G}{h_R + h_G}, \\quad p_G = \\frac{h_R}{h_R + h_G}   $$</p> <p>with the invariant:</p> <p>$$   p_R + p_G = 1   $$</p>"},{"location":"older/LMSR4/#3-contract-roles","title":"3. Contract Roles","text":""},{"location":"older/LMSR4/#system-liquidity-provider-slp","title":"System Liquidity Provider (SLP)","text":"<ul> <li>Core AMM logic.  </li> <li>Holds Red and Green inventory.  </li> <li>Mints pairs when USDC is deposited.  </li> <li>Executes trades by selling one side against the other.  </li> <li>Updates balances to maintain deterministic pricing.  </li> </ul>"},{"location":"older/LMSR4/#red-erc20-contract","title":"Red ERC20 Contract","text":"<ul> <li>Standard ERC20 token for Red.  </li> <li>Minted and burned only by the SLP.  </li> </ul>"},{"location":"older/LMSR4/#green-erc20-contract","title":"Green ERC20 Contract","text":"<ul> <li>Standard ERC20 token for Green.  </li> <li>Minted and burned only by the SLP.  </li> </ul>"},{"location":"older/LMSR4/#4-trade-routine","title":"4. Trade Routine","text":""},{"location":"older/LMSR4/#41-market-initialization","title":"4.1 Market Initialization","text":"<p>An initial USDC deposit mints equal Red and Green tokens.  </p> <p>Example: deposit \\(F\\) USDC  </p> \\[ h_R = F \\] \\[ h_G = F \\] <p>Initial prices are symmetric:  </p> \\[ p_R = p_G = 0.5 \\]"},{"location":"older/LMSR4/#42-buying-red-with-usdc","title":"4.2 Buying Red with USDC","text":"<p>The trader has \\(D\\) USDC and wants Red tokens.</p> <ol> <li>Inventory preparation (accounting step).    The SLP mints \\(D\\) Red and \\(D\\) Green to itself to set a fixed pricing inventory.</li> </ol> \\[ h_R' = h_R + D \\] \\[ h_G' = h_G + D \\] \\[ S = h_R' + h_G' \\] \\[ S = h_R + h_G + 2D \\] <ol> <li> <p>Trade execution against the fixed inventory.    The trader spends all \\(D\\) to buy \\(Q\\) Red according to the cost function.</p> </li> <li> <p>Post-trade balances.</p> </li> </ol> \\[ h_R = h_R' - Q \\] \\[ h_G = h_G' \\]"},{"location":"older/LMSR4/#5-deriving-the-cost-function-and-the-quantity-function","title":"5. Deriving the Cost Function and the Quantity Function","text":""},{"location":"older/LMSR4/#step-1-marginal-price-curve-from-first-principles","title":"Step 1. Marginal price curve (from first principles)","text":"<p>We want to know how the price of Red changes as the user buys red tokens.</p> <p>That is when a user buys Q tokens, what is the price of each unit.</p> <p>That is the price when the SLP has already sold \\(q\\) Red tokens.</p> <ul> <li>The first step of the process is that the SLP mints additional tokens equal to the D USDC which the user is supplying to buy tokens. This now becomes the total inventory S</li> </ul> \\[ S = h_R' + h_G' \\] <ul> <li>If \\(q\\) Red tokens have been sold, the remaining Red inventory is</li> </ul> \\[ h_R' - q \\] <ul> <li>At that point, the total remaining inventory is</li> </ul> \\[ S - q \\] <p>The pricing rule says that the price of Red is equal to the proportion of Green in the remaining inventory:</p> \\[ p_R(q) = \\frac{h_G'}{S - q} \\] \\[ \\lim_{q \\uparrow h_R'} (S - q) = h_G' \\] \\[ \\lim_{q \\uparrow h_R'} p_R(q) = 1 \\]"},{"location":"older/LMSR4/#step-2-small-quantity-cost","title":"Step 2. Small quantity cost","text":"<p>Now consider buying a tiny quantity \\(\\delta q\\) of Red Tokens. The cost of those tokens is the price of them multiplied by the quantity of them</p> \\[ \\delta D = p_R(q) \\cdot \\delta q \\]"},{"location":"older/LMSR4/#step-3-quantity-function","title":"Step 3. Quantity Function","text":"<p>Now if we buy a series of small quantities \\(Q\\) of Red tokens, we sum over all increments to find the price:</p> \\[ D(Q) \\approx \\sum \\, p_R(q) \\cdot \\delta q \\]"},{"location":"older/LMSR4/#step-4-limit-to-an-integral","title":"Step 4. Limit to an integral","text":"<p>As \\(\\delta q \\to 0\\), the sum becomes an integral:</p> \\[ D(Q) = \\int_{0}^{Q} p_R(q)\\,dq \\] \\[ D(Q) = \\int_{0}^{Q} \\frac{h_G'}{S - q}\\,dq \\]"},{"location":"older/LMSR4/#step-5-evaluate-the-integral","title":"Step 5. Evaluate the integral","text":"\\[ D(Q) = -\\,h_G' \\cdot \\ln(S - q)\\;\\Big|_{0}^{Q} \\] \\[ D(Q) = h_G' \\cdot \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] <p>Substituting for initial varibles</p> \\[ D(Q) = (h_G + D) \\cdot \\ln\\!\\left(\\frac{\\,h_R + h_G + 2D\\,}{\\,h_R + h_G + 2D - Q\\,}\\right) \\]"},{"location":"older/LMSR4/#step-3-tokens-as-a-function-of-spend","title":"Step 3. Tokens as a function of spend","text":"<p>Invert to solve for \\(Q\\):</p> \\[ \\frac{D(Q)}{h_G'} = \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ e^{-D(Q)/h_G'} = \\frac{S - Q}{S} \\] \\[ Q(D) = S \\cdot \\left(1 - e^{-D/h_G'}\\right) \\] <p>Restriction:</p> \\[ 0 &lt; Q &lt; h_R' \\] <p>Substituted form:</p> \\[ Q(D) = \\big(h_R + h_G + 2D\\big) \\cdot \\left(1 - e^{-\\,D/(h_G + D)}\\right) \\]"},{"location":"older/LMSR4/#6-properties","title":"6. Properties","text":"<ul> <li>Deterministic Pricing: Prices depend only on SLP token holdings.  </li> <li>Finite Liability:  Liability is simply the initial funding of the SLP.</li> <li>Fixed Complementary Pricing: Red and Green always sum to 1.  </li> <li>Path Invariance: Deposit and immediate withdraw returns the same USDC.  </li> </ul>"},{"location":"older/LMSR4/#7-extending-to-three-position-market","title":"7. Extending to three position market","text":""},{"location":"older/LMSR4/#71-market-initialization","title":"7.1 Market Initialization","text":"<p>An initial USDC deposit mints equal R G and B tokens.  </p> <p>Example: deposit \\(F\\) USDC  </p> \\[ h_R = F \\] \\[ h_G = F \\] \\[ h_B = F \\] <p>A subsequent user deposit of \\(D\\) USDC mints \\(D\\) of each into SLP inventory.</p> \\[ h_R' = h_R + D \\] \\[ h_G' = h_G + D \\] \\[ h_B' = h_B + D \\] \\[ S = h_R' + h_G' + h_B' \\]"},{"location":"older/LMSR4/#72-spot-prices-pre-trade","title":"7.2 Spot Prices (pre-trade)","text":"\\[ S_0 = h_R + h_G + h_B \\] \\[ p_R = \\frac{h_G + h_B}{2 S_0} \\] \\[ p_G = \\frac{h_R + h_B}{2 S_0} \\] \\[ p_B = \\frac{h_R + h_G}{2 S_0} \\] \\[ p_R + p_G + p_B = 1 \\]"},{"location":"older/LMSR4/#73-spot-prices-mid-trade","title":"7.3 Spot Prices (mid-trade)","text":"\\[ S = h_R' + h_G' + h_B' \\] \\[ p_R = \\frac{h_G' + h_B'}{2 S} \\] \\[ p_G = \\frac{h_R' + h_B'}{2 S} \\] \\[ p_B = \\frac{h_R' + h_G'}{2 S} \\] \\[ p_R + p_G + p_B = 1 \\]"},{"location":"older/LMSR4/#73-buying-r","title":"7.3 Buying \\(R\\)","text":"\\[ p_R(q) = \\frac{h_G' + h_B'}{2\\,(S - q)} \\] \\[ D_R(Q) = \\int_{0}^{Q} p_R(q)\\,dq \\] \\[ D_R(Q) = \\frac{h_G' + h_B'}{2}\\,\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_R(x) = S\\left(1 - e^{-\\,\\frac{2x}{\\,h_G' + h_B'\\,}}\\right) \\] <p>Substituting for initial variables</p> \\[ h_G' + h_B' = h_G + h_B + 2D \\] \\[ S = h_R + h_G + h_B + 3D \\] \\[ D_R(Q) = \\frac{h_G + h_B + 2D}{2}\\,\\ln\\!\\left(\\frac{h_R + h_G + h_B + 3D}{h_R + h_G + h_B + 3D - Q}\\right) \\] \\[ Q_R(x) = \\big(h_R + h_G + h_B + 3D\\big)\\left(1 - e^{-\\,\\frac{2x}{\\,h_G + h_B + 2D\\,}}\\right) \\] <p>By symmetry</p> \\[ D_G(Q) = \\frac{h_R' + h_B'}{2}\\,\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_G(x) = S\\left(1 - e^{-\\,\\frac{2x}{\\,h_R' + h_B'\\,}}\\right) \\] \\[ D_B(Q) = \\frac{h_R' + h_G'}{2}\\,\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_B(x) = S\\left(1 - e^{-\\,\\frac{2x}{\\,h_R' + h_G'\\,}}\\right) \\]"},{"location":"older/LMSR4/#8-general-n-outcome-market","title":"8. General \\(n\\)-Outcome Market","text":""},{"location":"older/LMSR4/#81-market-initialization","title":"8.1 Market Initialization","text":"<p>An initial USDC deposit mints equal amounts of all \\(n\\) outcome tokens \\(X_1,\\dots,X_n\\).  </p> <p>Example: deposit \\(F\\) USDC  </p> \\[ h_i = F \\quad \\text{for } i \\in \\{1,\\dots,n\\} \\] <p>A subsequent user deposit of \\(D\\) USDC mints \\(D\\) of each into SLP inventory.</p> \\[ h_i' = h_i + D \\quad \\text{for } i \\in \\{1,\\dots,n\\} \\] \\[ S = \\sum_{i=1}^{n} h_i' \\]"},{"location":"older/LMSR4/#spot-prices-pre-trade","title":"Spot Prices (pre-trade)","text":"\\[ S_0 = \\sum_{i=1}^{n} h_i \\] \\[ p_i = \\frac{S_0 - h_i}{(n-1)\\,S_0} \\] \\[ \\sum_{i=1}^{n} p_i = 1 \\]"},{"location":"older/LMSR4/#spot-prices-mid-trade","title":"Spot Prices (mid-trade)","text":"\\[ S = \\sum_{i=1}^{n} h_i' \\] \\[ p_i = \\frac{S - h_i'}{(n-1)\\,S} \\] \\[ \\sum_{i=1}^{n} p_i = 1 \\]"},{"location":"older/LMSR4/#buying-outcome-k","title":"Buying outcome \\(k\\)","text":"\\[ p_k(q) = \\frac{S - h_k'}{(n-1)\\,(S - q)} \\] \\[ D_k(Q) = \\int_{0}^{Q} p_k(q)\\,dq \\] \\[ D_k(Q) = \\frac{S - h_k'}{\\,n-1\\,}\\;\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_k(x) = S\\left(1 - e^{-\\,\\frac{(n-1)\\,x}{\\,S - h_k'\\,}}\\right) \\] <p>Expanded in initial balances</p> \\[ S = \\sum_{i=1}^{n} h_i + nD \\] \\[ S - h_k' = \\sum_{j\\neq k} h_j + (n-1)D \\] \\[ p_k = \\frac{\\sum_{j\\neq k} h_j + (n-1)D}{(n-1)\\left(\\sum_{i=1}^{n} h_i + nD\\right)} \\] \\[ D_k(Q) = \\frac{\\sum_{j\\neq k} h_j + (n-1)D}{\\,n-1\\,}\\;\\ln\\!\\left(\\frac{\\sum_{i=1}^{n} h_i + nD}{\\sum_{i=1}^{n} h_i + nD - Q}\\right) \\] \\[ Q_k(x) = \\left(\\sum_{i=1}^{n} h_i + nD\\right)\\left(1 - \\exp\\!\\left[-\\,\\frac{(n-1)\\,x}{\\sum_{j\\neq k} h_j + (n-1)D}\\right]\\right) \\]"},{"location":"older/LMSR5/","title":"LMSR5","text":"<pre><code># LMSR System Liquidity Provider (SLP)\n\n## 1. Introduction\nThe **Logarithmic Market Scoring Rule (LMSR)**, introduced by Robin Hanson (2003, *Combinatorial Information Market Design*), is a closed-form automated market-making mechanism. It provides path-independent pricing and bounded liability, and has been used in several real-world prediction markets (e.g. Iowa Electronic Markets, Gnosis).\n\nThis document shows how LMSR is adapted into a **System Liquidity Provider (SLP)** for a **binary market** with two complementary tokens: **Red (R)** and **Green (G)**.\n\nThe SLP is not the market itself. The **Market Controller** handles only *splitting* and *merging*:\n\n- **Split**: 1 USDC \u2192 (1 R + 1 G).  \n- **Merge**: (1 R + 1 G) \u2192 1 USDC.\n\nThe **SLP** sits on top of this controller:\n\n- It acquires tokens from the Market Controller using USDC.  \n- It prices and trades tokens deterministically using LMSR formulas.  \n- It can be deployed as a Uniswap v4 hook, alongside other liquidity sources.\n\n**Key features:**\n\n* Bounded maximum liability.  \n* Deterministic, path-independent pricing.  \n* Complementary prices (\\(p_R + p_G = 1\\)).  \n* Transparent state (balances are auditable).\n\n---\n\n## 2. Key Concepts (Binary Market)\n\n- **Red Tokens (\\(R\\))**: One outcome.  \n- **Green Tokens (\\(G\\))**: The complementary outcome.  \n- **Holdings**:  \n- \\(h_R\\): balance of Red tokens held by the SLP.  \n- \\(h_G\\): balance of Green tokens held by the SLP.  \n- **LMSR Liquidity Parameter (\\(b\\))**: Controls depth of the market and maximum liability.  \n- **Market Controller**: Issues and redeems bundles of \\(R+G\\) against USDC.  \n- **System Liquidity Provider (SLP)**: Uses LMSR maths to trade \\(R\\) and \\(G\\) with users.\n\n---\n\n## 3. Funding &amp; Parameterization\n\n### 3.1 Bounded Loss in LMSR\nHanson proved that in an LMSR with \\(n\\) outcomes, the market maker\u2019s **worst-case loss** is:\n\n\\[\nL_{\\max} = b \\cdot \\ln n.\n\\]\n\nFor a **binary market** (\\(n=2\\)):\n\n\\[\nL_{\\max} = b \\cdot \\ln 2.\n\\]\n\n---\n\n### 3.2 Funding the SLP\nWe assume the SLP begins by providing **\\(F\\) USDC** into the Market Controller. This \\(F\\) is the maximum loss the SLP is willing to risk. Therefore:\n\n\\[\nF = b \\cdot \\ln 2,\n\\]\n\nwhich implies\n\n\\[\nb = \\frac{F}{\\ln 2}.\n\\]\n\n---\n\n### 3.3 Initialization\n1. **Deposit:** SLP deposits \\(F\\) USDC into the Market Controller.  \n2. **Split:** Controller issues \\(F\\) Red + \\(F\\) Green to the SLP.  \n3. **Set \\(b\\):**\n\n\\[\nb = \\tfrac{F}{\\ln 2}.\n\\]\n\n4. **Initial prices:**\n\n\\[\np_R = p_G = 0.5.\n\\]\n\n---\n\n## 4. LMSR Pricing (from Hanson)\n\nThe **LMSR cost function** is:\n\n\\[\nC(h_R, h_G) = b \\cdot \\ln\\!\\left(e^{h_R/b} + e^{h_G/b}\\right).\n\\]\n\n- **Spot price of Red**:\n\n\\[\np_R = \\frac{e^{h_R/b}}{e^{h_R/b} + e^{h_G/b}}\n\\]\n\n- **Spot price of Green**:\n\n\\[\np_G = \\frac{e^{h_G/b}}{e^{h_R/b} + e^{h_G/b}}\n\\]\n\n- Invariant:\n\n\\[\np_R + p_G = 1\n\\]\n\n---\n\n## 5. Trading Logic\n\n### 5.1 Buying Red\n\nThe cost to acquire \\(Q\\) Red tokens is:\n\n\\[\nD(Q) = C(h_R + Q, h_G) - C(h_R, h_G).\n\\]\n\nGiven spend \\(D\\), the number of Red tokens received is:\n\n\\[\nQ(D) = b \\cdot \\ln\\!\\left(\\frac{e^{D/b} - (1 - p_{R,0})}{p_{R,0}}\\right),\n\\]\n\nwhere \\(p_{R,0}\\) is the pre-trade Red price.\n\n**Inventory update:**\n\n\\[\nh_R \\gets h_R + Q(D), \n\\]\n\n\\[\nh_G \\text{ unchanged.}\n\\]\n\n---\n\n### 5.2 Buying Green\n\nBy symmetry:\n\n\\[\nD(Q) = C(h_R, h_G + Q) - C(h_R, h_G).\n\\]\n\n\\[\nQ(D) = b \\cdot \\ln\\!\\left(\\frac{e^{D/b} - (1 - p_{G,0})}{p_{G,0}}\\right).\n\\]\n\n**Inventory update:**\n\n\\[\nh_G \\gets h_G + Q(D).\n\\]\n\n---\n\n## 6. Merge and Split Logic\n\n- **Split (Controller)**: Trader deposits USDC \u2192 Controller issues (1 R + 1 G).  \n- The SLP may use this to increase inventory before trading.\n\n- **Merge (Controller)**: Trader returns (1 R + 1 G) \u2192 Controller redeems 1 USDC.  \n- Provides a canonical redemption path.  \n- Ensures outcome tokens cannot inflate unchecked.\n\n---\n\n## 7. Properties\n\n- **Bounded loss:** Worst-case liability is exactly the initial funding \\(F\\).  \n- **No idle USDC in SLP:** All USDC sits in the Market Controller, convertible through split/merge.  \n- **Composable:** SLP is just one LP \u2014 others may coexist.  \n- **Deterministic:** Prices depend only on \\((h_R,h_G)\\).\n\n---\n\n## 8. Summary\n- Market Controller: only split/merge, dumb and neutral.  \n- SLP: applies LMSR maths, provides deterministic liquidity.  \n- Funding \\(F\\) defines liquidity parameter \\(b\\).  \n- Binary market: Red + Green with complementary pricing.\n</code></pre>"},{"location":"older/LMSRnew/","title":"Logarithmic Market Scoring Rule (LMSR)","text":""},{"location":"older/LMSRnew/#introduction","title":"Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR) is one of the most widely used automated market maker mechanisms for prediction markets. It was originally proposed by Robin Hanson (2003, 2007) as part of his work on market scoring rules. The LMSR provides a simple, closed-form pricing function with bounded loss for the market maker, while ensuring liquidity at all times.</p>"},{"location":"older/LMSRnew/#cost-function","title":"Cost Function","text":"<p>The LMSR defines a cost function \\( C(\\mathbf{q}) \\), where \\(\\mathbf{q} = (q_1, q_2, \\dots, q_n)\\) represents the outstanding quantities of each of the \\(n\\) outcome securities. The cost function is:</p> \\[ C(\\mathbf{q}) = b \\cdot \\ln \\left( \\sum_{i=1}^{n} e^{q_i / b} \\right) \\] <ul> <li>\\(q_i\\): outstanding shares of security \\(i\\) </li> <li>\\(b &gt; 0\\): liquidity parameter (controls sensitivity of prices to order size)</li> </ul>"},{"location":"older/LMSRnew/#instantaneous-price","title":"Instantaneous Price","text":"<p>The instantaneous price of outcome \\(i\\) is the partial derivative of the cost function with respect to \\(q_i\\):</p> \\[ p_i(\\mathbf{q}) = \\frac{\\partial C(\\mathbf{q})}{\\partial q_i}  = \\frac{e^{q_i / b}}{\\sum_{j=1}^{n} e^{q_j / b}} \\] <p>This ensures:</p> \\[ \\sum_{i=1}^{n} p_i(\\mathbf{q}) = 1 \\]"},{"location":"older/LMSRnew/#properties","title":"Properties","text":"<ul> <li>Bounded Loss: The maximum loss for the market maker is bounded by \\(b \\cdot \\ln(n)\\).  </li> <li>Liquidity Control: Larger \\(b\\) values provide more liquidity (prices change slowly with trades), while smaller \\(b\\) values make prices more sensitive to trades.  </li> <li>Path Independence: The total cost to reach a state \\(\\mathbf{q}\\) is independent of the sequence of trades.  </li> </ul>"},{"location":"older/LMSRnew/#references","title":"References","text":"<ul> <li>Hanson, R. (2003). Combinatorial Information Market Design. Information Systems Frontiers, 5(1), 107\u2013119.  </li> <li>Hanson, R. (2007). Logarithmic Market Scoring Rules for Modular Combinatorial Information Aggregation. Journal of Prediction Markets, 1(1), 3\u201315.  </li> </ul>"},{"location":"older/PredictionPerps/","title":"What are Prediction Perps","text":""},{"location":"older/PredictionPerps/#introduction","title":"Introduction","text":"<ul> <li>Prediction Perps are a new DeFi asset class which revolutionizes prediction markets.</li> <li>Central to Prediction Perps is our native yield-bearing stablecoin ppUSDC.</li> </ul>"},{"location":"older/PredictionPerps/#yield-bearing-stablecoin-explained","title":"Yield-Bearing Stablecoin Explained","text":"<ul> <li>What is ppUSDC? ppUSDC is a stablecoin pegged 1:1 to USDC, functioning exactly like Aave\u2019s aUSDC.</li> <li>How does it generate yield? USDC is deposited into DeFi protocols, like Aave, which lend it out to borrowers, earning interest.</li> <li>Automatic growth: This interest is automatically passed to ppUSDC holders, increasing their balance over time without any active management.</li> <li>Creation and burning: New ppUSDC is created when USDC is deposited and burnt when USDC is withdrawn, mirroring aUSDC\u2019s mechanics.</li> </ul>"},{"location":"older/PredictionPerps/#predictionperps-mechanism","title":"PredictionPerps Mechanism","text":"<ul> <li>Splitting USDC: 1 ppUSDC can be split into 1 red and 1 green share for various markets. Equally, 1 red and 1 green share from any market can be joined to form 1 ppUSDC.</li> <li>Red and green shares: These pairs represent opposing positions, for example, a bullish (green) or bearish (red) stance on a football team\u2019s performance.</li> <li>Comparison to other systems: This functionality is similar to Polymarket\u2019s use of the Gnosis Conditional Token Framework, but designed for perpetual markets.</li> <li>Yield distribution: When ppUSDC is split into green and red shares for a specific market, the yield is split between the green and red shares.</li> <li>Market-specific rubrics: Each market has a rubric for splitting the interest between the green and red tokens according to various conditions.</li> <li>Example: In a football team performance market, wins increase the share of interest on the green side, while losses increase the share of interest on the red side.</li> </ul>"},{"location":"older/PredictionPerps/#decentralisation","title":"Decentralisation","text":"<ul> <li>Decentralised protocol: PredictionPerps operates without centralised control, enabling its tokens (ppUSDC, red, and green shares) to be used across the DeFi ecosystem.</li> <li>Interoperability: Tokens can integrate with various DeFi platforms, ensuring flexibility and accessibility for users.</li> </ul>"},{"location":"older/PredictionPerps/#liquidity-provision","title":"Liquidity Provision","text":"<ul> <li>Liquidity pools: PredictionPerps creates pools to support trading of red and green shares, with rewards distributed to staked liquidity provider (LP) tokens.</li> <li>Yield delegation: The applicable yield from the pools is delegated to the LP staking contract to prevent price drift.</li> <li>Uniswap V2: Initial liquidity is provided through Uniswap V2, with rewards split among staked LP token holders.</li> <li>Future scalability: Similar strategies will be implemented for Uniswap V3 and V4, optimizing liquidity provision and reward distribution.</li> </ul>"},{"location":"older/PredictionPerps/#liquidity-rewards","title":"Liquidity Rewards","text":"<ul> <li>Pool fees: Liquidity providers earn 0.3% trading fees from Uniswap V2 pools for facilitating red and green share trades.</li> <li>Yield from positions: Providers receive yield from ppUSDC and red/green shares held in the liquidity pools, distributed through the LP staking contract.</li> <li>Governance tokens: Governance tokens are distributed to liquidity providers via a deflationary emission schedule, incentivizing sustained participation.</li> </ul>"},{"location":"older/PredictionPerps/#protocol-revenue","title":"Protocol Revenue","text":"<ul> <li>Initial phase: The protocol initially operates without generating revenue, utilizing Aave\u2019s retail lending rates to distribute yield to ppUSDC holders.</li> <li>Future revenue model: Revenue can be generated by capturing the spread between lending and deposit rates, similar to Aave\u2019s model.</li> <li>Development or partnerships: The protocol may develop its own lending services or partner with DeFi protocols to secure rates more favorable than retail, allowing the protocol to retain a portion of the interest.</li> <li>Revenue source: Profits are derived from managing a large volume of deposits and retaining a percentage of the interest generated.</li> </ul>"},{"location":"older/PredictionPerps/#predictionperps-lab-revenue","title":"PredictionPerps Lab Revenue","text":"<ul> <li>Trading bots: PredictionPerps Lab may develop and deploy trading bots that leverage market inefficiencies or arbitrage opportunities within the protocol or across DeFi ecosystems, generating revenue through optimized trading strategies.</li> <li>Strategic investments: The lab can invest in promising DeFi projects, protocols, or tokens, earning returns through capital appreciation or yield-generating opportunities, similar to Uniswap Labs' investment strategies.</li> <li>Partnerships: Collaborations with other DeFi platforms, exchanges, or blockchain projects can create revenue streams through shared fees, co-developed products, or integration incentives, mirroring models used by entities like Uniswap Labs.</li> <li>Additional services: The lab may offer premium tools, analytics, or customized solutions for traders and liquidity providers, creating revenue through subscriptions or service fees, akin to value-added services provided by other DeFi labs.</li> </ul>"},{"location":"older/PredictionPerps/#roadmap","title":"Roadmap","text":"<ul> <li>Growth targets: Over the next five years, PredictionPerps aims to maximize total value locked (TVL) in its markets, targeting $10 billion. The governance token is projected to reach a market capitalization of $1 billion.</li> <li>Context: For comparison, Aave\u2019s governance token currently has a market cap of $4.7 billion with a total value locked of $33 billion (source: CoinGecko).</li> <li>Mainnet deployment: The protocol will initially launch on mainnet, serving as the primary trading platform for centralized exchanges to offer PredictionPerps to their users.</li> <li>Network expansion: As liquidity grows, instances will be deployed on other networks, with listings on exchanges to enhance accessibility.</li> <li>Mainnet advantages: Operating on mainnet enables the use of Uniswap\u2019s limit order book and Uniswap X for smart liquidity sourcing, providing greater flexibility in trading.</li> </ul>"},{"location":"older/SamFeedback/","title":"SamFeedback","text":"<ol> <li> <p>PPGT Value Dependency    PPGT will only incentivize user participation if it has a value above zero. If perceived as worthless or speculative, it may fail to drive engagement.</p> </li> <li> <p>Early Trading of PPGT    PPGT will likely trade from day one, as users or speculators create liquidity pools (e.g., on DEXs). This could lead to volatility or misalignment with the protocol's planned valuation at the transition phase.</p> </li> <li> <p>Low Reward Shave Percentage    Shaving 10% of rewards is very small </p> </li> <li> <p>Scale of Reward Distribution    Reaching 1 billion USDC in rewards (to distribute 1 billion PPGT) implies ~$20 billion in deposits. This could take 5\u201310 years, even with a successful system, delaying the transition phase significantly.</p> </li> <li> <p>Delayed Value Appreciation    If it takes 5+ years to reach the transition phase, the potential for PPGT to \"moon\" is deferred, which may frustrate early adopters and reduce hype or community engagement.</p> </li> <li> <p>Liquidity Pool Interactions    Emergent liquidity pools (from day-one trading) could complicate the protocol\u2019s planned trading launch after years of operation. Uncontrolled pools may dilute price stability or create arbitrage issues.</p> </li> <li> <p>Post-Deflationary User Incentives    In Phase 2, when PPGT is no longer distributed with rewards, new users receive only USDPP/USDC. This shifts their role to \"just users\" without ownership, potentially reducing loyalty or engagement compared to early adopters.</p> </li> <li> <p>Divergent Incentives    Once PPGT distribution stops, platform ownership is no longer distributed to new users. This creates a divide where token holders\u2019 incentives (e.g., maximizing protocol revenue or token price) which may diverge from those of new users. </p> </li> </ol>"},{"location":"older/TokenDistribution/","title":"Governance Tokenomics Plan","text":""},{"location":"older/TokenDistribution/#ideology-rationale","title":"Ideology &amp; Rationale","text":"<p>Simple, fair, deflationary token distribution.</p> <p>Fixed annual emissions ensure scarcity as protocol value (Total Value Locked / revenue) grows.</p>"},{"location":"older/TokenDistribution/#deflationary-mechanism","title":"Deflationary Mechanism","text":"<ul> <li>Fixed Emissions per year/block.</li> <li>Early years: high token share per dollar.<ul> <li>High Total emissions per $ TVL</li> </ul> </li> <li>Later years: lower share per dollar.<ul> <li>Low Total emissions per $ TVL</li> </ul> </li> </ul>"},{"location":"older/TokenDistribution/#rewarding-early-risk","title":"Rewarding Early Risk","text":"<ul> <li>Team/advisors get 0 tokens in Year 1.</li> <li>Allocations start Year 2, end by Year 10.</li> </ul>"},{"location":"older/TokenDistribution/#depositor-ownership","title":"Depositor Ownership","text":"<ul> <li>Depositors provide USDC for yield.</li> <li>Depositior token emissions share rises to 90% by Year 11.</li> <li>Fixed total emissions reward loyalty in downturns.</li> </ul>"},{"location":"older/TokenDistribution/#supply-discipline","title":"Supply Discipline","text":"<ul> <li>Fixed issuance cuts supply inflation over time.</li> <li>Revenue can be used for buybacks/burns to reduce supply.</li> </ul>"},{"location":"older/TokenDistribution/#governance-control","title":"Governance Control","text":"<ul> <li>Manages Treasury tokens/revenue for:</li> <li>Staking</li> <li>Liquidity</li> <li>Buybacks</li> <li>Development</li> <li>Community initiatives</li> </ul>"},{"location":"older/TokenDistribution/#treasury-assets","title":"Treasury Assets","text":""},{"location":"older/TokenDistribution/#principal","title":"Principal","text":"<ul> <li>USDC deposits deployed for yield (eg Aave) via governance.</li> </ul>"},{"location":"older/TokenDistribution/#revenue","title":"Revenue","text":"<ul> <li>USDC yield from DeFi (e.g., Aave).</li> <li>Held initially, later allocated for liquidity, developtment, buybacks, burns, rewards.</li> </ul>"},{"location":"older/TokenDistribution/#governance-tokens","title":"Governance Tokens","text":"<ul> <li>Used for staking, liquidity, grants.</li> <li>Drops to 10% of emissions by Year 11.</li> </ul>"},{"location":"older/TokenDistribution/#governance-role","title":"Governance Role","text":"<ul> <li>Controls Treasury via on-chain proposals.</li> </ul>"},{"location":"older/TokenDistribution/#token-emissions","title":"Token Emissions","text":""},{"location":"older/TokenDistribution/#annual-issuance","title":"Annual Issuance","text":"<ul> <li>10M tokens/year, uncapped.</li> </ul>"},{"location":"older/TokenDistribution/#total-supply","title":"Total Supply","text":"<ul> <li>linear increase</li> <li>eg 100M tokens after 10 years.</li> <li>eg 500M tokens after 50 years.</li> </ul>"},{"location":"older/TokenDistribution/#issuance-structure","title":"Issuance Structure","text":"<ul> <li>Linear issuance, ~1.9 tokens/block.</li> </ul>"},{"location":"older/TokenDistribution/#token-distribution","title":"Token Distribution","text":""},{"location":"older/TokenDistribution/#year-1-startup-phase","title":"Year 1: Startup Phase","text":"<ul> <li>Team: 0% (0 tokens).</li> <li>Advisors: 0% (0 tokens).</li> <li>Treasury: 40% (4M tokens).</li> <li>Depositors: 60% (6M tokens).</li> </ul>"},{"location":"older/TokenDistribution/#year-2","title":"Year 2","text":"<ul> <li>Team: 15% (1.5M tokens).</li> <li>Advisors: 3.75% (0.375M tokens).</li> <li>Treasury: 21% (2.1M tokens).</li> <li>Depositors: 60% (6M tokens).</li> </ul>"},{"location":"older/TokenDistribution/#year-10","title":"Year 10","text":"<ul> <li>Team: 7% (0.7M tokens).</li> <li>Advisors: 0.5% (0.05M tokens).</li> <li>Treasury: 11% (1.1M tokens).</li> <li>Depositors: 81.5% (8.15M tokens).</li> </ul>"},{"location":"older/TokenDistribution/#years-11-depositor-dominance","title":"Years 11+: Depositor Dominance","text":"<ul> <li>Team/Advisors: 0% (fully vested).</li> <li>Treasury: 10% (1M tokens/year).</li> <li>Depositors: 90% (9M tokens/year).</li> </ul>"},{"location":"older/TokenDistribution/#cumulative-token-distribution","title":"Cumulative Token Distribution","text":""},{"location":"older/TokenDistribution/#after-10-years-100m-tokens","title":"After 10 Years (100M tokens)","text":"<ul> <li>Team: ~10% (10M).</li> <li>Advisors: ~2.5% (2.5M).</li> <li>Treasury: ~16.9% (16.9M).</li> <li>Depositors: ~70.6% (70.6M).</li> </ul>"},{"location":"older/TokenDistribution/#after-20-years-200m-tokens","title":"After 20 Years (200M tokens)","text":"<ul> <li>Team: ~5% (10M).</li> <li>Advisors: ~1.25% (2.5M).</li> <li>Treasury: ~12.45% (24.9M).</li> <li>Depositors: ~81.3% (162.6M).</li> </ul>"},{"location":"older/TokenDistribution/#note","title":"Note","text":"<ul> <li>Linear growth reduces insider share; depositors dominate.</li> </ul>"},{"location":"older/TokenDistribution/#governance-token-staking","title":"Governance Token Staking","text":""},{"location":"older/TokenDistribution/#funding","title":"Funding","text":"<ul> <li>Funded by Treasury emittance.</li> </ul>"},{"location":"older/TokenDistribution/#governance-role_1","title":"Governance Role","text":"<ul> <li>Adjusts rewards.</li> </ul>"},{"location":"older/TokenDistribution/#governance-responsibilities","title":"Governance Responsibilities","text":""},{"location":"older/TokenDistribution/#manages-treasury","title":"Manages Treasury","text":"<ul> <li>Spends or invests yield</li> <li>Distributes treasury emittance</li> <li>Controls Protocol levers</li> </ul>"},{"location":"older/TokenDistribution/#why-it-works","title":"Why It Works","text":"<ul> <li>Predictable 10M/year issuance.</li> <li>Depositor focused rewards (reaching 90% of emissions) - growing TVL.</li> <li>Deflationary token issuance.</li> <li>Team advisor rewards capped</li> <li>Team and advisor rewards distributed from year 2-9. - Shared goals</li> <li>Token holders control Governance.</li> </ul>"},{"location":"older/TokenDistribution/#summary","title":"Summary","text":""},{"location":"older/TokenDistribution/#token-supply","title":"Token Supply","text":"<ul> <li>10M/year</li> <li>So 200M after 20 years for example</li> </ul>"},{"location":"older/TokenDistribution/#insider-cap","title":"Insider Cap","text":"<ul> <li>Total 12.5M tokens ie</li> <li>0% after 1 year</li> <li>12.5% after 10 years</li> <li>6.25% after 20 years.</li> <li>3.125 after 40 years</li> </ul>"},{"location":"older/TokenDistribution/#treasury-assets_1","title":"Treasury Assets","text":"<ul> <li>Revenue held early, later allocated; principal yields; tokens drop to 10%.</li> </ul>"},{"location":"older/TokenDistribution/#governance","title":"Governance","text":"<ul> <li>Ensures depositor dominance, flexible strategy.</li> </ul>"},{"location":"older/V2/","title":"Perpetual Prediction Markets: V2","text":""},{"location":"older/V2/#introduction","title":"Introduction","text":""},{"location":"older/V2/#overview","title":"Overview","text":"<p>Traditional prediction markets, like Polymarket, focus on time-bound events such as elections or sports outcomes. While effective for short-term forecasting, they lack support for long-term hedging or sustained positions on recurring phenomena.</p>"},{"location":"older/V2/#limitations-of-expiring-markets","title":"Limitations of Expiring Markets","text":"<ul> <li>Finite Duration: Positions expire at event resolution, despite entities like sports teams, political parties, or economic indicators persisting over time.</li> <li>Repetitive Investment: Users must repurchase contracts each cycle (e.g., season), incurring fees and limiting long-term strategies.</li> <li>Event-Centric Focus: Markets emphasize one-off events and fail to support speculation on the longevity or sustained state of ongoing phenomena, such as a career\u2019s trajectory or persistent conditions.</li> </ul>"},{"location":"older/V2/#perpetual-prediction-tokens-ppts","title":"Perpetual Prediction Tokens (PPTs)","text":""},{"location":"older/V2/#concept","title":"Concept","text":"<p>Perpetual Prediction Tokens (PPTs) are non-expiring tokens designed for markets that enable speculation on recurring or persistent phenomena, supporting long-term \"buy and hold\" strategies.</p>"},{"location":"older/V2/#core-features","title":"Core Features","text":"<ul> <li>Indefinite Persistence: Tokens never expire, allowing continuous market participation.</li> <li>Dividend Payouts: Holders receive dividends (in USDC) during \"true\" periods, based on periodic evaluations (e.g., annual) via oracles like UMA.</li> <li>Dynamic Pricing: Token prices adjust to market sentiment, reflecting the discounted probability of future \"true\" outcomes and their expected duration.</li> <li>Verifiable Outcomes: Focus on clear, oracle-resolved truth statements.</li> </ul>"},{"location":"older/V2/#use-cases","title":"Use Cases","text":"<ul> <li>Sports: \"Liverpool are Premier League Champions,\" \"Crystal Palace are in the Premier League,\" \"Tottenham are in Champions League,\" \"Serena Williams is a top 8 tennis player.\"</li> <li>Entertainment: \"Taylor Swift is the most streamed artist on Spotify.\"</li> <li>Economics: \"CPI inflation is greater than 3%.\"</li> <li>Politics: \"Nigel Farage is Prime Minister,\" \"Labour have a majority in Parliament,\" \"JD Vance is President.\"</li> <li>Space: \"There are people on Mars,\" \"There are people on the Moon.\"</li> <li>BTC Mining Threshold: \"BTC &gt;= $50,000.\"</li> <li>Weather: \"New York Cooling Days over/under X.\"</li> </ul>"},{"location":"older/V2/#perpetual-vs-expiring-markets","title":"Perpetual vs. Expiring Markets","text":""},{"location":"older/V2/#challenges-of-expiring-markets","title":"Challenges of Expiring Markets","text":"<p>Expiring markets require users to repurchase contracts each cycle, incurring fees and preventing sustained positions. They focus on specific milestones rather than ongoing states or longevity.</p> <p>For example:</p> <ul> <li>Betting on \"Will Newcastle United win the Premier League?\" requires annual repurchasing, ignoring the team\u2019s long-term trajectory.</li> <li>Markets like \"Keir Starmer is Prime Minister\" or \"Taylor Swift is the most streamed artist\" don\u2019t allow speculation on the duration of their tenure or dominance.</li> <li>A market like \"Serena Williams is a top 8 tennis player\" would focus on breaking into the top 8 for a single season, not her career-long performance.</li> </ul>"},{"location":"older/V2/#how-ppts-solve-these-issues","title":"How PPTs Solve These Issues","text":"<p>PPTs create fluid, perpetual markets that: - Allow a single position to cover all future cycles, capturing long-term trends or careers. - Reward holders with dividends during \"true\" periods. - Reflect evolving probabilities through dynamic pricing.</p>"},{"location":"older/V2/#key-mechanics","title":"Key Mechanics","text":""},{"location":"older/V2/#token-structure","title":"Token Structure","text":"<ul> <li>T: Bullish position (e.g., \"Yes, Newcastle is champion\").</li> <li>\\(\\overline{T}\\): Bearish position (e.g., \"No, Newcastle is not champion\").</li> <li>Pricing: Constant sum mechanism (\\(P_T + P_{\\overline{T}} = 1\\) USDC) enables minting/burning for arbitrage.</li> </ul>"},{"location":"older/V2/#outcome-evaluation","title":"Outcome Evaluation","text":"<ul> <li>Binary Outcomes (V1): Conditions are evaluated as \"true\" or \"false\" (e.g., annually for sports).</li> <li>Bounded Outcomes (V2): Future iterations will support more complex, bounded outcomes.</li> <li>Oracle-Based Resolution: Verifiable via oracles like UMA.</li> </ul>"},{"location":"older/V2/#dividend-mechanism","title":"Dividend Mechanism","text":"<ul> <li>Dividends (in USDC) are paid only when the condition is \"true,\" based on a predefined rubric.</li> <li>Tokens persist indefinitely; yields toggle based on oracle outcomes, with prices reflecting long-term expectations.</li> </ul>"},{"location":"older/V2/#benefits","title":"Benefits","text":"<ul> <li>Long-Term Positions: Holders can maintain positions without repurchasing.</li> <li>Dividend Rewards: Sustained success generates ongoing yields.</li> <li>Market Efficiency: Prices adapt to new information, supporting arbitrage opportunities.</li> </ul>"},{"location":"older/V2/#example-newcastle-united-premier-league-champions","title":"Example: Newcastle United Premier League Champions","text":""},{"location":"older/V2/#outcome","title":"Outcome","text":"<p>Evaluated annually post-season: \"Is Newcastle United the current Premier League champion?\"</p>"},{"location":"older/V2/#tokens","title":"Tokens","text":"<ul> <li>T: Yes, Newcastle is champion.</li> <li>\\(\\overline{T}\\): No, Newcastle is not champion.</li> </ul>"},{"location":"older/V2/#yields","title":"Yields","text":"<ul> <li>If \"Yes,\" T holders receive yield \\(r\\) (or proportional); \\(\\overline{T}\\) holders receive 0.</li> <li>If \"No,\" \\(\\overline{T}\\) holders receive yield; T holders receive 0.</li> </ul>"},{"location":"older/V2/#market-dynamics","title":"Market Dynamics","text":"<ul> <li>Initial State: T at 0.03 USDC (low odds), \\(\\overline{T}\\) at 0.97 USDC.</li> <li>On Success: T price surges (e.g., to 0.8 USDC); T holders earn dividends.</li> <li>Long-Term Potential: A $100 investment in T may yield nothing for years but could generate $500/year in dividends upon success, plus capital gains.</li> </ul>"},{"location":"older/V2/#advantage-over-expiring-markets","title":"Advantage Over Expiring Markets","text":"<p>Unlike Polymarket, where users repurchase contracts each season, PPTs allow supporters to buy and hold a single position covering all future seasons, capturing long-term trends.</p>"},{"location":"older/footballperps/","title":"Football Perps Specification","text":""},{"location":"older/footballperps/#overview","title":"Overview","text":"<p>FootballPerps is the flagship product of PredictionPerps and the pioneer in a groundbreaking new asset class - Perpetual Prediction Markets! FootballPerps enables users to buy and sell perpetual positions on the performance of football teams.</p>"},{"location":"older/footballperps/#purpose-of-perpetual-prediction-markets","title":"Purpose of Perpetual Prediction Markets","text":"<ul> <li>A fun new mechanism for speculation.</li> <li>Removes centralisation from prediction markets.</li> <li>Introduce a perpetual asset class.</li> <li>Create a new crypto primitive that can be built upon.</li> <li>Allow the full range of DeFi products to be used in conjunction with prediction markets.</li> <li>Allow Centralised Exchanges to sell prediction tokens.</li> </ul>"},{"location":"older/footballperps/#predictionperps-roadmap","title":"PredictionPerps Roadmap","text":"<ul> <li>Integrate FootballPerps with the DeFi ecosystem including leveraged perpetuals, order books, and additional derivatives.</li> <li>Develop Perpetual Prediction Markets in other sports, events, or asset classes, creatinag a scalable, versatile ecosystem for PredictionPerps\u2019 future products.</li> </ul>"},{"location":"older/footballperps/#how-it-works","title":"How It Works","text":"<ul> <li>Take a Position: Buy bullish or bearish shares on football teams using USDC. These shares reflect your view on whether a team\u2019s performance will rise or fall, allowing profits from buying low and selling high.</li> <li>Earn Daily Rewards: Receive native FootballPerps tokens daily based on your team\u2019s recent game results. Stronger performance rewards bullish holders, while weaker performance benefits bearish holders, driving dynamic price shifts and enabling profit through token accumulation.</li> <li>No Loss from Interest: Tokens are backed by interest generated through Aave, ensuring users don\u2019t lose out, unlike traditional prediction markets.</li> <li>Powered by DeFi: Uniswap liquidity pools and Aave ensure a stable, efficient market, with the FootballPerps frontend optimizing trades, especially for large purchases.</li> <li>Distributed and Timeless: As a distributed protocol, shares never expire and can be traded across the entire crypto ecosystem, maximizing access and liquidity.</li> <li>Premier League and Championship: Starts with markets for all Premier League teams.</li> </ul> <p>FootballPerps blends the excitement of football with decentralized finance, creating boundless opportunities for speculation and innovation.</p>"},{"location":"older/footballperps/#components","title":"Components","text":"<ul> <li>Shares: Users can hold bullish or bearish shares representing their position on a football team\u2019s performance, purchased using USDC or USSD via FootballPerps-managed interactions with Uniswap liquidity pools.</li> <li>Funding Mechanism: FootballPerps distributes native perp payment tokens daily based on team performance metrics, backed by interest generated on USDC held by FootballPerps through Aave.</li> <li>Team Performance Tracking: Tracks rolling cumulative point scores over the last 38 games for Premier League teams (with adjustment for Championship teams).</li> <li>Perp Payment Tokens: Native tokens distributed daily to share holders, backed by interest on USDC held by FootballPerps, with potential market floatation and additional utility (e.g., burning for governance tokens).</li> <li>USSD Stablecoin: A stablecoin pegged 1:1 with USDC through minting and burning mechanisms.</li> <li>Liquidity Pools: Two liquidity pools (bullish USSD and bearish USSD) on Uniswap provide synthetic liquidity for trading bullish and bearish shares, utilized by FootballPerps to facilitate trades, with imbalances equalized by arbitrage bots.</li> <li>Frontend Algorithm: An algorithm that optimizes the buy/sell path for users, providing the best execution (especially for large purchases) by leveraging four bidirectional operations to execute trades through FootballPerps, without direct user access to Uniswap liquidity pools:</li> <li>USDC&lt;-&gt;USSD: Contract-based minting or burning of USSD to maintain a 1:1 peg with USDC.</li> <li>USSD&lt;-&gt;bullish,bearish pair: Minting or burning a pair of bullish and bearish shares for 1 USSD.</li> <li>USSD&lt;-&gt;bullish pool: Swapping USSD for bullish shares (or vice versa) via the Uniswap bullish USSD pool.</li> <li>USSD&lt;-&gt;bearish pool: Swapping USSD for bearish shares (or vice versa) via the Uniswap bearish USSD pool.</li> <li>Further components TBD: Based on Championship adjustment details, token management, and platform implementation.</li> </ul>"},{"location":"older/footballperps/#functionality","title":"Functionality","text":"<ul> <li>Position Types:</li> <li>Users can take perpetual bullish (expecting team performance to rise) or bearish (expecting team performance to decline) positions on football teams.</li> <li>Positions are represented as shares, split into bullish and bearish categories, similar to Polymarket\u2019s share system.</li> <li>Users purchase bullish or bearish shares using USDC, which can be converted to USSD for FootballPerps-managed interactions with Uniswap liquidity pools.</li> <li>Funding Mechanism:</li> <li>For Premier League teams, FootballPerps uses a rolling cumulative point score from a team\u2019s last 38 games. The bullish ratio is calculated as the cumulative point score divided by 114 (38 games \u00d7 3 points per game). The bearish ratio is calculated as 1 minus the bullish ratio.</li> <li>For Championship teams, a discount factor (e.g., 1/5) is applied to points to reflect their lower value compared to Premier League points.</li> <li>The bearish ratio is capped at a maximum of 0.93 (equivalent to a minimum bullish ratio of 0.07, or approximately 8 points in the Premier League and 40 points in the Championship after discounting), preventing teams in terminal decline from draining FootballPerps liquidity.</li> <li>Each day, holders of bullish shares receive perp payment tokens proportional to the bullish ratio.</li> <li>Each day, holders of bearish shares receive perp payment tokens proportional to the bearish ratio.</li> <li>NB: For teams relegated to the Championship, FootballPerps may use a 46-game rolling window (reflecting the Championship\u2019s season length) instead of a 38-game window, with adjustments needed to account for the different league structure (details TBD).</li> <li>For teams relegated from the Championship, tracking of games ceases, as their discounted points cannot exceed the 0.07 bullish ratio threshold.</li> <li>Perp Payment Tokens:</li> <li>Tokens are native to FootballPerps and backed by the interest generated on USDC held by FootballPerps through Aave, establishing a floor price.</li> <li>Tokens may be floated on the market, possibly introducing additional utility, such as burning tokens to acquire governance tokens.</li> <li>Details on token distribution mechanics and governance token functionality TBD.</li> <li>Interest Generation:</li> <li>FootballPerps holds USDC paid by users to open bullish or bearish positions.</li> <li>Interest on USDC is generated using Aave, which backs the perp payment tokens.</li> <li>Details on Aave integration, security, and reliability mechanisms TBD.</li> <li>USSD Stablecoin and Liquidity Pools:</li> <li>USSD is a stablecoin pegged 1:1 with USDC through minting and burning mechanisms.</li> <li>At t=0, two liquidity pools are created on Uniswap: bullish USSD and bearish USSD. The pools are initialized with a depth (D) and a weighting factor (W) to set the starting price. For example, with D = 10,000 and W = 0.8, the bullish pool contains 10,000 bullish shares against 8,000 USSD, and the bearish pool contains 10,000 bearish shares against 2,000 USSD, establishing synthetic liquidity.</li> <li>A pair of bullish and bearish tokens can be minted or burned for 1 USSD, capping the price of bullish and bearish shares between 0 and 1.</li> <li>Users buy or sell shares through FootballPerps, which utilizes Uniswap\u2019s bullish and bearish USSD liquidity pools to execute trades. Direct interaction with Uniswap pools is suboptimal, while the FootballPerps frontend provides optimal execution, especially for large purchases.</li> <li>The Uniswap liquidity pools are open to the broader crypto ecosystem, allowing anyone to buy tokens directly, with imbalances quickly equalized by arbitrage bots.</li> <li>A frontend algorithm optimizes the buy/sell path for users by leveraging four bidirectional operations:<ul> <li>USDC&lt;-&gt;USSD: Contract-based minting or burning of USSD to maintain a 1:1 peg with USDC.</li> <li>USSD&lt;-&gt;bullish,bearish pair: Minting or burning a pair of bullish and bearish shares for 1 USSD.</li> <li>USSD&lt;-&gt;bullish pool: Swapping USSD for bullish shares (or vice versa) via the Uniswap bullish USSD pool.</li> <li>USSD&lt;-&gt;bearish pool: Swapping USSD for bearish shares (or vice versa) via the Uniswap bearish USSD pool.</li> </ul> </li> <li>Arbitrage prevention is handled through optimized mechanisms via the frontend, ensuring efficient trading.</li> </ul>"},{"location":"older/footballperps/#scope","title":"Scope","text":"<ul> <li>FootballPerps supports positions on teams in the English Premier League and the Championship, with initial markets covering current Premier League teams.</li> <li>FootballPerps accommodates teams relegated from the Premier League, allowing positions on non-Premier League teams over time.</li> </ul>"},{"location":"older/test/","title":"Test Chart (chartjs fence)","text":"<pre><code>{\n  \"type\": \"line\",\n  \"data\": {\n    \"labels\": [0, 1],\n    \"datasets\": [{\n      \"label\": \"Test\",\n      \"data\": [0, 1],\n      \"borderColor\": \"#FF6384\",\n      \"fill\": false\n    }]\n  },\n  \"options\": {\n    \"responsive\": true,\n    \"plugins\": { \"legend\": { \"position\": \"top\" } }\n  }\n}\n</code></pre>"},{"location":"older/sections/10RebasingSketch/","title":"Rebasing Mechanism Sketch","text":""},{"location":"older/sections/10RebasingSketch/#introduction","title":"Introduction","text":"<p>This document outlines a rebasing vault smart contract in Solidity. Users deposit an underlying token (T) to receive a rebasing token (aT). The aT balance grows via periodic rebases, but new deposits remain fixed until activated at the next <code>rebase()</code> call. The rate at each checkpoint (<code>rebase_id = n</code>) applies to the period from <code>n-1</code> to <code>n</code>.</p> <p>Key Goals: - Support variable rates per rebase period. - Efficient: No iteration over users or deposits in <code>rebase()</code>. - User balances split into activated (rebasing, transferable) and pending (fixed until activation, non-transferable). - Use a cumulative index with historical snapshots for accurate accounting.</p> <p>Assumptions: - Rebase rate is provided externally (complex calculation, not detailed). - Scale factor: 1e18 for fixed-point math. - ERC20-based with overrides for <code>balanceOf</code>, <code>totalSupply</code>, <code>transfer</code>, etc. - Withdrawals distribute underlying T proportionally (vault accrues yield).</p>"},{"location":"older/sections/10RebasingSketch/#core-concepts","title":"Core Concepts","text":""},{"location":"older/sections/10RebasingSketch/#cumulative-index","title":"Cumulative Index","text":"<ul> <li>Global multiplier tracking growth since inception.</li> <li>Starts at <code>1e18</code>.</li> <li>Updated in <code>rebase()</code>: <code>new_index = old_index * (1e18 + rate) / 1e18</code>.</li> <li>Represents compounded rates from all rebases.</li> </ul>"},{"location":"older/sections/10RebasingSketch/#rebase-id-and-history","title":"Rebase ID and History","text":"<ul> <li><code>current_rebase_id</code>: Starts at 0, increments per <code>rebase()</code>.</li> <li><code>cumulative_index_history[rebase_id]</code>: Stores <code>cumulative_index</code> after each rebase.</li> <li>Rate from <code>x</code> to <code>y</code>: <code>(cumulative_index_history[y] * 1e18 / cumulative_index_history[x]) - 1e18</code>.</li> </ul>"},{"location":"older/sections/10RebasingSketch/#user-balance-parts","title":"User Balance Parts","text":"<p>Each user has two balance components (no arrays): 1. Activated Part (Part 1):    - Stored as <code>user_effective_shares</code> (normalized shares).    - Balance: <code>user_effective_shares * cumulative_index / 1e18</code>.    - Grows with every rebase, reflecting all rates post-activation.    - Transferable to other addresses. 2. Pending Part (Part 2):    - Stored as <code>user_pending_base</code> (raw amount) with <code>user_pending_entry_id</code> (activation rebase_id).    - Fixed if <code>user_pending_entry_id &gt; current_rebase_id</code>.    - If activated (<code>entry_id &lt;= current_rebase_id</code>), balance = <code>user_pending_base * cumulative_index / cumulative_index_history[entry_id]</code>.    - Non-transferable; remains with depositor until merged.    - Multiple deposits before a rebase accumulate in the same pending part.</p>"},{"location":"older/sections/10RebasingSketch/#global-tracking","title":"Global Tracking","text":"<ul> <li><code>effective_shares</code>: Sum of all <code>user_effective_shares</code>.</li> <li><code>global_pending_base</code>: Total pending deposits (single <code>entry_id</code>).</li> <li><code>global_pending_entry_id</code>: Pending group ID (one cohort at a time).</li> </ul>"},{"location":"older/sections/10RebasingSketch/#rebase-process","title":"Rebase Process","text":"<ol> <li>Input: Rate for period from <code>current_rebase_id</code> to <code>current_rebase_id + 1</code> (external).</li> <li>Update Index: <code>cumulative_index = cumulative_index * (1e18 + rate) / 1e18</code>.</li> <li>Store History: Increment <code>current_rebase_id</code>, set <code>cumulative_index_history[current_rebase_id] = cumulative_index</code>.</li> <li>Activate Pending: If <code>global_pending_entry_id == current_rebase_id</code>:</li> <li>Add <code>global_pending_base * 1e18 / cumulative_index</code> to <code>effective_shares</code>.</li> <li>Reset <code>global_pending_base = 0</code>, <code>global_pending_entry_id = 0</code>.</li> <li>Effects: Activated balances grow by rate; pending deposits activate without prior gains.</li> </ol> <p>Efficiency: O(1), no user loops.</p>"},{"location":"older/sections/10RebasingSketch/#rate-handling","title":"Rate Handling","text":"<ul> <li>Rate at Checkpoint n: Applies to period from <code>n-1</code> to <code>n</code>, used in <code>rebase()</code> to update <code>cumulative_index</code>.</li> <li>Querying Rates: Rate from <code>x</code> to <code>y</code> (y &gt; x): <code>(cumulative_index_history[y] * 1e18 / cumulative_index_history[x]) - 1e18</code>.</li> <li>Example:</li> <li>Rebase 1 (rate = 0.05e18): <code>history[1] = 1.05e18</code>.</li> <li>Rebase 2 (rate = 0.03e18): <code>history[2] = 1.05e18 * 1.03 = 1.0815e18</code>.</li> <li>Rate at checkpoint 2 (from 1 to 2): <code>(1.0815e18 / 1.05e18) - 1 = 0.03</code>.</li> </ul>"},{"location":"older/sections/10RebasingSketch/#user-interactions","title":"User Interactions","text":""},{"location":"older/sections/10RebasingSketch/#deposit","title":"Deposit","text":"<ol> <li>Merge pending if <code>user_pending_entry_id &lt;= current_rebase_id</code> (see Merge).</li> <li>Transfer T to vault.</li> <li>Set <code>entry_id = current_rebase_id + 1</code>.</li> <li>Add <code>amount</code> to <code>user_pending_base</code> (accumulate if same <code>entry_id</code>).</li> <li>Set <code>user_pending_entry_id = entry_id</code> if unset.</li> <li>Update globals: Add to <code>global_pending_base</code>, set <code>global_pending_entry_id</code> if needed.</li> <li>Mint aT equal to <code>amount</code>.</li> </ol> <p>Note: New deposits are fixed and non-transferable until next rebase.</p>"},{"location":"older/sections/10RebasingSketch/#withdraw","title":"Withdraw","text":"<ol> <li>Merge pending if activated.</li> <li>Compute total balance = activated + pending (fixed or rebased).</li> <li>Require amount &lt;= total.</li> <li>Pro-rata reduce <code>user_effective_shares</code> and <code>user_pending_base</code>.</li> <li>Update globals: Subtract from <code>effective_shares</code>, <code>global_pending_base</code> if applicable.</li> <li>Burn aT, transfer proportional T (based on <code>totalSupply</code>).</li> </ol>"},{"location":"older/sections/10RebasingSketch/#transfer","title":"Transfer","text":"<ol> <li>Merge pending for sender and recipient if <code>user_pending_entry_id &lt;= current_rebase_id</code>.</li> <li>Compute sender's total balance (activated + pending), require amount &lt;= total.</li> <li>Calculate activated balance: <code>user_effective_shares[sender] * cumulative_index / 1e18</code>.</li> <li>Determine transferable amount:</li> <li>Only the activated part is transferable.</li> <li>If amount &lt;= activated balance, use only activated.</li> <li>If amount &gt; activated balance but &lt;= total, fail (pending is non-transferable).</li> <li>Reduce sender\u2019s <code>user_effective_shares</code> by <code>amount * 1e18 / cumulative_index</code>.</li> <li>Add to recipient\u2019s <code>user_effective_shares</code> (same amount).</li> <li>Update global <code>effective_shares</code> (no net change).</li> <li>Pending Note: Sender\u2019s <code>user_pending_base</code> and <code>user_pending_entry_id</code> remain unchanged (non-transferable). Recipient\u2019s pending part is unaffected.</li> <li>Emit Transfer event.</li> </ol> <p>Transfer Clarification: Only activated balances (rebasing, from <code>user_effective_shares</code>) can be transferred. Pending balances (fixed, non-rebasing) stay with the sender until activated and merged, ensuring pending deposits are tied to the original depositor.</p>"},{"location":"older/sections/10RebasingSketch/#merge-internal","title":"Merge (Internal)","text":"<ul> <li>If <code>user_pending_entry_id &lt;= current_rebase_id</code>:</li> <li>Convert: <code>delta_shares = user_pending_base * 1e18 / cumulative_index_history[user_pending_entry_id]</code>.</li> <li>Add to <code>user_effective_shares</code> and <code>effective_shares</code>.</li> <li>Clear <code>user_pending_base</code>, <code>user_pending_entry_id</code>.</li> </ul>"},{"location":"older/sections/10RebasingSketch/#balance-calculation-balanceof","title":"Balance Calculation (balanceOf)","text":"<ul> <li>Activated: <code>user_effective_shares * cumulative_index / 1e18</code>.</li> <li>Pending:</li> <li>If <code>entry_id &gt; current_rebase_id</code>: <code>user_pending_base</code> (fixed).</li> <li>Else: <code>user_pending_base * cumulative_index / cumulative_index_history[entry_id]</code>.</li> <li>Total: Sum of both.</li> </ul>"},{"location":"older/sections/10RebasingSketch/#total-supply","title":"Total Supply","text":"<ul> <li>Activated: <code>effective_shares * cumulative_index / 1e18</code>.</li> <li>Pending: <code>global_pending_base</code> if <code>global_pending_entry_id &gt; current_rebase_id</code>, else 0.</li> <li>Total: Sum.</li> </ul>"},{"location":"older/sections/10RebasingSketch/#efficiency-and-scalability","title":"Efficiency and Scalability","text":"<ul> <li>Storage: Per-user: 3 slots. Global: Scalars + <code>cumulative_index_history</code> (grows with rebases).</li> <li>Gas:</li> <li><code>rebase()</code>: O(1).</li> <li>User ops: O(1), at most one merge.</li> <li>Views: O(1).</li> <li>No Iteration: Uses aggregates and history mapping.</li> <li>Scalability: Handles many users/deposits efficiently.</li> </ul>"},{"location":"older/sections/10RebasingSketch/#edge-cases","title":"Edge Cases","text":"<ul> <li>First rebase: <code>rebase_id = 0</code> initializes correctly.</li> <li>No deposits: Skips activation.</li> <li>Multiple deposits: Accumulate in pending.</li> <li>Transfers: Only activated part moves; pending stays with sender.</li> <li>Zero rate: No effect.</li> </ul> <p>This design ensures efficient rebasing with variable rates, proper handling of non-transferable pending deposits, and clear accounting.</p>"},{"location":"older/sections/1introduction/","title":"1introduction","text":""},{"location":"older/sections/1introduction/#introduction","title":"Introduction","text":"<p>Perpetual Bounded Phenomena (PBP)</p> <p>Perpetual Bounded Phenomena are formed from a perpetual series of discrete events which have bounded outcomes. </p> <p>Examples Include:</p> <ul> <li>Temperatures</li> <li>Poll percentages</li> <li>League points</li> <li>Popularity</li> <li>Market share</li> </ul> <p>In this work, we first formalise PBPs before showing how they can be tokenized through Perpetually Bounded Tokens.</p>"},{"location":"older/sections/2phenomenon/","title":"2phenomenon","text":""},{"location":"older/sections/2phenomenon/#the-phenomena","title":"The Phenomena","text":"<p>A Perpetual Bounded Phenomenon (PBP) arises from a sequence of discrete events with bounded outcomes.</p> <p>Formally, a PBP is a process mapping natural numbers to a bounded interval:</p> \\[ f: \\mathbb{N} \\to [a, b] \\] <p>where</p> \\[ a \\leq f(t) \\leq b \\quad \\text{for all discrete time steps } t \\in \\mathbb{N}. \\] <p>Each step \\( t \\) produces an outcome:</p> \\[ X_t \\in \\{0, 1, \\dots, m\\}. \\] <p>The cumulative value over a window of length \\( n \\) is:</p> \\[ S = \\sum_{k=0}^{n-1} X_{t-k}, \\quad 0 \\leq S \\leq m n. \\] <p>A complementary measure captures the shortfall from the maximum:</p> \\[ \\overline{S} = m n - S. \\] <p>Thus, every PBP yields a pair \\( (S, \\overline{S}) \\), representing achievement versus missed potential.</p>"},{"location":"older/sections/3PBP_examples/","title":"3PBP examples","text":""},{"location":"older/sections/3PBP_examples/#pbp-examples","title":"PBP Examples","text":""},{"location":"older/sections/3PBP_examples/#example-1-reform-uk-voting-intention-in-political-polls","title":"Example 1: Reform UK Voting Intention in Political Polls","text":"<p>This PBP models the percentage of voters intending to vote for Reform UK in weekly political polls. Each poll is a time step \\( t \\), with the outcome being the percentage of respondents supporting Reform UK, reported in increments of 0.1%, so:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 99.8, 99.9, 100\\} \\] <p>with maximum \\( m = 100 \\). The interval is defined by \\( a = 0 \\) (no support) and \\( b = 100 \\) (full support). Since each poll is a single event (\\( n = 1 \\)), the value \\( S \\) is the outcome of the last poll:</p> \\[ S = X_t, \\quad 0 \\leq S \\leq 100. \\] <p>The complementary measure, \\( \\overline{S} = 100 - S \\), represents the percentage of voters not supporting Reform UK. For example, if a poll shows 26.3% support for Reform UK, then:</p> \\[ \\overline{S} = 100 - 26.3 = 73.7 \\] <p>This pair \\( (26.3, 73.7) \\) reflects Reform UK\u2019s voter support versus the portion of voters favoring other parties or none.</p>"},{"location":"older/sections/3PBP_examples/#example-2-liverpools-points-in-the-english-premier-league","title":"Example 2: Liverpool\u2019s Points in the English Premier League","text":"<p>This PBP models the points scored by Liverpool in their last 38 matches in the English Premier League. Each match is a time step \\( t \\), with Liverpool earning points: 0 for a loss, 1 for a draw, or 3 for a win, so the outcome is:</p> \\[ X_t \\in \\{0, 1, 3\\} \\] <p>with maximum \\( m = 3 \\). The interval is defined by \\( a = 0 \\) (loss) and \\( b = 3 \\) (win). Over 38 matches (\\( n = 38 \\)), total points \\( S \\) are:</p> \\[ S = \\sum_{k=0}^{37} X_{t-k}, \\quad 0 \\leq S \\leq 3 \\cdot 38 = 114. \\] <p>The complementary measure, \\( \\overline{S} = 114 - S \\), represents unearned points. For example, if Liverpool scores 80 points, then:</p> \\[ \\overline{S} = 114 - 80 = 34 \\] <p>This pair \\( (80, 34) \\) reflects Liverpool\u2019s points earned versus points missed.</p>"},{"location":"older/sections/3PBP_examples/#example-3-cooling-degree-days-in-new-york","title":"Example 3: Cooling Degree Days in New York","text":""},{"location":"older/sections/3PBP_examples/#cooling-degree-days-cdd-definition","title":"Cooling Degree Days (CDD) Definition","text":"<p>Cooling Degree Days (CDD) measure the demand for cooling based on how much warmer the average daily temperature is compared to a baseline of 18\u00b0C. For a given day, CDD is calculated as the difference between the average daily temperature and 18\u00b0C, or zero if the temperature is 18\u00b0C or cooler. This quantifies the energy needed for air conditioning in warmer climates.</p> <p>This PBP models the total Cooling Degree Days (CDD) in New York over a rolling 30-day period. Each day is a time step \\( t \\), with the outcome being the CDD, calculated as \\( X_t = \\max(0, T_t - 18) \\), where \\( T_t \\) is the average daily temperature in \u00b0C, capped at 30 CDD per day to reflect realistic temperatures. Thus:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 29.8, 29.9, 30\\} \\] <p>with maximum \\( m = 30 \\). The interval is defined by \\( a = 0 \\) (no cooling needed) and \\( b = 30 \\) (maximum daily CDD). Over a 30-day window (\\( n = 30 \\)), total CDD \\( S \\) is:</p> \\[ S = \\sum_{k=0}^{29} X_{t-k}, \\quad 0 \\leq S \\leq 30 \\cdot 30 = 900. \\] <p>The complementary measure, \\( \\overline{S} = 900 - S \\), represents the shortfall from the maximum possible CDD. For example, if the total CDD over 30 days is 150, then:</p> \\[ \\overline{S} = 900 - 150 = 750 \\] <p>This pair \\( (150, 750) \\) reflects the cooling demand versus the unused cooling capacity over the period.</p>"},{"location":"older/sections/3PBP_examples/#note-on-cyclic-pbps","title":"Note on Cyclic PBPs","text":"<p>Some PBPs feature significant gaps between cycles of events, during which no new outcomes occur, but the values of \\( S \\) and \\( \\overline{S} \\) remain defined and fixed. For example, in the Liverpool Premier League case (Example 2), points are accumulated during the season\u2019s matches, but between seasons, no matches occur, and the values of \\( S \\) and \\( \\overline{S} \\) persist until the next season begins. Similarly, a PBP can track metrics over a specific period each year, such as Cooling Degree Days for August, with values updating during the period and remaining constant until the next cycle, as shown in Example 4.</p>"},{"location":"older/sections/3PBP_examples/#example-4-cooling-degree-days-in-new-york-for-august","title":"Example 4: Cooling Degree Days in New York for August","text":"<p>This PBP models the total Cooling Degree Days (CDD) in New York for the month of August, a fixed 31-day period each year. Each day in August is a time step \\( t \\), with the outcome being the CDD, calculated as \\( X_t = \\max(0, T_t - 18) \\), where \\( T_t \\) is the average daily temperature in \u00b0C, capped at 30 CDD per day. Thus:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 29.8, 29.9, 30\\} \\] <p>with maximum \\( m = 30 \\). The interval is defined by \\( a = 0 \\) (no cooling needed) and \\( b = 30 \\) (maximum daily CDD). Over the 31 days of August (\\( n = 31 \\)), total CDD \\( S \\) is:</p> \\[ S = \\sum_{k=0}^{30} X_{t-k}, \\quad 0 \\leq S \\leq 30 \\cdot 31 = 930. \\] <p>The complementary measure, \\( \\overline{S} = 930 - S \\), represents the shortfall from the maximum possible CDD. For example, if the total CDD for August is 200, then:</p> \\[ \\overline{S} = 930 - 200 = 730 \\] <p>This pair \\( (200, 730) \\) reflects the cooling demand for August versus the unused cooling capacity. After August, \\( S \\) and \\( \\overline{S} \\) remain fixed until the next August, illustrating a PBP with a yearly cycle and gaps between event periods.</p>"},{"location":"older/sections/4why_tokenize/","title":"4why tokenize","text":""},{"location":"older/sections/4why_tokenize/#tokenizing-principals","title":"Tokenizing Principals","text":""},{"location":"older/sections/4why_tokenize/#tokens-t-and-overlinet","title":"Tokens \\( T \\) and \\( \\overline{T} \\)","text":"graph TD     S[\"S\"] -.-&gt;|peg mechanism| T((T))     Sbar[\"S\u0305\"] -.-&gt;|peg mechanism| Tbar((T\u0305))     style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff     style S fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff     style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff     style Sbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff"},{"location":"older/sections/4why_tokenize/#constant-price-formula","title":"Constant Price Formula","text":"<p>To preserve the complementary dynamics inherent in \\( S \\) and \\( \\overline{S} \\), we fix the prices of our tokens to a constant.</p> \\[ P_T + P_{\\overline{T}} = 1 \\]"},{"location":"older/sections/4why_tokenize/#price-units","title":"Price Units","text":"<p>The constant price formula can be tied to any asset as needed. We envision this system primarily being priced in stablecoins, such as USDT or USDC. In this paper, we use USDC as shorthand for the pricing asset of choice.</p>"},{"location":"older/sections/4why_tokenize/#enforcement-of-constant-price-formula","title":"Enforcement of Constant Price Formula","text":"<p>The constant price relationship is enforced by allowing 1 \\( T \\) and 1 \\( \\overline{T} \\) to be minted or burned at any time for 1 USDC.</p> graph TD         USDC((USDC)) --&gt; T((T))         USDC((USDC)) --&gt; Tbar((T\u0305))         style USDC fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff         style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff         style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff  graph TD         T((T)) --&gt; USDC((USDC))         Tbar((T\u0305)) --&gt; USDC((USDC))         style USDC fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff         style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff         style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff"},{"location":"older/sections/5peg_mechanism/","title":"5peg mechanism","text":""},{"location":"older/sections/5peg_mechanism/#peg-mechanism-linking-tokens-to-performance","title":"Peg Mechanism: Linking Tokens to Performance","text":"<p>The peg mechanism ties the value of token \\(T\\) to the expected future performance of an underlying phenomenon \\(S\\). Below are the key variables:</p> <ul> <li>\\(r\\): Daily USDC yield</li> <li>\\(YT\\): Yield for token \\(T\\)</li> <li>\\(Y\\overline{T}\\): Yield for token \\(\\overline{T}\\)</li> </ul> <p>Each \\(T\\) and \\(\\overline{T}\\) pair is minted with USDC. USDC is deposited into an interest-bearing protocol generating a daily yield \\(r\\). This yield is split between \\(YT\\) and \\(Y\\overline{T}\\) based on \\(S\\), as evaluated by a fixed market rubric, such that:</p> \\[ YT + Y\\overline{T} = r \\] flowchart LR     S --&gt; Rubric     Rubric --&gt; Tyield[\"YT\"]     Rubric --&gt; Tbaryield[\"YT bar\"]     USDC --&gt; yield[\"r\"]     yield --&gt; Rubric"},{"location":"older/sections/5peg_mechanism/#rubrics","title":"Rubrics","text":"<p>Definitions:</p> <ul> <li>\\(\\rho_T\\): Ratio of \\(r\\) received by \\(T\\).</li> <li>\\(\\rho_{\\bar{T}}\\): Ratio of \\(r\\) received by \\(\\bar{T}\\).</li> </ul> <p>Thus:</p> <ul> <li>\\(Y_T = r \\cdot \\rho_T\\)</li> <li>\\(Y_{\\bar{T}} = r \\cdot \\rho_{\\bar{T}}\\)</li> </ul> <p>The constraint for the function is:</p> <ul> <li>Ratios must sum to 1:</li> <li>\\(\\rho_T(S) + \\rho_{\\bar{T}}(S) = 1\\)</li> </ul>"},{"location":"older/sections/5peg_mechanism/#what-does-price-mean","title":"What Does Price Mean?","text":"<ul> <li>\\(P(T)\\): Present value of token \\(T\\)\u2019s future yields (\\(YT\\)).</li> <li>\\(P(\\overline{T})\\): Present value of token \\(\\overline{T}\\)\u2019s yields (\\(Y\\overline{T}\\)).</li> </ul> <p>i.e.:</p> \\[ P(T) = \\sum_{t=1}^{\\infty} \\frac{YT_t}{(1 + r_t)^t} \\] \\[ P(\\overline{T}) = \\sum_{t=1}^{\\infty} \\frac{Y\\overline{T}_t}{(1 + r_t)^t} \\] <p>Linear Rubric:</p> <p>There are infinitely many pairs of \\(\\rho_T\\) and \\(\\rho_{\\bar{T}}\\) functions that satisfy the rubric conditions. We anticipate the most widely used will be the linear mapping:</p> <ul> <li>\\(\\rho_T(S) = \\frac{S}{S_{max}}\\)</li> <li>\\(\\rho_{\\bar{T}}(S) = 1 - \\frac{S}{S_{max}}\\)</li> </ul>"},{"location":"older/sections/5peg_mechanism/#price-under-the-linear-rubric","title":"Price under the linear Rubric","text":"<p>The price of token \\( T \\), denoted \\( P(T) \\), is derived by substituting the yield relation \\( YT_t = \\frac{S_t}{S_{\\max}} \\cdot r_t \\) into the price formula:</p> \\[ P(T) = \\sum_{t=1}^{\\infty} \\frac{\\frac{S_t}{S_{\\max}} \\cdot r_t}{(1 + r_t)^t} = \\frac{1}{S_{\\max}} \\cdot \\sum_{t=1}^{\\infty} \\frac{S_t \\cdot r_t}{(1 + r_t)^t} \\]"},{"location":"older/sections/5peg_mechanism/#yield-distribution","title":"Yield Distribution","text":"<p>The peg is maintained through daily yield distributions from the USDC yield \\(r\\), as described earlier. The yields are allocated to \\(T\\) and \\(\\overline{T}\\) holders based on the performance of \\(S\\) relative to the maximum possible performance \\(S_{max}\\), using the linear mapping defined in the rubric:</p> \\[ Y_T = r \\cdot \\frac{S}{S_{max}}, \\quad Y_{\\overline{T}} = r \\cdot \\frac{S_{max} - S}{S_{max}} \\] <p>This ensures the total daily yield is fully distributed:</p> \\[ Y_T + Y_{\\overline{T}} = r \\] <p>The better \\(S\\) performs, the larger the share of the daily yield \\(T\\) holders receive, and vice versa for \\(\\overline{T}\\).</p>"},{"location":"older/sections/6applications/","title":"6applications","text":""},{"location":"older/sections/6applications/#applications","title":"Applications","text":""},{"location":"older/sections/6applications/#1-reform-uk-voting-intention-in-weekly-poll","title":"1. Reform UK Voting Intention in Weekly Poll","text":"<p>Weekly poll using one of the main pollsters. Used for political forecasting and hedging.</p> <p>Events: </p> <ul> <li>Weekly poll percentage for Reform UK, in 0.1% increments \\(X_t \\in \\{0, 0.1, \\dots, 100\\}, m = 100\\).</li> </ul> <p>Value:</p> <ul> <li>\\(S_t = X_t\\) (0\u2013100).</li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 100 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{100}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{100}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between polls</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on the performance of Reform UK</li> </ul> <p>Peformance Outline: </p> <ul> <li>If YouGov reports 26.3% support (\\(S_t = 26.3\\))</li> <li>then \\(\\overline{S}_t = 73.7\\)</li> <li>\\(\\rho_T = 0.263\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.737\\). </li> <li>\\(T\\) holders (bullish on Reform UK) get ~26.3% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~73.7%.</li> </ul> <p>Application</p> <ul> <li>Analysts hedge campaign risks</li> <li>Users speculate on performance</li> <li>Each new poll updates ratios.</li> </ul>"},{"location":"older/sections/6applications/#2-liverpools-points-in-the-premier-league","title":"2. Liverpool\u2019s Points in the Premier League","text":"<p>Tracks Liverpool\u2019s points over a rolling 38 matches period.</p> <p>Events: </p> <ul> <li>Match points, in increments of 0, 1, or 3 for loss, draw, or win (\\(X_t \\in \\{0, 1, 3\\}, m = 3\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{37} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 114\\) </li> <li>\\(n = 38\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 114 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{114}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{114}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between matches</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on Liverpool\u2019s performance</li> </ul> <p>Peformance Outline: </p> <ul> <li>If Liverpool has scored 80 points in the last rolling 38 games (\\(S_t = 80\\))</li> <li>then \\(\\overline{S}_t = 114 - 80 = 34\\)</li> <li>\\(\\rho_T \\approx 0.702\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.298\\). </li> <li>\\(T\\) holders (bullish on Liverpool) get ~70.2% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~29.8%.</li> </ul> <p>Application</p> <ul> <li>Fans speculate on team performance</li> <li>Institutions hedge exposure</li> <li>Each new match updates ratios.</li> </ul>"},{"location":"older/sections/6applications/#3-cooling-degree-days-in-new-york-rolling-30-days","title":"3. Cooling Degree Days in New York (Rolling 30 Days)","text":"<p>Tracks cooling demand over a rolling 30-day period using NOAA data for energy cost hedging.</p> <p>Events: </p> <ul> <li>Daily CDD, \\(X_t = \\max(0, T_t - 18)\\), in \u00b0C, capped at 30 (\\(X_t \\in \\{0, 0.1, \\dots, 30\\}, m = 30\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{29} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 900\\) </li> <li>\\(n = 30\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 900 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{900}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{900}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) update daily with new temperature data</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on cooling demand</li> </ul> <p>Peformance Outline: </p> <ul> <li>If NOAA reports 150 CDD over 30 days (\\(S_t = 150\\))</li> <li>then \\(\\overline{S}_t = 900 - 150 = 750\\)</li> <li>\\(\\rho_T \\approx 0.167\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.833\\). </li> <li>\\(T\\) holders (bullish on high cooling demand) get ~16.7% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~83.3%.</li> </ul> <p>Application</p> <ul> <li>Energy firms hedge heatwave costs</li> <li>Speculators trade on weather forecasts</li> <li>Each new daily temperature updates ratios.</li> </ul>"},{"location":"older/sections/6applications/#4-cooling-degree-days-in-new-york-for-august","title":"4. Cooling Degree Days in New York for August","text":"<p>Tracks cooling demand for August using NOAA data for seasonal hedging.</p> <p>Events: </p> <ul> <li>Daily CDD, \\(X_t = \\max(0, T_t - 18)\\), in \u00b0C, capped at 30 (\\(X_t \\in \\{0, 0.1, \\dots, 30\\}, m = 30\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{30} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 930\\) </li> <li>\\(n = 31\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 930 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{930}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{930}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) adjust daily in August, fixed otherwise</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on August cooling demand</li> </ul> <p>Peformance Outline: </p> <ul> <li>If NOAA reports 200 CDD for August (\\(S_t = 200\\))</li> <li>then \\(\\overline{S}_t = 930 - 200 = 730\\)</li> <li>\\(\\rho_T \\approx 0.215\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.785\\). </li> <li>\\(T\\) holders (bullish on high cooling demand) get ~21.5% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~78.5%.</li> </ul> <p>Application</p> <ul> <li>Energy retailers hedge summer demand</li> <li>Speculators take positions on August weather</li> <li>Each new daily temperature in August updates ratios.</li> </ul>"},{"location":"older/sections/6applications/#5-inflation-rate","title":"5. Inflation Rate","text":"<p>Tracks quarterly inflation rates using U.S. Bureau of Labor Statistics CPI data for economic hedging.</p> <p>Events: </p> <ul> <li>Quarterly inflation rate, in 0.1% increments (\\(X_t \\in \\{0, 0.1, \\dots, 10\\}, m = 10\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = X_t\\) </li> <li>\\(0 \\leq S_t \\leq 10\\)</li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 10 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{10}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{10}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between quarterly reports</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on inflation trends</li> </ul> <p>Peformance Outline: </p> <ul> <li>If CPI reports 3.2% inflation (\\(S_t = 3.2\\))</li> <li>then \\(\\overline{S}_t = 10 - 3.2 = 6.8\\)</li> <li>\\(\\rho_T = 0.32\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.68\\). </li> <li>\\(T\\) holders (bullish on rising inflation) get ~32% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~68%.</li> </ul> <p>Application</p> <ul> <li>Investors hedge inflation costs</li> <li>Speculators take positions on economic stability</li> <li>Each new quarterly report updates ratios.</li> </ul>"},{"location":"older/sections/6applications/#6-self-referencing-popularity-index-for-taylor-swift","title":"6. Self-Referencing Popularity Index for Taylor Swift","text":"<p>Tracks public opinion on Taylor Swift's anticipated future popularity through a self-referencing asset, useful for sentiment analysis and cultural hedging.</p> <p>Events: </p> <ul> <li>No external events; self-referencing based on market price of \\(T\\)</li> <li>\\(X_t \\in \\{0, 0.01, \\dots, 1\\}, m = 100\\).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = P(T)\\) </li> <li>\\(0 \\leq S_t \\leq 1\\) </li> <li>\\(n = 1\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 100 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = {S_t} = P(T)\\)</li> <li>\\(\\rho_{\\overline{T}} = {\\overline{S}_t} = 1 - P(T)\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) update dynamically with changes in \\(P(T)\\), creating a feedback loop</li> </ul> <p>Price Meaning:</p> <ul> <li>\\(P(T)\\) reflects a discounted anticipation of Taylor Swift\u2019s future popularity</li> </ul> <p>Peformance Outline: </p> <ul> <li>If the current market price \\(P(T) = 0.85\\) (\\(S_t = 0.85\\))</li> <li>then \\(\\overline{S}_t = 1 - 0.85 = 0.15\\)</li> <li>\\(\\rho_T = 0.85\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.15\\). </li> <li>\\(T\\) holders (bullish on Taylor Swift\u2019s future popularity) get ~85% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~15%.</li> </ul> <p>Application</p> <ul> <li>Fans and media speculate on future cultural relevance</li> <li>Brands hedge endorsement risks</li> <li>Market dynamics drive updates through trading activity.</li> </ul>"},{"location":"older/sections/8new_ideas/","title":"New Ideas for Tokenizing Perpetual Bounded Phenomena","text":""},{"location":"older/sections/8new_ideas/#1-simplifying-with-annual-binary-outcomes","title":"1. Simplifying with Annual Binary Outcomes","text":"<p>To make development easier and the system more understandable, shift from continuous or frequent updates to annual binary outcomes. Instead of tracking rolling windows or frequent events, focus on yearly yes/no results for specific milestones.</p>"},{"location":"older/sections/8new_ideas/#key-changes","title":"Key Changes:","text":"<ul> <li>Binary Nature: Outcomes are binary (e.g., achieved or not achieved) and evaluated annually.</li> <li>Examples in Football:</li> <li>Liverpool wins the Premier League.</li> <li>Liverpool qualifies for Champions League.</li> <li>Liverpool qualifies for Europe (Champions or Europa League).</li> <li>Liverpool remains in the Premier League.</li> <li>Dividend Payouts: Dividends are paid based on the current status of the outcome. If the binary condition is met (e.g., team achieves the milestone), token holders receive yields; otherwise, no yields until the next evaluation.</li> <li>Long-Term Holding Incentive: Users can buy tokens for unlikely or long-shot outcomes (e.g., a lower-division team like Northampton Town reaching the Premier League). These tokens may yield nothing for years but could generate significant annual dividends (e.g., turning a $100 investment into $500/year in yields) once the outcome is achieved.</li> </ul>"},{"location":"older/sections/8new_ideas/#benefits","title":"Benefits:","text":"<ul> <li>Fewer oracle events (annual updates only).</li> <li>Simpler to implement and explain, reducing complexity compared to perpetual or rolling PBPs.</li> </ul> <p>This approach maintains the perpetual aspect but ties yields to discrete, annual checkpoints, making it more accessible for users and developers.</p>"},{"location":"older/sections/8new_ideas/#2-claimable-rewards","title":"2. Claimable Rewards","text":"<p>Native yield issuance without claiming poses challenges, especially with multiple tokens yielding in the same stablecoin (e.g., USDC). To address this, introduce claimable rewards to simplify yield distribution.</p>"},{"location":"older/sections/8new_ideas/#key-points","title":"Key Points:","text":"<ul> <li>Claimable Yields: Yields are not automatically distributed but must be claimed by token holders. This avoids building complex systems for handling yields across many tokens in the same asset.</li> <li>Implementation: Yields are accumulated in USDC (or a yield-bearing version like ppUSDC) and can be claimed by holders of T or \\(\\overline{T}\\) based on the performance rubric.</li> </ul>"},{"location":"older/sections/8new_ideas/#benefits_1","title":"Benefits:","text":"<ul> <li>Simplifies yield management for users and reduces system complexity.</li> <li>Ensures scalability when managing multiple token pairs.</li> </ul>"},{"location":"older/sections/8new_ideas/#3-rebasing-tokens-as-an-additional-development","title":"3. Rebasing Tokens as an Additional Development","text":"<p>As an additional feature to support users who prefer automated yield handling, introduce rebasing tokens for auto-compounding yields on top of the base system.</p>"},{"location":"older/sections/8new_ideas/#key-points_1","title":"Key Points:","text":"<ul> <li>Rebasing Tokens:</li> <li>Users deposit base tokens (T or \\(\\overline{T}\\)) into a rebasing contract to receive rebasing versions (e.g., aT for auto-compounding T).</li> <li>The contract holds the base tokens and accumulates claimable interest (in USDC or ppUSDC).</li> <li>Deposits and withdrawals of T or \\(\\overline{T}\\) trigger a swap on Uniswap to convert accumulated interest (USDC or \\(\\overline{T}\\)) into the deposited token type (e.g., depositing T triggers swapping \\(\\overline{T}\\) or USDC to T). This ensures the contract maintains a balanced pool for aT holders while leveraging Uniswap\u2019s market pricing.</li> <li>Deposit and Withdrawal Handling:<ul> <li>Deposits: Users deposit T or \\(\\overline{T}\\), and the contract mints aT based on a share price (<code>total_underlying / total_aT_supply</code>). The share price accounts for held T, \\(\\overline{T}\\) (valued at Uniswap\u2019s current price), and USDC (valued as mintable T + \\(\\overline{T}\\) sold on Uniswap). Deposits trigger a Uniswap swap to convert any \\(\\overline{T}\\) or USDC to T (or vice versa for \\(\\overline{T}\\) deposits), maintaining pool balance.</li> <li>Withdrawals: Redeeming aT returns T or \\(\\overline{T}\\) based on the share price. If insufficient T is available, the contract swaps \\(\\overline{T}\\) or USDC to T on Uniswap to fulfill the withdrawal.</li> <li>This prevents overpayment for new depositors by ensuring they receive a fair share of the contract\u2019s current value, adjusted for Uniswap\u2019s market rates.</li> </ul> </li> <li>The contract periodically claims USDC yields, splits them into T and \\(\\overline{T}\\), and uses Uniswap swaps to align holdings with deposited token types.</li> </ul>"},{"location":"older/sections/8new_ideas/#benefits_2","title":"Benefits:","text":"<ul> <li>Enables auto-compounding via rebasing for hands-off users, simplifying the user experience.</li> <li>Simplifies valuation by relying on Uniswap\u2019s market pricing, avoiding complex internal pricing algorithms.</li> </ul>"},{"location":"older/sections/8new_ideas/#4-internal-liquidity-as-a-positive-externality","title":"4. Internal Liquidity as a Positive Externality","text":"<p>The rebasing contract, by facilitating the conversion of T to \\(\\overline{T}\\) (or vice versa) via Uniswap swaps, also serves as a liquidity provider, creating a positive externality for the system.</p>"},{"location":"older/sections/8new_ideas/#key-points_2","title":"Key Points:","text":"<ul> <li>Liquidity Provision:</li> <li>The rebasing contract supports swaps between T and \\(\\overline{T}\\) by leveraging Uniswap for conversions, triggered by deposits or withdrawals. For example, depositing T may require swapping \\(\\overline{T}\\) or USDC to T on Uniswap to maintain pool balance.</li> <li>General Principle: When a swap is needed, the contract uses Uniswap\u2019s current market price (potentially with a TWAP for stability) to execute trades. This ensures liquidity for users while aligning the contract\u2019s holdings with user deposits.</li> <li>This creates a balanced, automated market within the contract, improving the liquidity of the system.</li> <li>Positive Externality: The need to manage complementary tokens (T and \\(\\overline{T}\\)) inherently provides liquidity to the system by facilitating Uniswap-based trades, enhancing market depth and accessibility.</li> </ul>"},{"location":"older/sections/8new_ideas/#benefits_3","title":"Benefits:","text":"<ul> <li>Enhances liquidity through Uniswap integration, leveraging external market efficiency.</li> <li>Creates a self-sustaining system where token conversion supports overall market efficiency.</li> </ul>"},{"location":"older/sections/8new_ideas/#handling-deposits-and-withdrawals-with-uniswap-integration","title":"Handling Deposits and Withdrawals with Uniswap Integration","text":"<p>To address the concern about overpayment when depositing into the rebasing contract (e.g., if significant interest has accumulated), the system uses a share-based model with Uniswap swaps to ensure fairness:</p> <ul> <li>Deposit Process:</li> <li>On T deposit, the contract claims accumulated USDC yields and swaps for T and \\(\\overline{T}\\).</li> <li>The contract swaps \\(\\overline{T}\\) to T on Uniswap.</li> <li>This updates user balances of aT</li> <li> <p>Mint aT = deposited T</p> </li> <li> <p>Withdrawal Process:</p> </li> <li>Claim accumulated ppUSDC</li> <li>Update balances of aT</li> <li>Burn aT being withdrawn</li> <li> <p>transfer amount of T equalt to aT being withdrawn to the user.</p> </li> <li> <p>Benefits of Uniswap Integration:</p> </li> <li>Fairness: Using Uniswap\u2019s market price (or TWAP) ensures new depositors don\u2019t receive disproportionate value from accumulated interest, preventing overpayment.</li> <li>Simplicity: Eliminates the need for a complex internal pricing algorithm, relying on Uniswap\u2019s established liquidity and pricing</li> <li>Liquidity Boost: Swaps triggered by deposits/withdrawals add trading volume to Uniswap pools, enhancing overall system liquidity.</li> <li>Trade-Off: Uniswap prices may not always be optimal (e.g., slippage or market volatility), but TWAP usage and sufficient pool depth can mitigate this. It\u2019s a practical trade-off for simplicity and reliability.</li> </ul> <p>This approach streamlines the rebasing contract by leveraging Uniswap for pricing and liquidity, ensuring fair deposits/withdrawals while maintaining the system\u2019s core mechanics.</p>"},{"location":"older/sections/9new_ideas2/","title":"Token Rebasing System Specification","text":"<p>This document outlines the design for a token rebasing system integrated with binary event resolution using UMA bonds and Uniswap V2 pools. The system simplifies event settlement and incentivizes frequent rebalancing through a dual-token mechanism with <code>T</code>, <code>T-bar</code>, <code>aT</code>, and <code>aT-bar</code> tokens, managed by a controller contract.</p>"},{"location":"older/sections/9new_ideas2/#binary-event-resolution","title":"Binary Event Resolution","text":""},{"location":"older/sections/9new_ideas2/#overview","title":"Overview","text":"<p>The system reduces complex phenomena to binary events with long-term outcomes, settled via UMA bonds for simplified implementation.</p>"},{"location":"older/sections/9new_ideas2/#key-points","title":"Key Points","text":"<ol> <li>Event Structure:</li> <li>Binary events are defined with clear, verifiable outcomes.</li> <li>Example: \"The most recent football season ended with the last match day on May 11th, 2025.\"</li> <li>Derived statement: \"Liverpool won the Premier League Football season that ended on May 11th, 2025.\"</li> <li>UMA Integration:</li> <li>Binary events are pushed to UMA for resolution, leveraging UMA bonds to ensure reliable settlement.</li> </ol>"},{"location":"older/sections/9new_ideas2/#rebasing-token-mechanism","title":"Rebasing Token Mechanism","text":""},{"location":"older/sections/9new_ideas2/#core-concepts","title":"Core Concepts","text":"<p>The rebasing system uses two primary tokens, <code>T</code> and <code>T-bar</code>, with their respective rebasing tokens <code>aT</code> and <code>aT-bar</code>. USDC serves as the reward and exchange currency, with Uniswap V2 pools facilitating liquidity and rebalancing. A controller contract manages the minting and distribution of tokens during rebalancing.</p>"},{"location":"older/sections/9new_ideas2/#token-mechanics","title":"Token Mechanics","text":"<ol> <li>Rewards:</li> <li>Rewards are claimable in USDC for holders of token <code>T</code> and <code>T-bar</code>.</li> <li>Uniswap V2 pools exist for:<ul> <li>USDC/<code>T</code></li> <li>USDC/<code>T-bar</code></li> </ul> </li> <li>Exchange rates:<ul> <li>1 USDC is exchangeable for 1 <code>T</code> or 1 <code>T-bar</code>.</li> <li>Burning 1 <code>T</code> and 1 <code>T-bar</code> yields 1 USDC.</li> </ul> </li> <li>Deposits and Withdrawals:</li> <li>Deposit <code>T</code> to receive <code>aT</code> at a 1:1 ratio.</li> <li>Deposit <code>T-bar</code> to receive <code>aT-bar</code> at a 1:1 ratio.</li> <li>Burn <code>aT</code> to receive <code>T</code> at a 1:1 ratio.</li> <li>Burn <code>aT-bar</code> to receive <code>T-bar</code> at a 1:1 ratio.</li> </ol>"},{"location":"older/sections/9new_ideas2/#rebalance-process","title":"Rebalance Process","text":"<p>The <code>Rebalance()</code> function manages the rebasing process between the <code>aT</code> and <code>aT-bar</code> contracts, utilizing Uniswap V2 TWAP and the <code>T/T-bar</code> controller contract. The function can be called by anyone, with incentives to increase call frequency as locked value grows.</p> <ol> <li>USDC Claim and Transfer:</li> <li>The <code>aT</code> contract claims USDC and transfers it to the controller.</li> <li>The <code>aT-bar</code> contract claims USDC and transfers it to the controller.</li> <li>TWAP Calculation:</li> <li>The <code>aT</code> contract uses TWAP since the last rebalance to calculate the amount of <code>T</code> it should receive for its USDC (denoted as value <code>b</code>).</li> <li>The <code>aT-bar</code> contract uses TWAP since the last rebalance to calculate the amount of <code>T-bar</code> it should receive for its USDC (denoted as value <code>c</code>).</li> <li>Minting and Rebasing:</li> <li>The controller mints <code>min(b, c)</code> pairs of <code>T</code> and <code>T-bar</code> using the USDC it holds, depositing claimed USDC into the <code>T/T-bar</code> controller contract.</li> <li>Minted <code>T</code> is sent to the <code>aT</code> contract, and minted <code>T-bar</code> is sent to the <code>aT-bar</code> contract.</li> <li>After minting, either the <code>aT</code> or <code>aT-bar</code> contract retains residual USDC, as only the minimum of <code>b</code> and <code>c</code> is minted.</li> <li>Rebalancing with TWAP Threshold:</li> <li>The contract rebases against Uniswap V2 using TWAP, triggered when the TWAP deviates by a predefined threshold.</li> <li>If the TWAP threshold is not met, the contract records a new TWAP checkpoint for the next rebalance and performs a partial rebase without executing a Uniswap swap.</li> <li>Incentives for Rebase Calls:</li> <li>The <code>Rebalance()</code> function is permissionless, allowing anyone to call it and earn a reward. The reward is a percentage of the total USDC claimed by <code>aT</code> and <code>aT-bar</code> contracts during the rebalance. A 1% reward is likely sufficient to incentivize frequent calls. Initially, the dev team will deploy a bot to call <code>Rebalance()</code> regularly, ensuring consistent operation. As the total locked value in the system increases, the USDC reward will incentivize additional external users to trigger the function more frequently, resulting in smoother and more continuous rebasing.</li> <li>Deposit Pending Period:</li> <li>When a user deposits <code>T</code> to receive <code>aT</code> (or <code>T-bar</code> to receive <code>aT-bar</code>), the deposit is non-transferable during the period before the next rebalance, referred to as the \"Pending Period.\" However, the deposit can be withdrawn during this period.</li> <li>Rebasing for that specific user deposit does not begin until the respective contract (<code>aT</code> or <code>aT-bar</code>) is fully rebased (i.e., no claimable USDC remains). This means the user may miss the first rebase period (or part thereof) for their deposit.</li> </ol>"},{"location":"older/sections/9new_ideas2/#additional-notes","title":"Additional Notes","text":"<ul> <li>A full specification for the deposit rebase delay and Pending Period is available separately.</li> <li>The system ensures continuous rebalancing to maintain stability, with incentives designed to encourage frequent user-driven rebase calls, especially as the locked value grows.</li> </ul>"}]}