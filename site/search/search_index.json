{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"BoundedPhenomena/","title":"Tokenizing Perpetual Bounded Phenomena","text":""},{"location":"BoundedPhenomena/#introduction","title":"Introduction","text":"<p>Perpetual Bounded Phenomena (PBP)</p> <p>Perpetual Bounded Phenomena are formed from a perpetual series of discrete events which have bounded outcomes. </p> <p>Examples Include:</p> <ul> <li>Temperatures</li> <li>Poll percentages</li> <li>League points</li> <li>Popularity</li> <li>Market share</li> </ul> <p>In this work, we first formalise PBPs before showing how they can be tokenized through Perpetually Bounded Tokens.</p>"},{"location":"BoundedPhenomena/#the-phenomena","title":"The Phenomena","text":"<p>A Perpetual Bounded Phenomenon (PBP) arises from a sequence of discrete events with bounded outcomes.</p> <p>Formally, a PBP is a process mapping natural numbers to a bounded interval:</p> \\[ f: \\mathbb{N} \\to [a, b] \\] <p>where</p> \\[ a \\leq f(t) \\leq b \\quad \\text{for all discrete time steps } t \\in \\mathbb{N}. \\] <p>Each step \\( t \\) produces an outcome:</p> \\[ X_t \\in \\{0, 1, \\dots, m\\}. \\] <p>The cumulative value over a window of length \\( n \\) is:</p> \\[ S = \\sum_{k=0}^{n-1} X_{t-k}, \\quad 0 \\leq S \\leq m n. \\] <p>A complementary measure captures the shortfall from the maximum:</p> \\[ \\overline{S} = m n - S. \\] <p>Thus, every PBP yields a pair \\( (S, \\overline{S}) \\), representing achievement versus missed potential.</p>"},{"location":"BoundedPhenomena/#pbp-examples","title":"PBP Examples","text":""},{"location":"BoundedPhenomena/#example-1-reform-uk-voting-intention-in-political-polls","title":"Example 1: Reform UK Voting Intention in Political Polls","text":"<p>This PBP models the percentage of voters intending to vote for Reform UK in weekly political polls. Each poll is a time step \\( t \\), with the outcome being the percentage of respondents supporting Reform UK, reported in increments of 0.1%, so:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 99.8, 99.9, 100\\} \\] <p>with maximum \\( m = 100 \\). The interval is defined by \\( a = 0 \\) (no support) and \\( b = 100 \\) (full support). Since each poll is a single event (\\( n = 1 \\)), the value \\( S \\) is the outcome of the last poll:</p> \\[ S = X_t, \\quad 0 \\leq S \\leq 100. \\] <p>The complementary measure, \\( \\overline{S} = 100 - S \\), represents the percentage of voters not supporting Reform UK. For example, if a poll shows 26.3% support for Reform UK, then:</p> \\[ \\overline{S} = 100 - 26.3 = 73.7 \\] <p>This pair \\( (26.3, 73.7) \\) reflects Reform UK\u2019s voter support versus the portion of voters favoring other parties or none.</p>"},{"location":"BoundedPhenomena/#example-2-liverpools-points-in-the-english-premier-league","title":"Example 2: Liverpool\u2019s Points in the English Premier League","text":"<p>This PBP models the points scored by Liverpool in their last 38 matches in the English Premier League. Each match is a time step \\( t \\), with Liverpool earning points: 0 for a loss, 1 for a draw, or 3 for a win, so the outcome is:</p> \\[ X_t \\in \\{0, 1, 3\\} \\] <p>with maximum \\( m = 3 \\). The interval is defined by \\( a = 0 \\) (loss) and \\( b = 3 \\) (win). Over 38 matches (\\( n = 38 \\)), total points \\( S \\) are:</p> \\[ S = \\sum_{k=0}^{37} X_{t-k}, \\quad 0 \\leq S \\leq 3 \\cdot 38 = 114. \\] <p>The complementary measure, \\( \\overline{S} = 114 - S \\), represents unearned points. For example, if Liverpool scores 80 points, then:</p> \\[ \\overline{S} = 114 - 80 = 34 \\] <p>This pair \\( (80, 34) \\) reflects Liverpool\u2019s points earned versus points missed.</p>"},{"location":"BoundedPhenomena/#example-3-cooling-degree-days-in-new-york","title":"Example 3: Cooling Degree Days in New York","text":""},{"location":"BoundedPhenomena/#cooling-degree-days-cdd-definition","title":"Cooling Degree Days (CDD) Definition","text":"<p>Cooling Degree Days (CDD) measure the demand for cooling based on how much warmer the average daily temperature is compared to a baseline of 18\u00b0C. For a given day, CDD is calculated as the difference between the average daily temperature and 18\u00b0C, or zero if the temperature is 18\u00b0C or cooler. This quantifies the energy needed for air conditioning in warmer climates.</p> <p>This PBP models the total Cooling Degree Days (CDD) in New York over a rolling 30-day period. Each day is a time step \\( t \\), with the outcome being the CDD, calculated as \\( X_t = \\max(0, T_t - 18) \\), where \\( T_t \\) is the average daily temperature in \u00b0C, capped at 30 CDD per day to reflect realistic temperatures. Thus:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 29.8, 29.9, 30\\} \\] <p>with maximum \\( m = 30 \\). The interval is defined by \\( a = 0 \\) (no cooling needed) and \\( b = 30 \\) (maximum daily CDD). Over a 30-day window (\\( n = 30 \\)), total CDD \\( S \\) is:</p> \\[ S = \\sum_{k=0}^{29} X_{t-k}, \\quad 0 \\leq S \\leq 30 \\cdot 30 = 900. \\] <p>The complementary measure, \\( \\overline{S} = 900 - S \\), represents the shortfall from the maximum possible CDD. For example, if the total CDD over 30 days is 150, then:</p> \\[ \\overline{S} = 900 - 150 = 750 \\] <p>This pair \\( (150, 750) \\) reflects the cooling demand versus the unused cooling capacity over the period.</p>"},{"location":"BoundedPhenomena/#note-on-cyclic-pbps","title":"Note on Cyclic PBPs","text":"<p>Some PBPs feature significant gaps between cycles of events, during which no new outcomes occur, but the values of \\( S \\) and \\( \\overline{S} \\) remain defined and fixed. For example, in the Liverpool Premier League case (Example 2), points are accumulated during the season\u2019s matches, but between seasons, no matches occur, and the values of \\( S \\) and \\( \\overline{S} \\) persist until the next season begins. Similarly, a PBP can track metrics over a specific period each year, such as Cooling Degree Days for August, with values updating during the period and remaining constant until the next cycle, as shown in Example 4.</p>"},{"location":"BoundedPhenomena/#example-4-cooling-degree-days-in-new-york-for-august","title":"Example 4: Cooling Degree Days in New York for August","text":"<p>This PBP models the total Cooling Degree Days (CDD) in New York for the month of August, a fixed 31-day period each year. Each day in August is a time step \\( t \\), with the outcome being the CDD, calculated as \\( X_t = \\max(0, T_t - 18) \\), where \\( T_t \\) is the average daily temperature in \u00b0C, capped at 30 CDD per day. Thus:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 29.8, 29.9, 30\\} \\] <p>with maximum \\( m = 30 \\). The interval is defined by \\( a = 0 \\) (no cooling needed) and \\( b = 30 \\) (maximum daily CDD). Over the 31 days of August (\\( n = 31 \\)), total CDD \\( S \\) is:</p> \\[ S = \\sum_{k=0}^{30} X_{t-k}, \\quad 0 \\leq S \\leq 30 \\cdot 31 = 930. \\] <p>The complementary measure, \\( \\overline{S} = 930 - S \\), represents the shortfall from the maximum possible CDD. For example, if the total CDD for August is 200, then:</p> \\[ \\overline{S} = 930 - 200 = 730 \\] <p>This pair \\( (200, 730) \\) reflects the cooling demand for August versus the unused cooling capacity. After August, \\( S \\) and \\( \\overline{S} \\) remain fixed until the next August, illustrating a PBP with a yearly cycle and gaps between event periods.</p>"},{"location":"BoundedPhenomena/#tokenizing-principals","title":"Tokenizing Principals","text":""},{"location":"BoundedPhenomena/#tokens-t-and-overlinet","title":"Tokens \\( T \\) and \\( \\overline{T} \\)","text":"<pre><code>graph TD\n    S[\"S\"] -.-&gt;|peg mechanism| T((T))\n    Sbar[\"S\u0305\"] -.-&gt;|peg mechanism| Tbar((T\u0305))\n    style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n    style S fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n    style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n    style Sbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n</code></pre>"},{"location":"BoundedPhenomena/#constant-price-formula","title":"Constant Price Formula","text":"<p>To preserve the complementary dynamics inherent in \\( S \\) and \\( \\overline{S} \\), we fix the prices of our tokens to a constant.</p> \\[ P_T + P_{\\overline{T}} = 1 \\]"},{"location":"BoundedPhenomena/#price-units","title":"Price Units","text":"<p>The constant price formula can be tied to any asset as needed. We envision this system primarily being priced in stablecoins, such as USDT or USDC. In this paper, we use USDC as shorthand for the pricing asset of choice.</p>"},{"location":"BoundedPhenomena/#enforcement-of-constant-price-formula","title":"Enforcement of Constant Price Formula","text":"<p>The constant price relationship is enforced by allowing 1 \\( T \\) and 1 \\( \\overline{T} \\) to be minted or burned at any time for 1 USDC.</p> <pre><code>graph TD\n        USDC((USDC)) --&gt; T((T))\n        USDC((USDC)) --&gt; Tbar((T\u0305))\n        style USDC fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff\n        style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n        style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n</code></pre> <pre><code>graph TD\n        T((T)) --&gt; USDC((USDC))\n        Tbar((T\u0305)) --&gt; USDC((USDC))\n        style USDC fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff\n        style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n        style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n</code></pre>"},{"location":"BoundedPhenomena/#peg-mechanism-linking-tokens-to-performance","title":"Peg Mechanism: Linking Tokens to Performance","text":"<p>The peg mechanism ties the value of token \\(T\\) to the expected future performance of an underlying phenomenon \\(S\\). Below are the key variables:</p> <ul> <li>\\(r\\): Daily USDC yield</li> <li>\\(YT\\): Yield for token \\(T\\)</li> <li>\\(Y\\overline{T}\\): Yield for token \\(\\overline{T}\\)</li> </ul> <p>Each \\(T\\) and \\(\\overline{T}\\) pair is minted with USDC. USDC is deposited into an interest-bearing protocol generating a daily yield \\(r\\). This yield is split between \\(YT\\) and \\(Y\\overline{T}\\) based on \\(S\\), as evaluated by a fixed market rubric, such that:</p> \\[ YT + Y\\overline{T} = r \\] <pre><code>flowchart LR\n    S --&gt; Rubric\n    Rubric --&gt; Tyield[\"YT\"]\n    Rubric --&gt; Tbaryield[\"YT bar\"]\n    USDC --&gt; yield[\"r\"]\n    yield --&gt; Rubric\n</code></pre>"},{"location":"BoundedPhenomena/#rubrics","title":"Rubrics","text":"<p>Definitions:</p> <ul> <li>\\(\\rho_T\\): Ratio of \\(r\\) received by \\(T\\).</li> <li>\\(\\rho_{\\bar{T}}\\): Ratio of \\(r\\) received by \\(\\bar{T}\\).</li> </ul> <p>Thus:</p> <ul> <li>\\(Y_T = r \\cdot \\rho_T\\)</li> <li>\\(Y_{\\bar{T}} = r \\cdot \\rho_{\\bar{T}}\\)</li> </ul> <p>The constraint for the function is:</p> <ul> <li>Ratios must sum to 1:</li> <li>\\(\\rho_T(S) + \\rho_{\\bar{T}}(S) = 1\\)</li> </ul>"},{"location":"BoundedPhenomena/#what-does-price-mean","title":"What Does Price Mean?","text":"<ul> <li>\\(P(T)\\): Present value of token \\(T\\)\u2019s future yields (\\(YT\\)).</li> <li>\\(P(\\overline{T})\\): Present value of token \\(\\overline{T}\\)\u2019s yields (\\(Y\\overline{T}\\)).</li> </ul> <p>i.e.:</p> \\[ P(T) = \\sum_{t=1}^{\\infty} \\frac{YT_t}{(1 + r_t)^t} \\] \\[ P(\\overline{T}) = \\sum_{t=1}^{\\infty} \\frac{Y\\overline{T}_t}{(1 + r_t)^t} \\] <p>Linear Rubric:</p> <p>There are infinitely many pairs of \\(\\rho_T\\) and \\(\\rho_{\\bar{T}}\\) functions that satisfy the rubric conditions. We anticipate the most widely used will be the linear mapping:</p> <ul> <li>\\(\\rho_T(S) = \\frac{S}{S_{max}}\\)</li> <li>\\(\\rho_{\\bar{T}}(S) = 1 - \\frac{S}{S_{max}}\\)</li> </ul>"},{"location":"BoundedPhenomena/#price-under-the-linear-rubric","title":"Price under the linear Rubric","text":"<p>The price of token \\( T \\), denoted \\( P(T) \\), is derived by substituting the yield relation \\( YT_t = \\frac{S_t}{S_{\\max}} \\cdot r_t \\) into the price formula:</p> \\[ P(T) = \\sum_{t=1}^{\\infty} \\frac{\\frac{S_t}{S_{\\max}} \\cdot r_t}{(1 + r_t)^t} = \\frac{1}{S_{\\max}} \\cdot \\sum_{t=1}^{\\infty} \\frac{S_t \\cdot r_t}{(1 + r_t)^t} \\]"},{"location":"BoundedPhenomena/#yield-distribution","title":"Yield Distribution","text":"<p>The peg is maintained through daily yield distributions from the USDC yield \\(r\\), as described earlier. The yields are allocated to \\(T\\) and \\(\\overline{T}\\) holders based on the performance of \\(S\\) relative to the maximum possible performance \\(S_{max}\\), using the linear mapping defined in the rubric:</p> \\[ Y_T = r \\cdot \\frac{S}{S_{max}}, \\quad Y_{\\overline{T}} = r \\cdot \\frac{S_{max} - S}{S_{max}} \\] <p>This ensures the total daily yield is fully distributed:</p> \\[ Y_T + Y_{\\overline{T}} = r \\] <p>The better \\(S\\) performs, the larger the share of the daily yield \\(T\\) holders receive, and vice versa for \\(\\overline{T}\\).</p>"},{"location":"BoundedPhenomena/#applications","title":"Applications","text":""},{"location":"BoundedPhenomena/#1-reform-uk-voting-intention-in-weekly-poll","title":"1. Reform UK Voting Intention in Weekly Poll","text":"<p>Weekly poll using one of the main pollsters. Used for political forecasting and hedging.</p> <p>Events: </p> <ul> <li>Weekly poll percentage for Reform UK, in 0.1% increments \\(X_t \\in \\{0, 0.1, \\dots, 100\\}, m = 100\\).</li> </ul> <p>Value:</p> <ul> <li>\\(S_t = X_t\\) (0\u2013100).</li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 100 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{100}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{100}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between polls</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on the performance of Reform UK</li> </ul> <p>Peformance Outline: </p> <ul> <li>If YouGov reports 26.3% support (\\(S_t = 26.3\\))</li> <li>then \\(\\overline{S}_t = 73.7\\)</li> <li>\\(\\rho_T = 0.263\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.737\\). </li> <li>\\(T\\) holders (bullish on Reform UK) get ~26.3% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~73.7%.</li> </ul> <p>Application</p> <ul> <li>Analysts hedge campaign risks</li> <li>Users speculate on performance</li> <li>Each new poll updates ratios.</li> </ul>"},{"location":"BoundedPhenomena/#2-liverpools-points-in-the-premier-league","title":"2. Liverpool\u2019s Points in the Premier League","text":"<p>Tracks Liverpool\u2019s points over a rolling 38 matches period.</p> <p>Events: </p> <ul> <li>Match points, in increments of 0, 1, or 3 for loss, draw, or win (\\(X_t \\in \\{0, 1, 3\\}, m = 3\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{37} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 114\\) </li> <li>\\(n = 38\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 114 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{114}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{114}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between matches</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on Liverpool\u2019s performance</li> </ul> <p>Peformance Outline: </p> <ul> <li>If Liverpool has scored 80 points in the last rolling 38 games (\\(S_t = 80\\))</li> <li>then \\(\\overline{S}_t = 114 - 80 = 34\\)</li> <li>\\(\\rho_T \\approx 0.702\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.298\\). </li> <li>\\(T\\) holders (bullish on Liverpool) get ~70.2% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~29.8%.</li> </ul> <p>Application</p> <ul> <li>Fans speculate on team performance</li> <li>Institutions hedge exposure</li> <li>Each new match updates ratios.</li> </ul>"},{"location":"BoundedPhenomena/#3-cooling-degree-days-in-new-york-rolling-30-days","title":"3. Cooling Degree Days in New York (Rolling 30 Days)","text":"<p>Tracks cooling demand over a rolling 30-day period using NOAA data for energy cost hedging.</p> <p>Events: </p> <ul> <li>Daily CDD, \\(X_t = \\max(0, T_t - 18)\\), in \u00b0C, capped at 30 (\\(X_t \\in \\{0, 0.1, \\dots, 30\\}, m = 30\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{29} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 900\\) </li> <li>\\(n = 30\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 900 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{900}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{900}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) update daily with new temperature data</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on cooling demand</li> </ul> <p>Peformance Outline: </p> <ul> <li>If NOAA reports 150 CDD over 30 days (\\(S_t = 150\\))</li> <li>then \\(\\overline{S}_t = 900 - 150 = 750\\)</li> <li>\\(\\rho_T \\approx 0.167\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.833\\). </li> <li>\\(T\\) holders (bullish on high cooling demand) get ~16.7% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~83.3%.</li> </ul> <p>Application</p> <ul> <li>Energy firms hedge heatwave costs</li> <li>Speculators trade on weather forecasts</li> <li>Each new daily temperature updates ratios.</li> </ul>"},{"location":"BoundedPhenomena/#4-cooling-degree-days-in-new-york-for-august","title":"4. Cooling Degree Days in New York for August","text":"<p>Tracks cooling demand for August using NOAA data for seasonal hedging.</p> <p>Events: </p> <ul> <li>Daily CDD, \\(X_t = \\max(0, T_t - 18)\\), in \u00b0C, capped at 30 (\\(X_t \\in \\{0, 0.1, \\dots, 30\\}, m = 30\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{30} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 930\\) </li> <li>\\(n = 31\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 930 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{930}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{930}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) adjust daily in August, fixed otherwise</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on August cooling demand</li> </ul> <p>Peformance Outline: </p> <ul> <li>If NOAA reports 200 CDD for August (\\(S_t = 200\\))</li> <li>then \\(\\overline{S}_t = 930 - 200 = 730\\)</li> <li>\\(\\rho_T \\approx 0.215\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.785\\). </li> <li>\\(T\\) holders (bullish on high cooling demand) get ~21.5% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~78.5%.</li> </ul> <p>Application</p> <ul> <li>Energy retailers hedge summer demand</li> <li>Speculators take positions on August weather</li> <li>Each new daily temperature in August updates ratios.</li> </ul>"},{"location":"BoundedPhenomena/#5-inflation-rate","title":"5. Inflation Rate","text":"<p>Tracks quarterly inflation rates using U.S. Bureau of Labor Statistics CPI data for economic hedging.</p> <p>Events: </p> <ul> <li>Quarterly inflation rate, in 0.1% increments (\\(X_t \\in \\{0, 0.1, \\dots, 10\\}, m = 10\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = X_t\\) </li> <li>\\(0 \\leq S_t \\leq 10\\)</li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 10 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{10}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{10}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between quarterly reports</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on inflation trends</li> </ul> <p>Peformance Outline: </p> <ul> <li>If CPI reports 3.2% inflation (\\(S_t = 3.2\\))</li> <li>then \\(\\overline{S}_t = 10 - 3.2 = 6.8\\)</li> <li>\\(\\rho_T = 0.32\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.68\\). </li> <li>\\(T\\) holders (bullish on rising inflation) get ~32% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~68%.</li> </ul> <p>Application</p> <ul> <li>Investors hedge inflation costs</li> <li>Speculators take positions on economic stability</li> <li>Each new quarterly report updates ratios.</li> </ul>"},{"location":"BoundedPhenomena/#6-self-referencing-popularity-index-for-taylor-swift","title":"6. Self-Referencing Popularity Index for Taylor Swift","text":"<p>Tracks public opinion on Taylor Swift's anticipated future popularity through a self-referencing asset, useful for sentiment analysis and cultural hedging.</p> <p>Events: </p> <ul> <li>No external events; self-referencing based on market price of \\(T\\)</li> <li>\\(X_t \\in \\{0, 0.01, \\dots, 1\\}, m = 100\\).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = P(T)\\) </li> <li>\\(0 \\leq S_t \\leq 1\\) </li> <li>\\(n = 1\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 100 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = {S_t} = P(T)\\)</li> <li>\\(\\rho_{\\overline{T}} = {\\overline{S}_t} = 1 - P(T)\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) update dynamically with changes in \\(P(T)\\), creating a feedback loop</li> </ul> <p>Price Meaning:</p> <ul> <li>\\(P(T)\\) reflects a discounted anticipation of Taylor Swift\u2019s future popularity</li> </ul> <p>Peformance Outline: </p> <ul> <li>If the current market price \\(P(T) = 0.85\\) (\\(S_t = 0.85\\))</li> <li>then \\(\\overline{S}_t = 1 - 0.85 = 0.15\\)</li> <li>\\(\\rho_T = 0.85\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.15\\). </li> <li>\\(T\\) holders (bullish on Taylor Swift\u2019s future popularity) get ~85% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~15%.</li> </ul> <p>Application</p> <ul> <li>Fans and media speculate on future cultural relevance</li> <li>Brands hedge endorsement risks</li> <li>Market dynamics drive updates through trading activity.</li> </ul>"},{"location":"BoundedPhenomena/#new-ideas-for-tokenizing-perpetual-bounded-phenomena","title":"New Ideas for Tokenizing Perpetual Bounded Phenomena","text":""},{"location":"BoundedPhenomena/#1-simplifying-with-annual-binary-outcomes","title":"1. Simplifying with Annual Binary Outcomes","text":"<p>To make development easier and the system more understandable, shift from continuous or frequent updates to annual binary outcomes. Instead of tracking rolling windows or frequent events, focus on yearly yes/no results for specific milestones.</p>"},{"location":"BoundedPhenomena/#key-changes","title":"Key Changes:","text":"<ul> <li>Binary Nature: Outcomes are binary (e.g., achieved or not achieved) and evaluated annually.</li> <li>Examples in Football:</li> <li>Liverpool wins the Premier League.</li> <li>Liverpool qualifies for Champions League.</li> <li>Liverpool qualifies for Europe (Champions or Europa League).</li> <li>Liverpool remains in the Premier League.</li> <li>Dividend Payouts: Dividends are paid based on the current status of the outcome. If the binary condition is met (e.g., team achieves the milestone), token holders receive yields; otherwise, no yields until the next evaluation.</li> <li>Long-Term Holding Incentive: Users can buy tokens for unlikely or long-shot outcomes (e.g., a lower-division team like Northampton Town reaching the Premier League). These tokens may yield nothing for years but could generate significant annual dividends (e.g., turning a $100 investment into $500/year in yields) once the outcome is achieved.</li> </ul>"},{"location":"BoundedPhenomena/#benefits","title":"Benefits:","text":"<ul> <li>Fewer oracle events (annual updates only).</li> <li>Simpler to implement and explain, reducing complexity compared to perpetual or rolling PBPs.</li> </ul> <p>This approach maintains the perpetual aspect but ties yields to discrete, annual checkpoints, making it more accessible for users and developers.</p>"},{"location":"BoundedPhenomena/#2-claimable-rewards","title":"2. Claimable Rewards","text":"<p>Native yield issuance without claiming poses challenges, especially with multiple tokens yielding in the same stablecoin (e.g., USDC). To address this, introduce claimable rewards to simplify yield distribution.</p>"},{"location":"BoundedPhenomena/#key-points","title":"Key Points:","text":"<ul> <li>Claimable Yields: Yields are not automatically distributed but must be claimed by token holders. This avoids building complex systems for handling yields across many tokens in the same asset.</li> <li>Implementation: Yields are accumulated in USDC (or a yield-bearing version like ppUSDC) and can be claimed by holders of T or \\(\\overline{T}\\) based on the performance rubric.</li> </ul>"},{"location":"BoundedPhenomena/#benefits_1","title":"Benefits:","text":"<ul> <li>Simplifies yield management for users and reduces system complexity.</li> <li>Ensures scalability when managing multiple token pairs.</li> </ul>"},{"location":"BoundedPhenomena/#3-rebasing-tokens-as-an-additional-development","title":"3. Rebasing Tokens as an Additional Development","text":"<p>As an additional feature to support users who prefer automated yield handling, introduce rebasing tokens for auto-compounding yields on top of the base system.</p>"},{"location":"BoundedPhenomena/#key-points_1","title":"Key Points:","text":"<ul> <li>Rebasing Tokens:</li> <li>Users deposit base tokens (T or \\(\\overline{T}\\)) into a rebasing contract to receive rebasing versions (e.g., aT for auto-compounding T).</li> <li>The contract holds the base tokens and accumulates claimable interest (in USDC or ppUSDC).</li> <li>Deposits and withdrawals of T or \\(\\overline{T}\\) trigger a swap on Uniswap to convert accumulated interest (USDC or \\(\\overline{T}\\)) into the deposited token type (e.g., depositing T triggers swapping \\(\\overline{T}\\) or USDC to T). This ensures the contract maintains a balanced pool for aT holders while leveraging Uniswap\u2019s market pricing.</li> <li>Deposit and Withdrawal Handling:<ul> <li>Deposits: Users deposit T or \\(\\overline{T}\\), and the contract mints aT based on a share price (<code>total_underlying / total_aT_supply</code>). The share price accounts for held T, \\(\\overline{T}\\) (valued at Uniswap\u2019s current price), and USDC (valued as mintable T + \\(\\overline{T}\\) sold on Uniswap). Deposits trigger a Uniswap swap to convert any \\(\\overline{T}\\) or USDC to T (or vice versa for \\(\\overline{T}\\) deposits), maintaining pool balance.</li> <li>Withdrawals: Redeeming aT returns T or \\(\\overline{T}\\) based on the share price. If insufficient T is available, the contract swaps \\(\\overline{T}\\) or USDC to T on Uniswap to fulfill the withdrawal.</li> <li>This prevents overpayment for new depositors by ensuring they receive a fair share of the contract\u2019s current value, adjusted for Uniswap\u2019s market rates.</li> </ul> </li> <li>The contract periodically claims USDC yields, splits them into T and \\(\\overline{T}\\), and uses Uniswap swaps to align holdings with deposited token types.</li> </ul>"},{"location":"BoundedPhenomena/#benefits_2","title":"Benefits:","text":"<ul> <li>Enables auto-compounding via rebasing for hands-off users, simplifying the user experience.</li> <li>Simplifies valuation by relying on Uniswap\u2019s market pricing, avoiding complex internal pricing algorithms.</li> </ul>"},{"location":"BoundedPhenomena/#4-internal-liquidity-as-a-positive-externality","title":"4. Internal Liquidity as a Positive Externality","text":"<p>The rebasing contract, by facilitating the conversion of T to \\(\\overline{T}\\) (or vice versa) via Uniswap swaps, also serves as a liquidity provider, creating a positive externality for the system.</p>"},{"location":"BoundedPhenomena/#key-points_2","title":"Key Points:","text":"<ul> <li>Liquidity Provision:</li> <li>The rebasing contract supports swaps between T and \\(\\overline{T}\\) by leveraging Uniswap for conversions, triggered by deposits or withdrawals. For example, depositing T may require swapping \\(\\overline{T}\\) or USDC to T on Uniswap to maintain pool balance.</li> <li>General Principle: When a swap is needed, the contract uses Uniswap\u2019s current market price (potentially with a TWAP for stability) to execute trades. This ensures liquidity for users while aligning the contract\u2019s holdings with user deposits.</li> <li>This creates a balanced, automated market within the contract, improving the liquidity of the system.</li> <li>Positive Externality: The need to manage complementary tokens (T and \\(\\overline{T}\\)) inherently provides liquidity to the system by facilitating Uniswap-based trades, enhancing market depth and accessibility.</li> </ul>"},{"location":"BoundedPhenomena/#benefits_3","title":"Benefits:","text":"<ul> <li>Enhances liquidity through Uniswap integration, leveraging external market efficiency.</li> <li>Creates a self-sustaining system where token conversion supports overall market efficiency.</li> </ul>"},{"location":"BoundedPhenomena/#handling-deposits-and-withdrawals-with-uniswap-integration","title":"Handling Deposits and Withdrawals with Uniswap Integration","text":"<p>To address the concern about overpayment when depositing into the rebasing contract (e.g., if significant interest has accumulated), the system uses a share-based model with Uniswap swaps to ensure fairness:</p> <ul> <li>Deposit Process:</li> <li>On T deposit, the contract claims accumulated USDC yields and swaps for T and \\(\\overline{T}\\).</li> <li>The contract swaps \\(\\overline{T}\\) to T on Uniswap.</li> <li>This updates user balances of aT</li> <li> <p>Mint aT = deposited T</p> </li> <li> <p>Withdrawal Process:</p> </li> <li>Claim accumulated ppUSDC</li> <li>Update balances of aT</li> <li>Burn aT being withdrawn</li> <li> <p>transfer amount of T equalt to aT being withdrawn to the user.</p> </li> <li> <p>Benefits of Uniswap Integration:</p> </li> <li>Fairness: Using Uniswap\u2019s market price (or TWAP) ensures new depositors don\u2019t receive disproportionate value from accumulated interest, preventing overpayment.</li> <li>Simplicity: Eliminates the need for a complex internal pricing algorithm, relying on Uniswap\u2019s established liquidity and pricing</li> <li>Liquidity Boost: Swaps triggered by deposits/withdrawals add trading volume to Uniswap pools, enhancing overall system liquidity.</li> <li>Trade-Off: Uniswap prices may not always be optimal (e.g., slippage or market volatility), but TWAP usage and sufficient pool depth can mitigate this. It\u2019s a practical trade-off for simplicity and reliability.</li> </ul> <p>This approach streamlines the rebasing contract by leveraging Uniswap for pricing and liquidity, ensuring fair deposits/withdrawals while maintaining the system\u2019s core mechanics.</p>"},{"location":"BoundedPhenomena/#token-rebasing-system-specification","title":"Token Rebasing System Specification","text":"<p>This document outlines the design for a token rebasing system integrated with binary event resolution using UMA bonds and Uniswap V2 pools. The system simplifies event settlement and incentivizes frequent rebalancing through a dual-token mechanism with <code>T</code>, <code>T-bar</code>, <code>aT</code>, and <code>aT-bar</code> tokens, managed by a controller contract.</p>"},{"location":"BoundedPhenomena/#binary-event-resolution","title":"Binary Event Resolution","text":""},{"location":"BoundedPhenomena/#overview","title":"Overview","text":"<p>The system reduces complex phenomena to binary events with long-term outcomes, settled via UMA bonds for simplified implementation.</p>"},{"location":"BoundedPhenomena/#key-points_3","title":"Key Points","text":"<ol> <li>Event Structure:</li> <li>Binary events are defined with clear, verifiable outcomes.</li> <li>Example: \"The most recent football season ended with the last match day on May 11th, 2025.\"</li> <li>Derived statement: \"Liverpool won the Premier League Football season that ended on May 11th, 2025.\"</li> <li>UMA Integration:</li> <li>Binary events are pushed to UMA for resolution, leveraging UMA bonds to ensure reliable settlement.</li> </ol>"},{"location":"BoundedPhenomena/#rebasing-token-mechanism","title":"Rebasing Token Mechanism","text":""},{"location":"BoundedPhenomena/#core-concepts","title":"Core Concepts","text":"<p>The rebasing system uses two primary tokens, <code>T</code> and <code>T-bar</code>, with their respective rebasing tokens <code>aT</code> and <code>aT-bar</code>. USDC serves as the reward and exchange currency, with Uniswap V2 pools facilitating liquidity and rebalancing. A controller contract manages the minting and distribution of tokens during rebalancing.</p>"},{"location":"BoundedPhenomena/#token-mechanics","title":"Token Mechanics","text":"<ol> <li>Rewards:</li> <li>Rewards are claimable in USDC for holders of token <code>T</code> and <code>T-bar</code>.</li> <li>Uniswap V2 pools exist for:<ul> <li>USDC/<code>T</code></li> <li>USDC/<code>T-bar</code></li> </ul> </li> <li>Exchange rates:<ul> <li>1 USDC is exchangeable for 1 <code>T</code> or 1 <code>T-bar</code>.</li> <li>Burning 1 <code>T</code> and 1 <code>T-bar</code> yields 1 USDC.</li> </ul> </li> <li>Deposits and Withdrawals:</li> <li>Deposit <code>T</code> to receive <code>aT</code> at a 1:1 ratio.</li> <li>Deposit <code>T-bar</code> to receive <code>aT-bar</code> at a 1:1 ratio.</li> <li>Burn <code>aT</code> to receive <code>T</code> at a 1:1 ratio.</li> <li>Burn <code>aT-bar</code> to receive <code>T-bar</code> at a 1:1 ratio.</li> </ol>"},{"location":"BoundedPhenomena/#rebalance-process","title":"Rebalance Process","text":"<p>The <code>Rebalance()</code> function manages the rebasing process between the <code>aT</code> and <code>aT-bar</code> contracts, utilizing Uniswap V2 TWAP and the <code>T/T-bar</code> controller contract. The function can be called by anyone, with incentives to increase call frequency as locked value grows.</p> <ol> <li>USDC Claim and Transfer:</li> <li>The <code>aT</code> contract claims USDC and transfers it to the controller.</li> <li>The <code>aT-bar</code> contract claims USDC and transfers it to the controller.</li> <li>TWAP Calculation:</li> <li>The <code>aT</code> contract uses TWAP since the last rebalance to calculate the amount of <code>T</code> it should receive for its USDC (denoted as value <code>b</code>).</li> <li>The <code>aT-bar</code> contract uses TWAP since the last rebalance to calculate the amount of <code>T-bar</code> it should receive for its USDC (denoted as value <code>c</code>).</li> <li>Minting and Rebasing:</li> <li>The controller mints <code>min(b, c)</code> pairs of <code>T</code> and <code>T-bar</code> using the USDC it holds, depositing claimed USDC into the <code>T/T-bar</code> controller contract.</li> <li>Minted <code>T</code> is sent to the <code>aT</code> contract, and minted <code>T-bar</code> is sent to the <code>aT-bar</code> contract.</li> <li>After minting, either the <code>aT</code> or <code>aT-bar</code> contract retains residual USDC, as only the minimum of <code>b</code> and <code>c</code> is minted.</li> <li>Rebalancing with TWAP Threshold:</li> <li>The contract rebases against Uniswap V2 using TWAP, triggered when the TWAP deviates by a predefined threshold.</li> <li>If the TWAP threshold is not met, the contract records a new TWAP checkpoint for the next rebalance and performs a partial rebase without executing a Uniswap swap.</li> <li>Incentives for Rebase Calls:</li> <li>The <code>Rebalance()</code> function is permissionless, allowing anyone to call it and earn a reward. The reward is a percentage of the total USDC claimed by <code>aT</code> and <code>aT-bar</code> contracts during the rebalance. A 1% reward is likely sufficient to incentivize frequent calls. Initially, the dev team will deploy a bot to call <code>Rebalance()</code> regularly, ensuring consistent operation. As the total locked value in the system increases, the USDC reward will incentivize additional external users to trigger the function more frequently, resulting in smoother and more continuous rebasing.</li> <li>Deposit Pending Period:</li> <li>When a user deposits <code>T</code> to receive <code>aT</code> (or <code>T-bar</code> to receive <code>aT-bar</code>), the deposit is non-transferable during the period before the next rebalance, referred to as the \"Pending Period.\" However, the deposit can be withdrawn during this period.</li> <li>Rebasing for that specific user deposit does not begin until the respective contract (<code>aT</code> or <code>aT-bar</code>) is fully rebased (i.e., no claimable USDC remains). This means the user may miss the first rebase period (or part thereof) for their deposit.</li> </ol>"},{"location":"BoundedPhenomena/#additional-notes","title":"Additional Notes","text":"<ul> <li>A full specification for the deposit rebase delay and Pending Period is available separately.</li> <li>The system ensures continuous rebalancing to maintain stability, with incentives designed to encourage frequent user-driven rebase calls, especially as the locked value grows.</li> </ul>"},{"location":"BoundedPhenomena/#rebasing-mechanism-sketch","title":"Rebasing Mechanism Sketch","text":""},{"location":"BoundedPhenomena/#introduction_1","title":"Introduction","text":"<p>This document outlines a rebasing vault smart contract in Solidity. Users deposit an underlying token (T) to receive a rebasing token (aT). The aT balance grows via periodic rebases, but new deposits remain fixed until activated at the next <code>rebase()</code> call. The rate at each checkpoint (<code>rebase_id = n</code>) applies to the period from <code>n-1</code> to <code>n</code>.</p> <p>Key Goals: - Support variable rates per rebase period. - Efficient: No iteration over users or deposits in <code>rebase()</code>. - User balances split into activated (rebasing, transferable) and pending (fixed until activation, non-transferable). - Use a cumulative index with historical snapshots for accurate accounting.</p> <p>Assumptions: - Rebase rate is provided externally (complex calculation, not detailed). - Scale factor: 1e18 for fixed-point math. - ERC20-based with overrides for <code>balanceOf</code>, <code>totalSupply</code>, <code>transfer</code>, etc. - Withdrawals distribute underlying T proportionally (vault accrues yield).</p>"},{"location":"BoundedPhenomena/#core-concepts_1","title":"Core Concepts","text":""},{"location":"BoundedPhenomena/#cumulative-index","title":"Cumulative Index","text":"<ul> <li>Global multiplier tracking growth since inception.</li> <li>Starts at <code>1e18</code>.</li> <li>Updated in <code>rebase()</code>: <code>new_index = old_index * (1e18 + rate) / 1e18</code>.</li> <li>Represents compounded rates from all rebases.</li> </ul>"},{"location":"BoundedPhenomena/#rebase-id-and-history","title":"Rebase ID and History","text":"<ul> <li><code>current_rebase_id</code>: Starts at 0, increments per <code>rebase()</code>.</li> <li><code>cumulative_index_history[rebase_id]</code>: Stores <code>cumulative_index</code> after each rebase.</li> <li>Rate from <code>x</code> to <code>y</code>: <code>(cumulative_index_history[y] * 1e18 / cumulative_index_history[x]) - 1e18</code>.</li> </ul>"},{"location":"BoundedPhenomena/#user-balance-parts","title":"User Balance Parts","text":"<p>Each user has two balance components (no arrays): 1. Activated Part (Part 1):    - Stored as <code>user_effective_shares</code> (normalized shares).    - Balance: <code>user_effective_shares * cumulative_index / 1e18</code>.    - Grows with every rebase, reflecting all rates post-activation.    - Transferable to other addresses. 2. Pending Part (Part 2):    - Stored as <code>user_pending_base</code> (raw amount) with <code>user_pending_entry_id</code> (activation rebase_id).    - Fixed if <code>user_pending_entry_id &gt; current_rebase_id</code>.    - If activated (<code>entry_id &lt;= current_rebase_id</code>), balance = <code>user_pending_base * cumulative_index / cumulative_index_history[entry_id]</code>.    - Non-transferable; remains with depositor until merged.    - Multiple deposits before a rebase accumulate in the same pending part.</p>"},{"location":"BoundedPhenomena/#global-tracking","title":"Global Tracking","text":"<ul> <li><code>effective_shares</code>: Sum of all <code>user_effective_shares</code>.</li> <li><code>global_pending_base</code>: Total pending deposits (single <code>entry_id</code>).</li> <li><code>global_pending_entry_id</code>: Pending group ID (one cohort at a time).</li> </ul>"},{"location":"BoundedPhenomena/#rebase-process","title":"Rebase Process","text":"<ol> <li>Input: Rate for period from <code>current_rebase_id</code> to <code>current_rebase_id + 1</code> (external).</li> <li>Update Index: <code>cumulative_index = cumulative_index * (1e18 + rate) / 1e18</code>.</li> <li>Store History: Increment <code>current_rebase_id</code>, set <code>cumulative_index_history[current_rebase_id] = cumulative_index</code>.</li> <li>Activate Pending: If <code>global_pending_entry_id == current_rebase_id</code>:</li> <li>Add <code>global_pending_base * 1e18 / cumulative_index</code> to <code>effective_shares</code>.</li> <li>Reset <code>global_pending_base = 0</code>, <code>global_pending_entry_id = 0</code>.</li> <li>Effects: Activated balances grow by rate; pending deposits activate without prior gains.</li> </ol> <p>Efficiency: O(1), no user loops.</p>"},{"location":"BoundedPhenomena/#rate-handling","title":"Rate Handling","text":"<ul> <li>Rate at Checkpoint n: Applies to period from <code>n-1</code> to <code>n</code>, used in <code>rebase()</code> to update <code>cumulative_index</code>.</li> <li>Querying Rates: Rate from <code>x</code> to <code>y</code> (y &gt; x): <code>(cumulative_index_history[y] * 1e18 / cumulative_index_history[x]) - 1e18</code>.</li> <li>Example:</li> <li>Rebase 1 (rate = 0.05e18): <code>history[1] = 1.05e18</code>.</li> <li>Rebase 2 (rate = 0.03e18): <code>history[2] = 1.05e18 * 1.03 = 1.0815e18</code>.</li> <li>Rate at checkpoint 2 (from 1 to 2): <code>(1.0815e18 / 1.05e18) - 1 = 0.03</code>.</li> </ul>"},{"location":"BoundedPhenomena/#user-interactions","title":"User Interactions","text":""},{"location":"BoundedPhenomena/#deposit","title":"Deposit","text":"<ol> <li>Merge pending if <code>user_pending_entry_id &lt;= current_rebase_id</code> (see Merge).</li> <li>Transfer T to vault.</li> <li>Set <code>entry_id = current_rebase_id + 1</code>.</li> <li>Add <code>amount</code> to <code>user_pending_base</code> (accumulate if same <code>entry_id</code>).</li> <li>Set <code>user_pending_entry_id = entry_id</code> if unset.</li> <li>Update globals: Add to <code>global_pending_base</code>, set <code>global_pending_entry_id</code> if needed.</li> <li>Mint aT equal to <code>amount</code>.</li> </ol> <p>Note: New deposits are fixed and non-transferable until next rebase.</p>"},{"location":"BoundedPhenomena/#withdraw","title":"Withdraw","text":"<ol> <li>Merge pending if activated.</li> <li>Compute total balance = activated + pending (fixed or rebased).</li> <li>Require amount &lt;= total.</li> <li>Pro-rata reduce <code>user_effective_shares</code> and <code>user_pending_base</code>.</li> <li>Update globals: Subtract from <code>effective_shares</code>, <code>global_pending_base</code> if applicable.</li> <li>Burn aT, transfer proportional T (based on <code>totalSupply</code>).</li> </ol>"},{"location":"BoundedPhenomena/#transfer","title":"Transfer","text":"<ol> <li>Merge pending for sender and recipient if <code>user_pending_entry_id &lt;= current_rebase_id</code>.</li> <li>Compute sender's total balance (activated + pending), require amount &lt;= total.</li> <li>Calculate activated balance: <code>user_effective_shares[sender] * cumulative_index / 1e18</code>.</li> <li>Determine transferable amount:</li> <li>Only the activated part is transferable.</li> <li>If amount &lt;= activated balance, use only activated.</li> <li>If amount &gt; activated balance but &lt;= total, fail (pending is non-transferable).</li> <li>Reduce sender\u2019s <code>user_effective_shares</code> by <code>amount * 1e18 / cumulative_index</code>.</li> <li>Add to recipient\u2019s <code>user_effective_shares</code> (same amount).</li> <li>Update global <code>effective_shares</code> (no net change).</li> <li>Pending Note: Sender\u2019s <code>user_pending_base</code> and <code>user_pending_entry_id</code> remain unchanged (non-transferable). Recipient\u2019s pending part is unaffected.</li> <li>Emit Transfer event.</li> </ol> <p>Transfer Clarification: Only activated balances (rebasing, from <code>user_effective_shares</code>) can be transferred. Pending balances (fixed, non-rebasing) stay with the sender until activated and merged, ensuring pending deposits are tied to the original depositor.</p>"},{"location":"BoundedPhenomena/#merge-internal","title":"Merge (Internal)","text":"<ul> <li>If <code>user_pending_entry_id &lt;= current_rebase_id</code>:</li> <li>Convert: <code>delta_shares = user_pending_base * 1e18 / cumulative_index_history[user_pending_entry_id]</code>.</li> <li>Add to <code>user_effective_shares</code> and <code>effective_shares</code>.</li> <li>Clear <code>user_pending_base</code>, <code>user_pending_entry_id</code>.</li> </ul>"},{"location":"BoundedPhenomena/#balance-calculation-balanceof","title":"Balance Calculation (balanceOf)","text":"<ul> <li>Activated: <code>user_effective_shares * cumulative_index / 1e18</code>.</li> <li>Pending:</li> <li>If <code>entry_id &gt; current_rebase_id</code>: <code>user_pending_base</code> (fixed).</li> <li>Else: <code>user_pending_base * cumulative_index / cumulative_index_history[entry_id]</code>.</li> <li>Total: Sum of both.</li> </ul>"},{"location":"BoundedPhenomena/#total-supply","title":"Total Supply","text":"<ul> <li>Activated: <code>effective_shares * cumulative_index / 1e18</code>.</li> <li>Pending: <code>global_pending_base</code> if <code>global_pending_entry_id &gt; current_rebase_id</code>, else 0.</li> <li>Total: Sum.</li> </ul>"},{"location":"BoundedPhenomena/#efficiency-and-scalability","title":"Efficiency and Scalability","text":"<ul> <li>Storage: Per-user: 3 slots. Global: Scalars + <code>cumulative_index_history</code> (grows with rebases).</li> <li>Gas:</li> <li><code>rebase()</code>: O(1).</li> <li>User ops: O(1), at most one merge.</li> <li>Views: O(1).</li> <li>No Iteration: Uses aggregates and history mapping.</li> <li>Scalability: Handles many users/deposits efficiently.</li> </ul>"},{"location":"BoundedPhenomena/#edge-cases","title":"Edge Cases","text":"<ul> <li>First rebase: <code>rebase_id = 0</code> initializes correctly.</li> <li>No deposits: Skips activation.</li> <li>Multiple deposits: Accumulate in pending.</li> <li>Transfers: Only activated part moves; pending stays with sender.</li> <li>Zero rate: No effect.</li> </ul> <p>This design ensures efficient rebasing with variable rates, proper handling of non-transferable pending deposits, and clear accounting.</p>"},{"location":"CircleAmm/","title":"Elliptical and Circle Automated Market Maker (AMM) Models","text":"<p>This document provides a high-level overview of the elliptical model AMM and its symmetric special case, the circle AMM. The models are described from a \"holdings\" perspective, where the AMM's state is defined by the current token reserves (holdings) \\( h_R \\) and \\( h_G \\) for two tokens (e.g., Red and Green). At initialization, holdings are assumed equal: \\( h_R = F \\), \\( h_G = F \\), where \\( F \\) is the initial funding amount. Fees are ignored in this model for simplicity.</p> <p>The elliptical AMM is based on the work of Wang, as detailed in the referenced paper. The circle AMM is a symmetric simplification of the elliptical model, ensuring equal treatment of both tokens.</p>"},{"location":"CircleAmm/#elliptical-model-amm","title":"Elliptical Model AMM","text":""},{"location":"CircleAmm/#overview","title":"Overview","text":"<p>The elliptical AMM uses a cost function or invariant shaped like an ellipse in the reserve space. This generalizes constant-product AMMs (like Uniswap) by allowing tilted or squeezed level sets while maintaining convexity on the feasible branch (typically the lower-left arc in the first quadrant). It provides efficient computation (additions, multiplications, and one square root for block trades) and supports asymmetric token treatment if needed.</p>"},{"location":"CircleAmm/#state-and-holdings","title":"State and Holdings","text":"<ul> <li>Holdings (Reserves): Let \\( h_R = x \\) and \\( h_G = y \\) represent the current holdings of the two tokens.</li> <li>Initialization: At genesis, \\( h_R = F \\), \\( h_G = F \\), ensuring symmetry unless parameters introduce bias.</li> </ul>"},{"location":"CircleAmm/#invariant-cost-function","title":"Invariant / Cost Function","text":"<p>The general constant-ellipse invariant proposed by Wang is:</p> \\[ C(h_R, h_G) = (h_R - a)^2 + (h_G - a)^2 + b \\cdot h_R \\cdot h_G, \\] <p>where:</p> <ul> <li>\\( a &gt; 0 \\) is a center parameter (related to the ellipse's offset),</li> <li>\\( b \\) is a tilting/squeezing parameter (controls asymmetry; \\( b \\neq 0 \\) tilts the ellipse).</li> </ul> <p>Trades occur along the level sets of \\( C \\) (constant \\( C = k \\)), specifically the convex lower-left branch in the first quadrant. The invariant ensures that after a trade, the new holdings satisfy \\( C(h_R', h_G') = C(h_R, h_G) \\).</p> <p>For \\( n=2 \\) tokens, this is convex and admits efficient arithmetic for swaps.</p>"},{"location":"CircleAmm/#exchange-rates-and-trades","title":"Exchange Rates and Trades","text":"<ul> <li>Instantaneous Rate: Derived from the tangent slope of the ellipse.</li> <li>Block Trades: Solve the quadratic equation from the invariant for the output amount, involving one square root.</li> </ul>"},{"location":"CircleAmm/#reference","title":"Reference","text":"<p>This model is from Wang's paper: \"Automated Market Makers Designs for Decentralized Finance\" (arXiv:2009.01676v3). See Sections 2\u20134 and 6 for the ellipse cost/invariant, price derivatives, and generalizations.</p>"},{"location":"CircleAmm/#circle-amm-symmetric-case","title":"Circle AMM (Symmetric Case)","text":""},{"location":"CircleAmm/#overview_1","title":"Overview","text":"<p>The circle AMM is a special case of the elliptical model where \\( b = 0 \\), reducing the invariant to a perfect circle. This ensures complete symmetry between the tokens (\\( h_R \\) and \\( h_G \\) are treated identically, with no tilting). It is \"normal\" and intuitive when no specific shape is preferred, and reserves start equal.</p>"},{"location":"CircleAmm/#state-and-holdings_1","title":"State and Holdings","text":"<ul> <li>Holdings (Reserves): \\( h_R = x \\), \\( h_G = y \\).</li> <li>Initialization: \\( h_R = F \\), \\( h_G = F \\).</li> <li>Parameters: Center \\( c &gt; 0 \\), fixed radius \\( r &gt; 0 \\). These can be pinned to match initial holdings (e.g., \\( c = F \\), \\( r = F\\sqrt{2} \\) so the initial point lies on the circle).</li> </ul>"},{"location":"CircleAmm/#geometry-and-invariant","title":"Geometry and Invariant","text":"<p>The AMM constrains holdings to the lower-left arc of the circle in the first quadrant. Two equivalent implementations:</p>"},{"location":"CircleAmm/#approach-i-scaled-circle","title":"Approach I: Scaled Circle","text":"<p>Use a scaling factor \\( \\mu &gt; 0 \\) to fit holdings to the circle:</p> \\[ (\\mu h_R - c)^2 + (\\mu h_G - c)^2 = r^2, \\] <p>with \\( \\mu h_R &lt; c \\), \\( \\mu h_G &lt; c \\) (ensuring the lower-left arc).</p>"},{"location":"CircleAmm/#approach-ii-cost-as-circle-no-scaling","title":"Approach II: Cost as Circle (No Scaling)","text":"<p>Define the cost function directly:</p> \\[ C(h_R, h_G) = (h_R - c)^2 + (h_G - c)^2 = k, \\] <p>where \\( k = r^2 \\). Trades move along constant-\\( C \\) level sets (convex branch).</p> <p>At initialization (\\( h_R = F \\), \\( h_G = F \\)):</p> \\[ (F - c)^2 + (F - c)^2 = r^2 \\implies 2(F - c)^2 = r^2. \\]"},{"location":"CircleAmm/#instantaneous-exchange-rate","title":"Instantaneous Exchange Rate","text":"<p>For the circle \\( u^2 + v^2 = r^2 \\) with \\( u = \\mu h_R - c \\), \\( v = \\mu h_G - c \\) (Approach I):</p> \\[ \\frac{d(\\mu h_G)}{d(\\mu h_R)} = -\\frac{c - \\mu h_R}{c - \\mu h_G} \\implies \\text{Rate (} h_G \\text{ per } h_R\\text{)} = \\frac{c - \\mu h_R}{c - \\mu h_G}. \\] <p>For infinitesimal input \\( dh_R &gt; 0 \\), output \\( dh_G = dh_R \\cdot \\frac{c - \\mu h_R}{c - \\mu h_G} \\).</p> <p>In Approach II (no \\( \\mu \\)):</p> \\[ \\text{Rate} = \\frac{c - h_R}{c - h_G}. \\] <p>As one holding approaches 0, the rate diverges, creating a natural barrier against depletion.</p>"},{"location":"CircleAmm/#block-trade-formulas","title":"Block-Trade Formulas","text":"<p>For a block trade input \\( \\Delta h_R &gt; 0 \\) (buy \\( h_G \\), sell \\( h_R \\); no fees):</p> <ul> <li>New holdings: \\( h_R' = h_R + \\Delta h_R \\), \\( h_G' = h_G - \\Delta h_G \\).</li> <li>Solve the invariant for \\( \\Delta h_G \\) (Approach I):</li> </ul> \\[ \\Delta h_G = h_G - \\frac{1}{\\mu} \\left[ c - \\sqrt{r^2 - (\\mu (h_R + \\Delta h_R) - c)^2} \\right]. \\] <p>Pick the lower-left branch (minus sign in square root).</p> <p>For Approach II (no \\( \\mu \\)):</p> \\[ \\Delta h_G = h_G - \\left[ c - \\sqrt{r^2 - (h_R + \\Delta h_R - c)^2} \\right]. \\] <p>Symmetry: Swap roles for the opposite direction.</p>"},{"location":"CircleAmm/#relation-to-elliptical-model","title":"Relation to Elliptical Model","text":"<p>Setting \\( b = 0 \\) in the elliptical invariant reduces to the circle, ensuring symmetry (\\( \\lambda_0 = \\lambda_1 = 1 \\)).</p>"},{"location":"CircleAmm/#implementation-considerations","title":"Implementation Considerations","text":""},{"location":"CircleAmm/#from-holdings-perspective","title":"From Holdings Perspective","text":"<p>The AMM operates directly on holdings \\( h_R, h_G \\):</p> <ul> <li>State: Store \\( h_R, h_G, c, r \\) (or \\( \\mu \\) if using Approach I).</li> <li>Initialization: Set \\( h_R = F \\), \\( h_G = F \\). Choose \\( c = F \\), \\( r = F\\sqrt{2} \\) to place the initial point on the circle.</li> <li>Quotes: For input \\( \\Delta h_R \\), compute \\( \\Delta h_G \\) using the block-trade formula (one square root; gas-efficient).</li> <li>Updates: After trade, update holdings: \\( h_R += \\Delta h_R \\), \\( h_G -= \\Delta h_G \\).</li> <li>Barrier: Rate explosion prevents holdings from reaching 0 with finite input.</li> <li>Symmetry: Circle ensures identical treatment of tokens.</li> </ul>"},{"location":"CircleAmm/#solidity-snippet-approach-ii-no-fees","title":"Solidity Snippet (Approach II, No Fees)","text":"<p>For reference, a simplified Solidity implementation for quoting (using fixed-point math and Babylonian square root):</p> <pre><code>// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CircleAMM {\n    uint256 public hR; // Red holdings\n    uint256 public hG; // Green holdings\n    uint256 public c; // Center\n    uint256 public rSquared; // r^2\n    uint256 public constant PRECISION = 1e18;\n\n    constructor(uint256 F) {\n        hR = F;\n        hG = F;\n        c = F;\n        rSquared = 2 * F * F; // r^2 = 2 F^2\n    }\n\n    // Babylonian square root\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y &gt; 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x &lt; z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n        return z;\n    }\n\n    // Quote output DeltaG for input DeltaR (buy G, sell R)\n    function quoteG(uint256 deltaR) public view returns (uint256 deltaG) {\n        uint256 newHR = hR + deltaR;\n        uint256 term = rSquared - (newHR - c) * (newHR - c);\n        require(term &gt;= 0, \"Trade exceeds circle\");\n        uint256 sqrtTerm = sqrt(term);\n        deltaG = hG - (c - sqrtTerm);\n        require(deltaG &lt;= hG, \"Insufficient holdings\");\n    }\n\n    // Execute trade (simplified)\n    function swapG(uint256 deltaR) external returns (uint256 deltaG) {\n        deltaG = quoteG(deltaR);\n        hR += deltaR;\n        hG -= deltaG;\n        // Token transfers omitted\n    }\n}\n</code></pre> <p>This uses holdings directly and assumes integer values (scale with PRECISION for decimals).</p>"},{"location":"CircleAmm/#citations","title":"Citations","text":"<ul> <li>Wang, 2020. \"Automated Market Makers Designs for Decentralized Finance.\" arXiv:2009.01676v3. (General ellipse model.)</li> <li>Wang, 2021. \"Implementation Notes on Constant Ellipse based AMMs.\" arXiv:2103.03699v1. (Circle implementation details.)</li> </ul>"},{"location":"CircleAmm2/","title":"Constant Ellipse / Circle Cost-Function AMM","text":"<p>This page documents a constant-ellipse cost-function market maker (and its symmetric circle special case), and shows how to implement it as an AMM. We provide the general \\(n\\)-asset form and the binary specialization in terms of live balances \\(h_R,h_G\\). All formulas here are fee-free (pure mechanics).</p>"},{"location":"CircleAmm2/#references","title":"References","text":"<ul> <li>Yunhao Wang (2020) \u2014 Automated Market Makers for Decentralized Finance (DeFi), arXiv:2009.01676.   Introduces the constant ellipse family, compares to LMSR and constant-product, and discusses convexity &amp; implementation.</li> <li>Yunhao Wang (2021) \u2014 Implementing Automated Market Makers with Constant Ellipse / Circle, arXiv:2103.03699.   Presents two concrete implementations (\u201cApproach I: invariant with scaling\u201d and \u201cApproach II: cost-function form\u201d), swap equations, and parameterization.</li> </ul>"},{"location":"CircleAmm2/#1-elliptical-cost-function-general-n-assets","title":"1) Elliptical Cost Function (General \\(n\\) Assets)","text":"<p>Let \\(q=(q_1,\\dots,q_n)\\) be the inventory vector for \\(n\\) outcome tokens (or assets). The constant-ellipse quadratic cost potential is</p> \\[ \\boxed{C(q)\\;=\\;\\sum_{i=1}^{n} (q_i-a)^2\\;+\\;b\\!\\!\\sum_{i\\ne j}\\! q_i q_j} \\] <p>with real constants \\(a,b\\). This defines a convex (on the chosen branch) cost surface whose differences price block trades in USDC:</p> \\[ \\text{Cost to move } q \\to q' \\;=\\; C(q')-C(q)\\,. \\]"},{"location":"CircleAmm2/#instantaneous-cash-price","title":"Instantaneous (cash) price","text":"<p>The marginal (instantaneous) price of asset \\(i\\) is</p> \\[ \\boxed{P_i(q)\\;=\\;\\frac{\\partial C}{\\partial q_i}\\;=\\;2\\,(q_i-a)\\;+\\;b\\sum_{j\\ne i} q_j}\\,. \\] <p>(If you want probability-like quotes that sum to 1, normalize: \\(\\pi_i(q)=P_i(q)/\\sum_j P_j(q)\\).)</p>"},{"location":"CircleAmm2/#convexity-sketch","title":"Convexity (sketch)","text":"<p>The Hessian is \\(H = 2I + b(\\mathbf{1}\\mathbf{1}^\\top - I)\\). For \\(n{=}2\\), positive semidefinite if \\(-2\\le b\\le 2\\). In practice you select the convex branch (see Wang 2020/2021).</p>"},{"location":"CircleAmm2/#block-trade-exact-buy-q-of-asset-k","title":"Block trade (exact) \u2014 buy \\(Q\\) of asset \\(k\\)","text":"<p>Hold all other coordinates fixed and increase \\(q_k \\mapsto q_k+Q\\). The exact block cost is</p> \\[ \\boxed{D_k(Q)\\;=\\;C(q+Q e_k)-C(q)\\;=\\;Q^2\\;+\\;\\Big(2(q_k-a)+b\\!\\!\\sum_{j\\ne k}\\!q_j\\Big)\\,Q} \\] <p>Let [ B_k := 2(q_k-a)+b\\sum_{j\\ne k} q_j\\,. ]</p> <p>Given a spend \\(D\\), the quantity is the non-negative root</p> \\[ \\boxed{Q_k(D)\\;=\\;\\frac{-B_k+\\sqrt{B_k^2+4D}}{2}}\\,. \\] <p>These are add/mul plus one square root (no exp/log), which is why the model is gas-cheap.</p>"},{"location":"CircleAmm2/#2-circle-implementation-symmetric-ellipse","title":"2) Circle Implementation (Symmetric Ellipse)","text":"<p>The circle is the symmetric special case. Wang describes two equivalent realizations.</p>"},{"location":"CircleAmm2/#a-invariant-form-approach-i","title":"(A) Invariant form (Approach I)","text":"<p>Introduce a scaling \\(\\mu&gt;0\\) and keep the (scaled) reserves on a fixed circle</p> \\[ \\boxed{(\\mu x-c)^2+(\\mu y-c)^2=r^2}\\,,\\qquad \\mu x&lt;c,\\;\\mu y&lt;c, \\] <p>where \\(x,y\\) are the live reserves of the two tokens. The instantaneous exchange rate (tangent slope) on the lower-left arc is</p> \\[ \\boxed{\\frac{d(\\mu y)}{d(\\mu x)}\\;=\\;-\\frac{c-\\mu x}{c-\\mu y}} \\quad\\Longrightarrow\\quad \\text{rate (out per in)}=\\frac{c-\\mu x}{c-\\mu y}\\,. \\] <p>A finite update \\(x\\to x'=x+\\Delta x\\) is obtained by projecting back to the circle:</p> \\[ \\boxed{y'\\;=\\;c\\;-\\;\\frac{1}{\\mu}\\sqrt{\\,r^2-(\\mu x'-c)^2\\,}},\\qquad \\Delta y := y-y'\\,. \\] <p>(Choose the lower-left branch to keep \u201csupply\u2191 \u21d2 price\u2191\u201d behavior.)</p>"},{"location":"CircleAmm2/#b-cost-function-form-approach-ii","title":"(B) Cost-function form (Approach II)","text":"<p>Alternatively, represent the circle as a cost:</p> \\[ \\boxed{C(x,y)=(x-c)^2+(y-c)^2}\\,, \\] <p>so spot prices are marginals \\(P_x=2(x-c)\\), \\(P_y=2(y-c)\\), and block trade costs are \\(C(\\text{after})-C(\\text{before})\\). This approach is algebraically simple, fully path-independent, and symmetric.</p>"},{"location":"CircleAmm2/#3-amm-realization-with-balances","title":"3) AMM Realization with Balances","text":"<p>Two versions: general \\(n\\)-asset ellipse and the binary specialization.</p>"},{"location":"CircleAmm2/#31-general-n-asset-ellipse-amm","title":"3.1 General \\(n\\)-asset ellipse AMM","text":"<ul> <li>State: live inventories \\(q=(q_1,\\dots,q_n)\\).</li> <li>Cost: \\(C(q)=\\sum_i (q_i-a)^2 + b\\sum_{i\\ne j} q_i q_j\\).</li> <li>Spot (cash) prices: \\(P_i(q)=2(q_i-a)+b\\sum_{j\\ne i}q_j\\).</li> <li>Block trade costs: as in \u00a71, \\(D_k(Q)=Q^2+B_k Q\\) with \\(B_k=2(q_k-a)+b\\sum_{j\\ne k}q_j\\).</li> <li>Inverse (spend\u2192quantity): \\(Q_k(D)=(-B_k+\\sqrt{B_k^2+4D})/2\\).</li> <li>Optional probability quotes: \\(\\pi_i=P_i/\\sum_j P_j\\).</li> <li>Path independence: any sequence of trades with the same start/end state costs \\(C(\\text{end})-C(\\text{start})\\).</li> </ul>"},{"location":"CircleAmm2/#32-binary-specialization-balances-h_rh_g","title":"3.2 Binary specialization (balances \\(h_R,h_G\\))","text":"<p>Identify \\(x=h_R\\), \\(y=h_G\\). Using the ellipse cost</p> \\[ \\boxed{C(h_R,h_G)=(h_R-a)^2+(h_G-a)^2 + b\\,h_R h_G}\\,, \\] <p>the spot (cash) prices are</p> \\[ \\boxed{P_R(h_R,h_G)=2(h_R-a)+b\\,h_G}\\,,\\qquad \\boxed{P_G(h_R,h_G)=2(h_G-a)+b\\,h_R}\\,. \\] <ul> <li>Buy \\(Q\\) Red (hold \\(h_G\\) fixed):</li> </ul> \\[ \\boxed{D_R(Q)=Q^2+\\big(2(h_R-a)+b\\,h_G\\big)\\,Q}\\,, \\qquad \\boxed{Q_R(D)=\\frac{-B+\\sqrt{B^2+4D}}{2}},\\;\\;B:=2(h_R-a)+b\\,h_G\\,. \\] <ul> <li> <p>Buy \\(Q\\) Green: swap \\(h_R \\leftrightarrow h_G\\).</p> </li> <li> <p>Optional complementary prices: if you need \\(p_R+p_G=1\\), [ p_R=\\frac{P_R}{P_R+P_G}\\,,\\qquad p_G=1-p_R\\,. ]</p> </li> </ul>"},{"location":"CircleAmm2/#33-binary-circle-perfect-symmetry","title":"3.3 Binary circle (perfect symmetry)","text":"<ul> <li> <p>Approach I (invariant):   [   (\\mu h_R-c)^2+(\\mu h_G-c)^2=r^2,\\quad   \\frac{d(\\mu h_G)}{d(\\mu h_R)}= -\\frac{c-\\mu h_R}{c-\\mu h_G},\\quad   h_G' = c - \\frac{1}{\\mu}\\sqrt{r^2-(\\mu h_R'-c)^2}.   ]</p> </li> <li> <p>Approach II (cost):   [   C(h_R,h_G)=(h_R-c)^2+(h_G-c)^2,\\quad   P_R=2(h_R-c),\\;P_G=2(h_G-c),\\quad   D = C(\\text{after})-C(\\text{before}).   ]</p> </li> </ul> <p>Both are algebraically simple, path-independent, and symmetric in \\(R/G\\).</p>"},{"location":"CircleAmm2/#notes-on-parameters","title":"Notes on Parameters","text":"<ul> <li>Ellipse \\((a,b)\\): \\(a\\) sets the \u201ccenter\u201d of inventory; \\(b\\) couples the assets (tilt/curvature). For \\(n{=}2\\), convex if \\(-2\\le b\\le 2\\). Choose the convex branch.</li> <li>Circle \\((c,r)\\):   Choose \\(c,r\\) so your genesis point lies on the lower-left arc. Approach I uses \\((c,r,\\mu)\\) and keeps \\((\\mu x,\\mu y)\\) on the circle; Approach II uses \\((c,r)\\) via a cost.</li> </ul> <p>All formulas above assume no fees. To add fees later, apply them to the user\u2019s input or output and keep pricing on the fee-free state transition; the path-independence of \\(C\\) is preserved.</p>"},{"location":"LMSR/","title":"Logarithmic Market Scoring Rule (LMSR) for Binary Prediction Markets","text":""},{"location":"LMSR/#introduction","title":"Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), developed by Robin Hanson, is a pricing mechanism for binary prediction markets with two outcomes (Yes or No, e.g., \"Will it rain?\"). It ensures traders can buy or sell shares anytime, with prices reflecting probabilities that sum to 100%. LMSR provides continuous liquidity and limits the market maker's financial risk while aggregating trader beliefs into accurate forecasts.</p>"},{"location":"LMSR/#key-terms-and-formulas","title":"Key Terms and Formulas","text":"<ul> <li>Yes Shares (\\(q_Y\\)): Total Yes shares held by users</li> <li>No Shares (\\(q_N\\)): Total No shares held by users</li> <li>Liquidity Parameter (\\(b\\)): A constant (e.g., 1000) set at market creation, controlling price sensitivity. Higher \\(b\\) means less price movement per trade, creating a deeper market.</li> <li>Maximum Liability: The market maker's worst-case loss, equal to \\(b \\cdot \\ln(2) \\approx 0.693b\\). For \\(b = 1000\\), max liability is \u2248 $693</li> <li>Cost Function (\\(C\\)): Tracks the total USDC committed to reach the current share distribution (\\(q_Y\\), \\(q_N\\)) and includes the liability of the AMM. </li> </ul> <p>The system's value excluding AMM liability is:</p> <p>$$ \\text{System Value} = C(q_Y, q_N) - C(0,0) $$</p> <p>where:</p> <p>$$ C(q_Y, q_N) = b \\cdot \\ln(e^{q_Y / b} + e^{q_N / b}) $$</p> <p>At \\(q_Y = q_N = 0\\), \\(C(0,0) = b \\cdot \\ln(2) \\approx 0.693b\\), the baseline equal to the maximum liability, setting fair initial prices.</p> <ul> <li> <p>Price of Yes (\\(p_Y\\)): Marginal cost of one additional Yes share for a user, defined as the partial derivative of the cost function with respect to \\(q_Y\\):   $$ p_Y = \\frac{\\partial C}{\\partial q_Y} = \\frac{e^{q_Y / b}}{e^{q_Y / b} + e^{q_N / b}} $$</p> </li> <li> <p>Price of No (\\(p_N\\)): Marginal cost of one additional No share for a user, defined as the partial derivative of the cost function with respect to \\(q_N\\):   $$ p_N = \\frac{\\partial C}{\\partial q_N} = \\frac{e^{q_N / b}}{e^{q_Y / b} + e^{q_N / b}} $$</p> </li> <li> <p>Complementary Pricing: \\(p_Y + p_N = 1\\)</p> </li> <li>Trade Cost: Cost of buying \\(\\Delta\\) Yes shares:</li> </ul> <p>$$ \\text{Cost} = C(q_Y + \\Delta, q_N) - C(q_Y, q_N) $$</p>"},{"location":"LMSR2/","title":"Logarithmic Market Scoring Rule (LMSR) for Binary Prediction Markets with Token Pair Minting","text":""},{"location":"LMSR2/#introduction","title":"Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), developed by Robin Hanson, is adapted here for a binary prediction market with two outcomes (Yes or No, e.g., \"Will it rain?\"). This version simplifies computations by minting Yes/No token pairs from the contract's funds, ensuring prices reflect probabilities summing to 100%. The contract is funded with its maximum liability, and tokens are minted dynamically to maintain liquidity while capping risk.</p>"},{"location":"LMSR2/#key-terms-and-concepts","title":"Key Terms and Concepts","text":"<ul> <li>Yes Shares (\\(q_Y\\)): Total Yes tokens held by users.</li> <li>No Shares (\\(q_N\\)): Total No tokens held by users.</li> <li>Contract Holdings (\\(h_Y\\), \\(h_N\\)): Yes and No tokens held by the contract, used to calculate prices and trade amounts.</li> <li>Liquidity Parameter (\\(b\\)): A constant (e.g., 1000) set at market creation, controlling price sensitivity. Higher \\(b\\) means less price movement per trade, creating a deeper market.</li> <li>Maximum Liability: The market maker's worst-case loss, funded upfront as \\(b \\cdot \\ln(2) \\approx 0.693b\\). For \\(b = 1000\\), max liability is \u2248 $693 USDC.</li> <li>System Value: The total USDC value of user-held tokens, derived from the contract's token holdings.</li> <li>Price Calculation: Prices are derived from the contract's holdings (\\(h_Y\\), \\(h_N\\)), ensuring computational simplicity and real-time updates.</li> </ul>"},{"location":"LMSR2/#mechanism","title":"Mechanism","text":"<p>The contract is initialized with \\(q_Y = q_N = 0\\), \\(h_Y = h_N = b\\), and funded with \\(b \\cdot \\ln(2)\\) USDC. Prices start at \\(p_Y = p_N = 0.5\\). When a user deposits USDC, the contract: 1. Mints equal Yes/No token pairs using its funds. 2. Sells the requested token type (Yes or No) to the user at a price derived from the updated holdings. 3. Adjusts \\(h_Y\\) and \\(h_N\\) based on the trade.</p>"},{"location":"LMSR2/#price-formulas","title":"Price Formulas","text":"<p>Prices are calculated based on the contract\u2019s token holdings: - Price of Yes (\\(p_Y\\)):   $$ p_Y = \\frac{h_N}{h_Y + h_N} $$ - Price of No (\\(p_N\\)):   $$ p_N = \\frac{h_Y}{h_Y + h_N} $$ - Complementary Pricing: \\(p_Y + p_N = 1\\), ensuring probability summation.</p>"},{"location":"LMSR2/#trade-process","title":"Trade Process","text":"<ul> <li>User Deposit: A user deposits \\(d\\) USDC to buy Yes or No tokens.</li> <li>Pair Minting: The contract mints \\(m\\) pairs of Yes/No tokens, where \\(m\\) is determined by the deposited USDC and current prices, ensuring the contract\u2019s liability remains within \\(b \\cdot \\ln(2)\\).</li> <li>Token Sale: The contract sells the requested tokens (e.g., \\(\\Delta\\) Yes tokens) to the user, updating \\(h_Y\\) and \\(h_N\\).</li> <li>Cost Calculation: The cost is the USDC spent (\\(d\\)), and the number of tokens received is based on the price at the time of the trade:   $$ \\Delta = \\frac{d}{p_Y} \\text{ (for Yes tokens)} \\text{ or } \\frac{d}{p_N} \\text{ (for No tokens)} $$</li> <li>Holdings Update: For \\(\\Delta\\) Yes tokens sold, \\(h_Y \\gets h_Y - \\Delta\\), \\(h_N \\gets h_N + \\Delta\\) (since pairs are minted).</li> </ul>"},{"location":"LMSR2/#liquidity-adjustment","title":"Liquidity Adjustment","text":"<p>The contract can increase liquidity by adding more USDC (increasing \\(b\\)) and minting additional Yes/No token pairs, proportionally increasing \\(h_Y\\) and \\(h_N\\). This maintains price stability and ensures the liability cap scales with \\(b \\cdot \\ln(2)\\).</p>"},{"location":"LMSR2/#example","title":"Example","text":"<p>For \\(b = 1000\\), initial state: \\(q_Y = q_N = 0\\), \\(h_Y = h_N = 1000\\), \\(p_Y = p_N = 0.5\\), contract funded with \u2248 \\(693.15 USDC. A user deposits 9.85 USDC to buy Yes tokens: - Contract mints \\(m\\) Yes/No pairs (e.g., \\(m = 10\\), adding 10 Yes and 10 No tokens, costing \u2248 (10 USDC at \\(p_Y = 0.5\\)). - Sells \u2248 19.7 Yes tokens (\\)9.85 / 0.5\\)) to the user. - Updates: \\(h_Y = 1000 - 19.7 = 980.3\\), \\(h_N = 1000 + 10 = 1010\\). - New prices: \\(p_Y = \\frac{1010}{980.3 + 1010} \\approx 0.507\\), \\(p_N = \\frac{980.3}{980.3 + 1010} \\approx 0.493\\). - System Value: Value of user-held tokens (19.7 Yes tokens at \\(p_Y \\approx 0.507\\)) \u2248 $9.85 USDC.</p>"},{"location":"LMSR2/#advantages","title":"Advantages","text":"<ul> <li>Simplified Computation: Prices are derived from token holdings (\\(h_Y\\), \\(h_N\\)), avoiding complex logarithmic calculations in real-time.</li> <li>Dynamic Liquidity: Minting pairs ensures continuous trading and allows liquidity increases without disrupting prices.</li> <li>Capped Risk: The contract\u2019s liability is always funded upfront at \\(b \\cdot \\ln(2)\\), ensuring no excess loss.</li> <li>Scalability: Liquidity can be increased by adding USDC and minting more pairs, adjusting \\(b\\) dynamically.</li> </ul>"},{"location":"LMSR2/#conclusion","title":"Conclusion","text":"<p>This LMSR variant uses token pair minting to simplify pricing and maintain liquidity in binary prediction markets. By calculating prices from contract holdings, it reduces computational overhead while ensuring fair pricing and capped risk at \\(b \\cdot \\ln(2)\\). The system value reflects trader investment, making it suitable for decentralized prediction markets.</p>"},{"location":"LMSR3/","title":"LSRM for Uniswap v4","text":""},{"location":"LMSR3/#1-introduction","title":"1. Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), introduced by Robin Hanson in 2003 (see: Combinatorial Information Market Design), is a market-making mechanism widely used in prediction markets.  </p> <p>This document adapts LMSR into a System Liquidity Provider (SLP) designed for use with Uniswap v4, where the SLP sits behind two liquidity pools(with no liquidity) as a hook called with every transaction.</p> <p>Features of the Uniswap v4 SLP</p> <ul> <li>Defined Risk</li> <li>Determinate Price</li> <li>Integrated complementary pricing between two pools</li> <li>Integrates with liquidity provided in any additional pools</li> <li>Easily add additional liquidity</li> </ul>"},{"location":"LMSR3/#2-key-concepts","title":"2. Key Concepts","text":"<ul> <li>Red Tokens (\\(R\\)): Represent one side of a binary market.</li> <li>Green Tokens (\\(G\\)): Represent the other side of a binary market.</li> <li>Holdings (\\(h_R, h_G\\)): Balances of Red and Green held by the market contract.</li> <li>Pairs: Always minted as 1 Red + 1 Green when USDC enters the system.</li> <li>Spot Price: Determined directly from holdings:</li> </ul> <p>$$   p_R = \\frac{h_G}{h_R + h_G}, \\quad p_G = \\frac{h_R}{h_R + h_G}   $$</p> <p>Prices are always complementary:</p> <p>$$   p_R + p_G = 1   $$</p>"},{"location":"LMSR3/#3-contract-roles","title":"3. Contract Roles","text":""},{"location":"LMSR3/#system-liquidity-provider-slp","title":"System Liquidity Provider (SLP)","text":"<ul> <li>Acts as the interface for traders to swap to and from USDC to market tokens.</li> <li>Holds Red and Green tokens as inventory.</li> <li>Computes trade amounts and transfers Red or Green tokens to traders based on the cost function.</li> </ul>"},{"location":"LMSR3/#market-controller","title":"Market Controller","text":"<ul> <li>Manages the Red ERC20 Contract and Green ERC20 Contract.</li> <li>Custodies vUSDC received from the Treasury for internal accounting.</li> <li>Mints Red and Green token pairs on deposits and sends them to the SLP.</li> <li>Burns Red and Green token pairs on redemptions and redeems vUSDC for USDC from treasury.</li> </ul>"},{"location":"LMSR3/#red-erc20-contract","title":"Red ERC20 Contract","text":"<ul> <li>Standard ERC20 contract representing Red tokens.</li> <li>Controlled by the Market Controller for minting and burning.</li> </ul>"},{"location":"LMSR3/#green-erc20-contract","title":"Green ERC20 Contract","text":"<ul> <li>Standard ERC20 contract representing Green tokens.</li> <li>Controlled by the Market Controller for minting and burning.</li> </ul>"},{"location":"LMSR3/#treasury-vusdc-controller","title":"Treasury (vUSDC controller)","text":"<ul> <li>Custodies all USDC, depositing it into Aave to earn yield (aUSDC).</li> <li>Mints vUSDC via the vUSDC Contract to track deposited USDC.</li> <li>Sends vUSDC to the Market Controller during the USDC and token flow routine.</li> <li>Handles withdrawals from Aave when redemptions occur.</li> </ul>"},{"location":"LMSR3/#vusdc-contract","title":"vUSDC Contract","text":"<ul> <li>Receipt token held by the Market Controller to facilitate internal accounting of USDC deposited in Aave.</li> <li>Minted and managed by the Treasury.</li> <li>Pegged 1:1 to USDC.</li> </ul>"},{"location":"LMSR3/#4-token-flow-implementation-with-easy-accounting-and-auditing","title":"4. Token Flow implementation with easy accounting and auditing","text":""},{"location":"LMSR3/#41-usdc-and-token-flow-routine","title":"4.1 USDC and Token Flow Routine","text":"<p>This routine describes how USDC moves up the chain and how vUSDC and token pairs move down:</p>"},{"location":"LMSR3/#usdc-upward-flow","title":"USDC Upward Flow","text":"<ul> <li>USDC is sent from the caller (market initiator or trader) to the SLP.</li> <li>SLP forwards the USDC to the Market Controller.</li> <li>Market Controller sends the USDC to the Treasury.</li> <li>Treasury deposits the USDC into Aave, receiving aUSDC (yield-bearing).</li> </ul>"},{"location":"LMSR3/#vusdc-and-token-pairs-downward-flow","title":"vUSDC and Token Pairs Downward Flow","text":"<ul> <li>Treasury mints vUSDC (a receipt token pegged 1:1 to USDC) via the vUSDC Contract and sends it to the Market Controller.</li> <li>Market Controller retains vUSDC for internal accounting and mints an equal amount of Red and Green token pairs via the Red ERC20 Contract and Green ERC20 Contract.</li> <li>Market Controller sends the Red and Green token pairs to the SLP.</li> <li>SLP holds the token pairs as inventory for trading.</li> </ul> <p>This routine ensures that all USDC is custodied in Aave and receipts are passed down the chain.</p>"},{"location":"LMSR3/#42-market-initiation-sequence","title":"4.2 Market Initiation Sequence","text":"<p>The market is initialized with an initial funding amount to bootstrap liquidity:</p> <ol> <li>The SLP is called with an <code>initialFund(uint)</code> function, specifying the initial USDC amount.</li> <li>The SLP pulls the specified USDC from the caller.</li> <li>The USDC and token flow routine is executed:<ul> <li>USDC is sent from SLP to Market Controller, then to Treasury, and deposited into Aave.</li> <li>Treasury mints vUSDC and sends it to the Market Controller.</li> <li>Market Controller mints Red and Green token pairs and sends them to the SLP.</li> </ul> </li> <li>The SLP is now initiated with Red and Green tokens in its inventory, ready for trading.</li> </ol>"},{"location":"LMSR3/#43-trading-sequence","title":"4.3 Trading Sequence","text":"<p>When a trader deposits \\(D\\) USDC to trade:</p> <ol> <li>The trader sends \\(D\\) USDC to the SLP.</li> <li>The USDC and token flow routine is executed:<ul> <li>USDC is sent from SLP to Market Controller, then to Treasury, and deposited into Aave.</li> <li>Treasury mints \\(D\\) vUSDC and sends it to the Market Controller.</li> <li>Market Controller mints \\(D\\) Red and \\(D\\) Green tokens and sends them to the SLP.</li> </ul> </li> <li>The SLP computes the number of Red (or Green) tokens to send to the trader using the cost function.</li> <li>Remaining tokens are left in the SLP\u2019s inventory, ensuring balances match the pricing function.</li> </ol> <p>This guarantees:</p> <ul> <li>Path invariance: Immediate deposit/withdraw cycles return the same USDC.  </li> <li>Finite liability: The Market Controller always has sufficient reserves.  </li> <li>Determinate state: Prices depend only on holdings. </li> <li>Auditable: Values of each contract clear.</li> </ul>"},{"location":"LMSR3/#5-pricing-and-trade-math-with-derivation","title":"5. Pricing and Trade Math (with Derivation)","text":"<p>We\u2019ll use Red (R) and Green (G) as the two sides of the market.</p> <p>SLP Starting Red Balance</p> \\[ h_R \\] <p>SLP Starting Green Balance</p> \\[ h_G \\] <p>Red Price</p> \\[ p_R = \\frac{h_G}{h_R + h_G}, \\] <p>Green Price</p> \\[ p_G = \\frac{h_R}{h_R + h_G}, \\] <p>Combined Price Invariant</p> \\[ p_R + p_G = 1. \\] <p>When a user buys Red with a deposit of \\(D\\) USDC, the SLP uses the USDC to mint \\(D\\) new pairs:</p> <p>SLP Post-Mint Red Balance</p> \\[ h_R' = h_R + D, \\] <p>SLP Post-Mint Green Balance</p> \\[ h_G' = h_G + D, \\] <p>SLP Post-Mint Combined Token Balance</p> \\[ S = h_R' + h_G' = (h_R + D) + (h_G + D). \\]"},{"location":"LMSR3/#step-1-marginal-price-curve","title":"Step 1. Marginal price curve","text":"<p>The instantaneous (marginal) price of Red, when selling \\(q\\) units from inventory, is given by:</p> \\[ p_R(q) = \\frac{h_G'}{S - q} \\] <p>where:</p> <ul> <li>\\(h_G' = h_G + D\\) (post-mint Green)  </li> <li>\\(S = h_R + h_G + 2D\\) (post-mint total)</li> </ul>"},{"location":"LMSR3/#step-2-total-spend","title":"Step 2. Total spend","text":"<p>To compute the total spend for buying \\(Q\\) Red tokens, integrate the marginal price along the fill path:</p> \\[ D(Q) = \\int_{0}^{Q} p_R(q)\\,dq \\] \\[ D(Q) = \\int_{0}^{Q} \\frac{h_G'}{S - q}\\,dq \\] \\[ D(Q) = -\\,h_G' \\cdot \\ln(S - q)\\;\\Big|_{0}^{Q} \\] \\[ D(Q) = h_G' \\cdot \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] <p>Expanding in terms of the initial balances:</p> \\[ D(Q) = (h_G + D) \\cdot \\ln\\!\\left(\\frac{\\,h_R + h_G + 2D\\,}{\\,h_R + h_G + 2D - Q\\,}\\right) \\]"},{"location":"LMSR3/#step-3-tokens-as-a-function-of-spend","title":"Step 3. Tokens as a function of spend","text":"<p>We now invert the above relation to solve for \\(Q\\) in terms of \\(D\\):</p> \\[ D(Q) = h_G' \\cdot \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ \\frac{D(Q)}{h_G'} = \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ e^{-D(Q)/h_G'} = \\frac{S - Q}{S} \\] \\[ Q(D) = S \\cdot \\left(1 - e^{-D/h_G'}\\right) \\] <p>with the natural restriction</p> \\[ 0 &lt; Q &lt; h_R' \\] <p>Substituting the intial variables gives</p> \\[ Q(D) = \\big(h_R + h_G + 2D\\big) \\cdot \\left(1 - e^{-\\,D/(h_G + D)}\\right) \\]"},{"location":"LMSR4/","title":"LSRM System Liquidity Provider (SLP)","text":""},{"location":"LMSR4/#1-introduction","title":"1. Introduction","text":"<p>The Logarithmic Market Scoring Rule (LMSR), introduced by Robin Hanson in 2003 (Combinatorial Information Market Design), is a market-making mechanism which is used in some prediction markets.  </p> <p>This document adapts LMSR into a System Liquidity Provider (SLP), where the SLP is the a liquidity source for two complementary tokens (Red and Green). </p> <p>The SLP mints new token pairs, prices them deterministically based on its inventory.</p> <p>The SLP is designed to feature as part of a Uniswap V4 hook, so it can dovetail with additional liquidity pools, and give a defined complementary price of Red and Green tokens.</p> <p>This document considers markets as binary, but there are no doubt extensions that can be made for multi directional markets.</p> <p>Features of the SLP:</p> <ul> <li>Defined maximum liability  </li> <li>Deterministic, path-invariant pricing  </li> <li>Complementary pricing between Red and Green  </li> <li>Simple accounting and auditable state  </li> </ul>"},{"location":"LMSR4/#2-key-concepts","title":"2. Key Concepts","text":"<ul> <li>Red Tokens (\\(R\\)): Represent one side of a binary market.  </li> <li>Green Tokens (\\(G\\)): Represent the other side.  </li> <li>Holdings (\\(h_R, h_G\\)): Balances of Red and Green held by the SLP.  </li> <li>Pairs: Always minted as 1 Red + 1 Green when USDC enters.  </li> <li>Spot Price: Determined directly from holdings:</li> </ul> <p>$$   p_R = \\frac{h_G}{h_R + h_G}, \\quad p_G = \\frac{h_R}{h_R + h_G}   $$</p> <p>with the invariant:</p> <p>$$   p_R + p_G = 1   $$</p>"},{"location":"LMSR4/#3-contract-roles","title":"3. Contract Roles","text":""},{"location":"LMSR4/#system-liquidity-provider-slp","title":"System Liquidity Provider (SLP)","text":"<ul> <li>Core AMM logic.  </li> <li>Holds Red and Green inventory.  </li> <li>Mints pairs when USDC is deposited.  </li> <li>Executes trades by selling one side against the other.  </li> <li>Updates balances to maintain deterministic pricing.  </li> </ul>"},{"location":"LMSR4/#red-erc20-contract","title":"Red ERC20 Contract","text":"<ul> <li>Standard ERC20 token for Red.  </li> <li>Minted and burned only by the SLP.  </li> </ul>"},{"location":"LMSR4/#green-erc20-contract","title":"Green ERC20 Contract","text":"<ul> <li>Standard ERC20 token for Green.  </li> <li>Minted and burned only by the SLP.  </li> </ul>"},{"location":"LMSR4/#4-trade-routine","title":"4. Trade Routine","text":""},{"location":"LMSR4/#41-market-initialization","title":"4.1 Market Initialization","text":"<p>An initial USDC deposit mints equal Red and Green tokens.  </p> <p>Example: deposit \\(F\\) USDC  </p> \\[ h_R = F \\] \\[ h_G = F \\] <p>Initial prices are symmetric:  </p> \\[ p_R = p_G = 0.5 \\]"},{"location":"LMSR4/#42-buying-red-with-usdc","title":"4.2 Buying Red with USDC","text":"<p>The trader has \\(D\\) USDC and wants Red tokens.</p> <ol> <li>Inventory preparation (accounting step).    The SLP mints \\(D\\) Red and \\(D\\) Green to itself to set a fixed pricing inventory.</li> </ol> \\[ h_R' = h_R + D \\] \\[ h_G' = h_G + D \\] \\[ S = h_R' + h_G' \\] \\[ S = h_R + h_G + 2D \\] <ol> <li> <p>Trade execution against the fixed inventory.    The trader spends all \\(D\\) to buy \\(Q\\) Red according to the cost function.</p> </li> <li> <p>Post-trade balances.</p> </li> </ol> \\[ h_R = h_R' - Q \\] \\[ h_G = h_G' \\]"},{"location":"LMSR4/#5-deriving-the-cost-function-and-the-quantity-function","title":"5. Deriving the Cost Function and the Quantity Function","text":""},{"location":"LMSR4/#step-1-marginal-price-curve-from-first-principles","title":"Step 1. Marginal price curve (from first principles)","text":"<p>We want to know how the price of Red changes as the user buys red tokens.</p> <p>That is when a user buys Q tokens, what is the price of each unit.</p> <p>That is the price when the SLP has already sold \\(q\\) Red tokens.</p> <ul> <li>The first step of the process is that the SLP mints additional tokens equal to the D USDC which the user is supplying to buy tokens. This now becomes the total inventory S</li> </ul> \\[ S = h_R' + h_G' \\] <ul> <li>If \\(q\\) Red tokens have been sold, the remaining Red inventory is</li> </ul> \\[ h_R' - q \\] <ul> <li>At that point, the total remaining inventory is</li> </ul> \\[ S - q \\] <p>The pricing rule says that the price of Red is equal to the proportion of Green in the remaining inventory:</p> \\[ p_R(q) = \\frac{h_G'}{S - q} \\] \\[ \\lim_{q \\uparrow h_R'} (S - q) = h_G' \\] \\[ \\lim_{q \\uparrow h_R'} p_R(q) = 1 \\]"},{"location":"LMSR4/#step-2-small-quantity-cost","title":"Step 2. Small quantity cost","text":"<p>Now consider buying a tiny quantity \\(\\delta q\\) of Red Tokens. The cost of those tokens is the price of them multiplied by the quantity of them</p> \\[ \\delta D = p_R(q) \\cdot \\delta q \\]"},{"location":"LMSR4/#step-3-quantity-function","title":"Step 3. Quantity Function","text":"<p>Now if we buy a series of small quantities \\(Q\\) of Red tokens, we sum over all increments to find the price:</p> \\[ D(Q) \\approx \\sum \\, p_R(q) \\cdot \\delta q \\]"},{"location":"LMSR4/#step-4-limit-to-an-integral","title":"Step 4. Limit to an integral","text":"<p>As \\(\\delta q \\to 0\\), the sum becomes an integral:</p> \\[ D(Q) = \\int_{0}^{Q} p_R(q)\\,dq \\] \\[ D(Q) = \\int_{0}^{Q} \\frac{h_G'}{S - q}\\,dq \\]"},{"location":"LMSR4/#step-5-evaluate-the-integral","title":"Step 5. Evaluate the integral","text":"\\[ D(Q) = -\\,h_G' \\cdot \\ln(S - q)\\;\\Big|_{0}^{Q} \\] \\[ D(Q) = h_G' \\cdot \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] <p>Substituting for initial varibles</p> \\[ D(Q) = (h_G + D) \\cdot \\ln\\!\\left(\\frac{\\,h_R + h_G + 2D\\,}{\\,h_R + h_G + 2D - Q\\,}\\right) \\]"},{"location":"LMSR4/#step-3-tokens-as-a-function-of-spend","title":"Step 3. Tokens as a function of spend","text":"<p>Invert to solve for \\(Q\\):</p> \\[ \\frac{D(Q)}{h_G'} = \\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ e^{-D(Q)/h_G'} = \\frac{S - Q}{S} \\] \\[ Q(D) = S \\cdot \\left(1 - e^{-D/h_G'}\\right) \\] <p>Restriction:</p> \\[ 0 &lt; Q &lt; h_R' \\] <p>Substituted form:</p> \\[ Q(D) = \\big(h_R + h_G + 2D\\big) \\cdot \\left(1 - e^{-\\,D/(h_G + D)}\\right) \\]"},{"location":"LMSR4/#6-properties","title":"6. Properties","text":"<ul> <li>Deterministic Pricing: Prices depend only on SLP token holdings.  </li> <li>Finite Liability:  Liability is simply the initial funding of the SLP.</li> <li>Fixed Complementary Pricing: Red and Green always sum to 1.  </li> <li>Path Invariance: Deposit and immediate withdraw returns the same USDC.  </li> </ul>"},{"location":"LMSR4/#7-extending-to-three-position-market","title":"7. Extending to three position market","text":""},{"location":"LMSR4/#71-market-initialization","title":"7.1 Market Initialization","text":"<p>An initial USDC deposit mints equal R G and B tokens.  </p> <p>Example: deposit \\(F\\) USDC  </p> \\[ h_R = F \\] \\[ h_G = F \\] \\[ h_B = F \\] <p>A subsequent user deposit of \\(D\\) USDC mints \\(D\\) of each into SLP inventory.</p> \\[ h_R' = h_R + D \\] \\[ h_G' = h_G + D \\] \\[ h_B' = h_B + D \\] \\[ S = h_R' + h_G' + h_B' \\]"},{"location":"LMSR4/#72-spot-prices-pre-trade","title":"7.2 Spot Prices (pre-trade)","text":"\\[ S_0 = h_R + h_G + h_B \\] \\[ p_R = \\frac{h_G + h_B}{2 S_0} \\] \\[ p_G = \\frac{h_R + h_B}{2 S_0} \\] \\[ p_B = \\frac{h_R + h_G}{2 S_0} \\] \\[ p_R + p_G + p_B = 1 \\]"},{"location":"LMSR4/#73-spot-prices-mid-trade","title":"7.3 Spot Prices (mid-trade)","text":"\\[ S = h_R' + h_G' + h_B' \\] \\[ p_R = \\frac{h_G' + h_B'}{2 S} \\] \\[ p_G = \\frac{h_R' + h_B'}{2 S} \\] \\[ p_B = \\frac{h_R' + h_G'}{2 S} \\] \\[ p_R + p_G + p_B = 1 \\]"},{"location":"LMSR4/#73-buying-r","title":"7.3 Buying \\(R\\)","text":"\\[ p_R(q) = \\frac{h_G' + h_B'}{2\\,(S - q)} \\] \\[ D_R(Q) = \\int_{0}^{Q} p_R(q)\\,dq \\] \\[ D_R(Q) = \\frac{h_G' + h_B'}{2}\\,\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_R(x) = S\\left(1 - e^{-\\,\\frac{2x}{\\,h_G' + h_B'\\,}}\\right) \\] <p>Substituting for initial variables</p> \\[ h_G' + h_B' = h_G + h_B + 2D \\] \\[ S = h_R + h_G + h_B + 3D \\] \\[ D_R(Q) = \\frac{h_G + h_B + 2D}{2}\\,\\ln\\!\\left(\\frac{h_R + h_G + h_B + 3D}{h_R + h_G + h_B + 3D - Q}\\right) \\] \\[ Q_R(x) = \\big(h_R + h_G + h_B + 3D\\big)\\left(1 - e^{-\\,\\frac{2x}{\\,h_G + h_B + 2D\\,}}\\right) \\] <p>By symmetry</p> \\[ D_G(Q) = \\frac{h_R' + h_B'}{2}\\,\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_G(x) = S\\left(1 - e^{-\\,\\frac{2x}{\\,h_R' + h_B'\\,}}\\right) \\] \\[ D_B(Q) = \\frac{h_R' + h_G'}{2}\\,\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_B(x) = S\\left(1 - e^{-\\,\\frac{2x}{\\,h_R' + h_G'\\,}}\\right) \\]"},{"location":"LMSR4/#8-general-n-outcome-market","title":"8. General \\(n\\)-Outcome Market","text":""},{"location":"LMSR4/#81-market-initialization","title":"8.1 Market Initialization","text":"<p>An initial USDC deposit mints equal amounts of all \\(n\\) outcome tokens \\(X_1,\\dots,X_n\\).  </p> <p>Example: deposit \\(F\\) USDC  </p> \\[ h_i = F \\quad \\text{for } i \\in \\{1,\\dots,n\\} \\] <p>A subsequent user deposit of \\(D\\) USDC mints \\(D\\) of each into SLP inventory.</p> \\[ h_i' = h_i + D \\quad \\text{for } i \\in \\{1,\\dots,n\\} \\] \\[ S = \\sum_{i=1}^{n} h_i' \\]"},{"location":"LMSR4/#spot-prices-pre-trade","title":"Spot Prices (pre-trade)","text":"\\[ S_0 = \\sum_{i=1}^{n} h_i \\] \\[ p_i = \\frac{S_0 - h_i}{(n-1)\\,S_0} \\] \\[ \\sum_{i=1}^{n} p_i = 1 \\]"},{"location":"LMSR4/#spot-prices-mid-trade","title":"Spot Prices (mid-trade)","text":"\\[ S = \\sum_{i=1}^{n} h_i' \\] \\[ p_i = \\frac{S - h_i'}{(n-1)\\,S} \\] \\[ \\sum_{i=1}^{n} p_i = 1 \\]"},{"location":"LMSR4/#buying-outcome-k","title":"Buying outcome \\(k\\)","text":"\\[ p_k(q) = \\frac{S - h_k'}{(n-1)\\,(S - q)} \\] \\[ D_k(Q) = \\int_{0}^{Q} p_k(q)\\,dq \\] \\[ D_k(Q) = \\frac{S - h_k'}{\\,n-1\\,}\\;\\ln\\!\\left(\\frac{S}{S - Q}\\right) \\] \\[ Q_k(x) = S\\left(1 - e^{-\\,\\frac{(n-1)\\,x}{\\,S - h_k'\\,}}\\right) \\] <p>Expanded in initial balances</p> \\[ S = \\sum_{i=1}^{n} h_i + nD \\] \\[ S - h_k' = \\sum_{j\\neq k} h_j + (n-1)D \\] \\[ p_k = \\frac{\\sum_{j\\neq k} h_j + (n-1)D}{(n-1)\\left(\\sum_{i=1}^{n} h_i + nD\\right)} \\] \\[ D_k(Q) = \\frac{\\sum_{j\\neq k} h_j + (n-1)D}{\\,n-1\\,}\\;\\ln\\!\\left(\\frac{\\sum_{i=1}^{n} h_i + nD}{\\sum_{i=1}^{n} h_i + nD - Q}\\right) \\] \\[ Q_k(x) = \\left(\\sum_{i=1}^{n} h_i + nD\\right)\\left(1 - \\exp\\!\\left[-\\,\\frac{(n-1)\\,x}{\\sum_{j\\neq k} h_j + (n-1)D}\\right]\\right) \\]"},{"location":"LMSR5/","title":"LMSR5","text":"<pre><code># LMSR System Liquidity Provider (SLP)\n\n## 1. Introduction\nThe **Logarithmic Market Scoring Rule (LMSR)**, introduced by Robin Hanson (2003, *Combinatorial Information Market Design*), is a closed-form automated market-making mechanism. It provides path-independent pricing and bounded liability, and has been used in several real-world prediction markets (e.g. Iowa Electronic Markets, Gnosis).\n\nThis document shows how LMSR is adapted into a **System Liquidity Provider (SLP)** for a **binary market** with two complementary tokens: **Red (R)** and **Green (G)**.\n\nThe SLP is not the market itself. The **Market Controller** handles only *splitting* and *merging*:\n\n- **Split**: 1 USDC \u2192 (1 R + 1 G).  \n- **Merge**: (1 R + 1 G) \u2192 1 USDC.\n\nThe **SLP** sits on top of this controller:\n\n- It acquires tokens from the Market Controller using USDC.  \n- It prices and trades tokens deterministically using LMSR formulas.  \n- It can be deployed as a Uniswap v4 hook, alongside other liquidity sources.\n\n**Key features:**\n\n* Bounded maximum liability.  \n* Deterministic, path-independent pricing.  \n* Complementary prices (\\(p_R + p_G = 1\\)).  \n* Transparent state (balances are auditable).\n\n---\n\n## 2. Key Concepts (Binary Market)\n\n- **Red Tokens (\\(R\\))**: One outcome.  \n- **Green Tokens (\\(G\\))**: The complementary outcome.  \n- **Holdings**:  \n- \\(h_R\\): balance of Red tokens held by the SLP.  \n- \\(h_G\\): balance of Green tokens held by the SLP.  \n- **LMSR Liquidity Parameter (\\(b\\))**: Controls depth of the market and maximum liability.  \n- **Market Controller**: Issues and redeems bundles of \\(R+G\\) against USDC.  \n- **System Liquidity Provider (SLP)**: Uses LMSR maths to trade \\(R\\) and \\(G\\) with users.\n\n---\n\n## 3. Funding &amp; Parameterization\n\n### 3.1 Bounded Loss in LMSR\nHanson proved that in an LMSR with \\(n\\) outcomes, the market maker\u2019s **worst-case loss** is:\n\n\\[\nL_{\\max} = b \\cdot \\ln n.\n\\]\n\nFor a **binary market** (\\(n=2\\)):\n\n\\[\nL_{\\max} = b \\cdot \\ln 2.\n\\]\n\n---\n\n### 3.2 Funding the SLP\nWe assume the SLP begins by providing **\\(F\\) USDC** into the Market Controller. This \\(F\\) is the maximum loss the SLP is willing to risk. Therefore:\n\n\\[\nF = b \\cdot \\ln 2,\n\\]\n\nwhich implies\n\n\\[\nb = \\frac{F}{\\ln 2}.\n\\]\n\n---\n\n### 3.3 Initialization\n1. **Deposit:** SLP deposits \\(F\\) USDC into the Market Controller.  \n2. **Split:** Controller issues \\(F\\) Red + \\(F\\) Green to the SLP.  \n3. **Set \\(b\\):**\n\n\\[\nb = \\tfrac{F}{\\ln 2}.\n\\]\n\n4. **Initial prices:**\n\n\\[\np_R = p_G = 0.5.\n\\]\n\n---\n\n## 4. LMSR Pricing (from Hanson)\n\nThe **LMSR cost function** is:\n\n\\[\nC(h_R, h_G) = b \\cdot \\ln\\!\\left(e^{h_R/b} + e^{h_G/b}\\right).\n\\]\n\n- **Spot price of Red**:\n\n\\[\np_R = \\frac{e^{h_R/b}}{e^{h_R/b} + e^{h_G/b}}\n\\]\n\n- **Spot price of Green**:\n\n\\[\np_G = \\frac{e^{h_G/b}}{e^{h_R/b} + e^{h_G/b}}\n\\]\n\n- Invariant:\n\n\\[\np_R + p_G = 1\n\\]\n\n---\n\n## 5. Trading Logic\n\n### 5.1 Buying Red\n\nThe cost to acquire \\(Q\\) Red tokens is:\n\n\\[\nD(Q) = C(h_R + Q, h_G) - C(h_R, h_G).\n\\]\n\nGiven spend \\(D\\), the number of Red tokens received is:\n\n\\[\nQ(D) = b \\cdot \\ln\\!\\left(\\frac{e^{D/b} - (1 - p_{R,0})}{p_{R,0}}\\right),\n\\]\n\nwhere \\(p_{R,0}\\) is the pre-trade Red price.\n\n**Inventory update:**\n\n\\[\nh_R \\gets h_R + Q(D), \n\\]\n\n\\[\nh_G \\text{ unchanged.}\n\\]\n\n---\n\n### 5.2 Buying Green\n\nBy symmetry:\n\n\\[\nD(Q) = C(h_R, h_G + Q) - C(h_R, h_G).\n\\]\n\n\\[\nQ(D) = b \\cdot \\ln\\!\\left(\\frac{e^{D/b} - (1 - p_{G,0})}{p_{G,0}}\\right).\n\\]\n\n**Inventory update:**\n\n\\[\nh_G \\gets h_G + Q(D).\n\\]\n\n---\n\n## 6. Merge and Split Logic\n\n- **Split (Controller)**: Trader deposits USDC \u2192 Controller issues (1 R + 1 G).  \n- The SLP may use this to increase inventory before trading.\n\n- **Merge (Controller)**: Trader returns (1 R + 1 G) \u2192 Controller redeems 1 USDC.  \n- Provides a canonical redemption path.  \n- Ensures outcome tokens cannot inflate unchecked.\n\n---\n\n## 7. Properties\n\n- **Bounded loss:** Worst-case liability is exactly the initial funding \\(F\\).  \n- **No idle USDC in SLP:** All USDC sits in the Market Controller, convertible through split/merge.  \n- **Composable:** SLP is just one LP \u2014 others may coexist.  \n- **Deterministic:** Prices depend only on \\((h_R,h_G)\\).\n\n---\n\n## 8. Summary\n- Market Controller: only split/merge, dumb and neutral.  \n- SLP: applies LMSR maths, provides deterministic liquidity.  \n- Funding \\(F\\) defines liquidity parameter \\(b\\).  \n- Binary market: Red + Green with complementary pricing.\n</code></pre>"},{"location":"PredictionPerps/","title":"What are Prediction Perps","text":""},{"location":"PredictionPerps/#introduction","title":"Introduction","text":"<ul> <li>Prediction Perps are a new DeFi asset class which revolutionizes prediction markets.</li> <li>Central to Prediction Perps is our native yield-bearing stablecoin ppUSDC.</li> </ul>"},{"location":"PredictionPerps/#yield-bearing-stablecoin-explained","title":"Yield-Bearing Stablecoin Explained","text":"<ul> <li>What is ppUSDC? ppUSDC is a stablecoin pegged 1:1 to USDC, functioning exactly like Aave\u2019s aUSDC.</li> <li>How does it generate yield? USDC is deposited into DeFi protocols, like Aave, which lend it out to borrowers, earning interest.</li> <li>Automatic growth: This interest is automatically passed to ppUSDC holders, increasing their balance over time without any active management.</li> <li>Creation and burning: New ppUSDC is created when USDC is deposited and burnt when USDC is withdrawn, mirroring aUSDC\u2019s mechanics.</li> </ul>"},{"location":"PredictionPerps/#predictionperps-mechanism","title":"PredictionPerps Mechanism","text":"<ul> <li>Splitting USDC: 1 ppUSDC can be split into 1 red and 1 green share for various markets. Equally, 1 red and 1 green share from any market can be joined to form 1 ppUSDC.</li> <li>Red and green shares: These pairs represent opposing positions, for example, a bullish (green) or bearish (red) stance on a football team\u2019s performance.</li> <li>Comparison to other systems: This functionality is similar to Polymarket\u2019s use of the Gnosis Conditional Token Framework, but designed for perpetual markets.</li> <li>Yield distribution: When ppUSDC is split into green and red shares for a specific market, the yield is split between the green and red shares.</li> <li>Market-specific rubrics: Each market has a rubric for splitting the interest between the green and red tokens according to various conditions.</li> <li>Example: In a football team performance market, wins increase the share of interest on the green side, while losses increase the share of interest on the red side.</li> </ul>"},{"location":"PredictionPerps/#decentralisation","title":"Decentralisation","text":"<ul> <li>Decentralised protocol: PredictionPerps operates without centralised control, enabling its tokens (ppUSDC, red, and green shares) to be used across the DeFi ecosystem.</li> <li>Interoperability: Tokens can integrate with various DeFi platforms, ensuring flexibility and accessibility for users.</li> </ul>"},{"location":"PredictionPerps/#liquidity-provision","title":"Liquidity Provision","text":"<ul> <li>Liquidity pools: PredictionPerps creates pools to support trading of red and green shares, with rewards distributed to staked liquidity provider (LP) tokens.</li> <li>Yield delegation: The applicable yield from the pools is delegated to the LP staking contract to prevent price drift.</li> <li>Uniswap V2: Initial liquidity is provided through Uniswap V2, with rewards split among staked LP token holders.</li> <li>Future scalability: Similar strategies will be implemented for Uniswap V3 and V4, optimizing liquidity provision and reward distribution.</li> </ul>"},{"location":"PredictionPerps/#liquidity-rewards","title":"Liquidity Rewards","text":"<ul> <li>Pool fees: Liquidity providers earn 0.3% trading fees from Uniswap V2 pools for facilitating red and green share trades.</li> <li>Yield from positions: Providers receive yield from ppUSDC and red/green shares held in the liquidity pools, distributed through the LP staking contract.</li> <li>Governance tokens: Governance tokens are distributed to liquidity providers via a deflationary emission schedule, incentivizing sustained participation.</li> </ul>"},{"location":"PredictionPerps/#protocol-revenue","title":"Protocol Revenue","text":"<ul> <li>Initial phase: The protocol initially operates without generating revenue, utilizing Aave\u2019s retail lending rates to distribute yield to ppUSDC holders.</li> <li>Future revenue model: Revenue can be generated by capturing the spread between lending and deposit rates, similar to Aave\u2019s model.</li> <li>Development or partnerships: The protocol may develop its own lending services or partner with DeFi protocols to secure rates more favorable than retail, allowing the protocol to retain a portion of the interest.</li> <li>Revenue source: Profits are derived from managing a large volume of deposits and retaining a percentage of the interest generated.</li> </ul>"},{"location":"PredictionPerps/#predictionperps-lab-revenue","title":"PredictionPerps Lab Revenue","text":"<ul> <li>Trading bots: PredictionPerps Lab may develop and deploy trading bots that leverage market inefficiencies or arbitrage opportunities within the protocol or across DeFi ecosystems, generating revenue through optimized trading strategies.</li> <li>Strategic investments: The lab can invest in promising DeFi projects, protocols, or tokens, earning returns through capital appreciation or yield-generating opportunities, similar to Uniswap Labs' investment strategies.</li> <li>Partnerships: Collaborations with other DeFi platforms, exchanges, or blockchain projects can create revenue streams through shared fees, co-developed products, or integration incentives, mirroring models used by entities like Uniswap Labs.</li> <li>Additional services: The lab may offer premium tools, analytics, or customized solutions for traders and liquidity providers, creating revenue through subscriptions or service fees, akin to value-added services provided by other DeFi labs.</li> </ul>"},{"location":"PredictionPerps/#roadmap","title":"Roadmap","text":"<ul> <li>Growth targets: Over the next five years, PredictionPerps aims to maximize total value locked (TVL) in its markets, targeting $10 billion. The governance token is projected to reach a market capitalization of $1 billion.</li> <li>Context: For comparison, Aave\u2019s governance token currently has a market cap of $4.7 billion with a total value locked of $33 billion (source: CoinGecko).</li> <li>Mainnet deployment: The protocol will initially launch on mainnet, serving as the primary trading platform for centralized exchanges to offer PredictionPerps to their users.</li> <li>Network expansion: As liquidity grows, instances will be deployed on other networks, with listings on exchanges to enhance accessibility.</li> <li>Mainnet advantages: Operating on mainnet enables the use of Uniswap\u2019s limit order book and Uniswap X for smart liquidity sourcing, providing greater flexibility in trading.</li> </ul>"},{"location":"SamFeedback/","title":"SamFeedback","text":"<ol> <li> <p>PPGT Value Dependency    PPGT will only incentivize user participation if it has a value above zero. If perceived as worthless or speculative, it may fail to drive engagement.</p> </li> <li> <p>Early Trading of PPGT    PPGT will likely trade from day one, as users or speculators create liquidity pools (e.g., on DEXs). This could lead to volatility or misalignment with the protocol's planned valuation at the transition phase.</p> </li> <li> <p>Low Reward Shave Percentage    Shaving 10% of rewards is very small </p> </li> <li> <p>Scale of Reward Distribution    Reaching 1 billion USDC in rewards (to distribute 1 billion PPGT) implies ~$20 billion in deposits. This could take 5\u201310 years, even with a successful system, delaying the transition phase significantly.</p> </li> <li> <p>Delayed Value Appreciation    If it takes 5+ years to reach the transition phase, the potential for PPGT to \"moon\" is deferred, which may frustrate early adopters and reduce hype or community engagement.</p> </li> <li> <p>Liquidity Pool Interactions    Emergent liquidity pools (from day-one trading) could complicate the protocol\u2019s planned trading launch after years of operation. Uncontrolled pools may dilute price stability or create arbitrage issues.</p> </li> <li> <p>Post-Deflationary User Incentives    In Phase 2, when PPGT is no longer distributed with rewards, new users receive only USDPP/USDC. This shifts their role to \"just users\" without ownership, potentially reducing loyalty or engagement compared to early adopters.</p> </li> <li> <p>Divergent Incentives    Once PPGT distribution stops, platform ownership is no longer distributed to new users. This creates a divide where token holders\u2019 incentives (e.g., maximizing protocol revenue or token price) which may diverge from those of new users. </p> </li> </ol>"},{"location":"TokenDistribution/","title":"Governance Tokenomics Plan","text":""},{"location":"TokenDistribution/#ideology-rationale","title":"Ideology &amp; Rationale","text":"<p>Simple, fair, deflationary token distribution.</p> <p>Fixed annual emissions ensure scarcity as protocol value (Total Value Locked / revenue) grows.</p>"},{"location":"TokenDistribution/#deflationary-mechanism","title":"Deflationary Mechanism","text":"<ul> <li>Fixed Emissions per year/block.</li> <li>Early years: high token share per dollar.<ul> <li>High Total emissions per $ TVL</li> </ul> </li> <li>Later years: lower share per dollar.<ul> <li>Low Total emissions per $ TVL</li> </ul> </li> </ul>"},{"location":"TokenDistribution/#rewarding-early-risk","title":"Rewarding Early Risk","text":"<ul> <li>Team/advisors get 0 tokens in Year 1.</li> <li>Allocations start Year 2, end by Year 10.</li> </ul>"},{"location":"TokenDistribution/#depositor-ownership","title":"Depositor Ownership","text":"<ul> <li>Depositors provide USDC for yield.</li> <li>Depositior token emissions share rises to 90% by Year 11.</li> <li>Fixed total emissions reward loyalty in downturns.</li> </ul>"},{"location":"TokenDistribution/#supply-discipline","title":"Supply Discipline","text":"<ul> <li>Fixed issuance cuts supply inflation over time.</li> <li>Revenue can be used for buybacks/burns to reduce supply.</li> </ul>"},{"location":"TokenDistribution/#governance-control","title":"Governance Control","text":"<ul> <li>Manages Treasury tokens/revenue for:</li> <li>Staking</li> <li>Liquidity</li> <li>Buybacks</li> <li>Development</li> <li>Community initiatives</li> </ul>"},{"location":"TokenDistribution/#treasury-assets","title":"Treasury Assets","text":""},{"location":"TokenDistribution/#principal","title":"Principal","text":"<ul> <li>USDC deposits deployed for yield (eg Aave) via governance.</li> </ul>"},{"location":"TokenDistribution/#revenue","title":"Revenue","text":"<ul> <li>USDC yield from DeFi (e.g., Aave).</li> <li>Held initially, later allocated for liquidity, developtment, buybacks, burns, rewards.</li> </ul>"},{"location":"TokenDistribution/#governance-tokens","title":"Governance Tokens","text":"<ul> <li>Used for staking, liquidity, grants.</li> <li>Drops to 10% of emissions by Year 11.</li> </ul>"},{"location":"TokenDistribution/#governance-role","title":"Governance Role","text":"<ul> <li>Controls Treasury via on-chain proposals.</li> </ul>"},{"location":"TokenDistribution/#token-emissions","title":"Token Emissions","text":""},{"location":"TokenDistribution/#annual-issuance","title":"Annual Issuance","text":"<ul> <li>10M tokens/year, uncapped.</li> </ul>"},{"location":"TokenDistribution/#total-supply","title":"Total Supply","text":"<ul> <li>linear increase</li> <li>eg 100M tokens after 10 years.</li> <li>eg 500M tokens after 50 years.</li> </ul>"},{"location":"TokenDistribution/#issuance-structure","title":"Issuance Structure","text":"<ul> <li>Linear issuance, ~1.9 tokens/block.</li> </ul>"},{"location":"TokenDistribution/#token-distribution","title":"Token Distribution","text":""},{"location":"TokenDistribution/#year-1-startup-phase","title":"Year 1: Startup Phase","text":"<ul> <li>Team: 0% (0 tokens).</li> <li>Advisors: 0% (0 tokens).</li> <li>Treasury: 40% (4M tokens).</li> <li>Depositors: 60% (6M tokens).</li> </ul>"},{"location":"TokenDistribution/#year-2","title":"Year 2","text":"<ul> <li>Team: 15% (1.5M tokens).</li> <li>Advisors: 3.75% (0.375M tokens).</li> <li>Treasury: 21% (2.1M tokens).</li> <li>Depositors: 60% (6M tokens).</li> </ul>"},{"location":"TokenDistribution/#year-10","title":"Year 10","text":"<ul> <li>Team: 7% (0.7M tokens).</li> <li>Advisors: 0.5% (0.05M tokens).</li> <li>Treasury: 11% (1.1M tokens).</li> <li>Depositors: 81.5% (8.15M tokens).</li> </ul>"},{"location":"TokenDistribution/#years-11-depositor-dominance","title":"Years 11+: Depositor Dominance","text":"<ul> <li>Team/Advisors: 0% (fully vested).</li> <li>Treasury: 10% (1M tokens/year).</li> <li>Depositors: 90% (9M tokens/year).</li> </ul>"},{"location":"TokenDistribution/#cumulative-token-distribution","title":"Cumulative Token Distribution","text":""},{"location":"TokenDistribution/#after-10-years-100m-tokens","title":"After 10 Years (100M tokens)","text":"<ul> <li>Team: ~10% (10M).</li> <li>Advisors: ~2.5% (2.5M).</li> <li>Treasury: ~16.9% (16.9M).</li> <li>Depositors: ~70.6% (70.6M).</li> </ul>"},{"location":"TokenDistribution/#after-20-years-200m-tokens","title":"After 20 Years (200M tokens)","text":"<ul> <li>Team: ~5% (10M).</li> <li>Advisors: ~1.25% (2.5M).</li> <li>Treasury: ~12.45% (24.9M).</li> <li>Depositors: ~81.3% (162.6M).</li> </ul>"},{"location":"TokenDistribution/#note","title":"Note","text":"<ul> <li>Linear growth reduces insider share; depositors dominate.</li> </ul>"},{"location":"TokenDistribution/#governance-token-staking","title":"Governance Token Staking","text":""},{"location":"TokenDistribution/#funding","title":"Funding","text":"<ul> <li>Funded by Treasury emittance.</li> </ul>"},{"location":"TokenDistribution/#governance-role_1","title":"Governance Role","text":"<ul> <li>Adjusts rewards.</li> </ul>"},{"location":"TokenDistribution/#governance-responsibilities","title":"Governance Responsibilities","text":""},{"location":"TokenDistribution/#manages-treasury","title":"Manages Treasury","text":"<ul> <li>Spends or invests yield</li> <li>Distributes treasury emittance</li> <li>Controls Protocol levers</li> </ul>"},{"location":"TokenDistribution/#why-it-works","title":"Why It Works","text":"<ul> <li>Predictable 10M/year issuance.</li> <li>Depositor focused rewards (reaching 90% of emissions) - growing TVL.</li> <li>Deflationary token issuance.</li> <li>Team advisor rewards capped</li> <li>Team and advisor rewards distributed from year 2-9. - Shared goals</li> <li>Token holders control Governance.</li> </ul>"},{"location":"TokenDistribution/#summary","title":"Summary","text":""},{"location":"TokenDistribution/#token-supply","title":"Token Supply","text":"<ul> <li>10M/year</li> <li>So 200M after 20 years for example</li> </ul>"},{"location":"TokenDistribution/#insider-cap","title":"Insider Cap","text":"<ul> <li>Total 12.5M tokens ie</li> <li>0% after 1 year</li> <li>12.5% after 10 years</li> <li>6.25% after 20 years.</li> <li>3.125 after 40 years</li> </ul>"},{"location":"TokenDistribution/#treasury-assets_1","title":"Treasury Assets","text":"<ul> <li>Revenue held early, later allocated; principal yields; tokens drop to 10%.</li> </ul>"},{"location":"TokenDistribution/#governance","title":"Governance","text":"<ul> <li>Ensures depositor dominance, flexible strategy.</li> </ul>"},{"location":"V2/","title":"Perpetual Prediction Markets: V2","text":""},{"location":"V2/#introduction","title":"Introduction","text":""},{"location":"V2/#overview","title":"Overview","text":"<p>Traditional prediction markets, like Polymarket, focus on time-bound events such as elections or sports outcomes. While effective for short-term forecasting, they lack support for long-term hedging or sustained positions on recurring phenomena.</p>"},{"location":"V2/#limitations-of-expiring-markets","title":"Limitations of Expiring Markets","text":"<ul> <li>Finite Duration: Positions expire at event resolution, despite entities like sports teams, political parties, or economic indicators persisting over time.</li> <li>Repetitive Investment: Users must repurchase contracts each cycle (e.g., season), incurring fees and limiting long-term strategies.</li> <li>Event-Centric Focus: Markets emphasize one-off events and fail to support speculation on the longevity or sustained state of ongoing phenomena, such as a career\u2019s trajectory or persistent conditions.</li> </ul>"},{"location":"V2/#perpetual-prediction-tokens-ppts","title":"Perpetual Prediction Tokens (PPTs)","text":""},{"location":"V2/#concept","title":"Concept","text":"<p>Perpetual Prediction Tokens (PPTs) are non-expiring tokens designed for markets that enable speculation on recurring or persistent phenomena, supporting long-term \"buy and hold\" strategies.</p>"},{"location":"V2/#core-features","title":"Core Features","text":"<ul> <li>Indefinite Persistence: Tokens never expire, allowing continuous market participation.</li> <li>Dividend Payouts: Holders receive dividends (in USDC) during \"true\" periods, based on periodic evaluations (e.g., annual) via oracles like UMA.</li> <li>Dynamic Pricing: Token prices adjust to market sentiment, reflecting the discounted probability of future \"true\" outcomes and their expected duration.</li> <li>Verifiable Outcomes: Focus on clear, oracle-resolved truth statements.</li> </ul>"},{"location":"V2/#use-cases","title":"Use Cases","text":"<ul> <li>Sports: \"Liverpool are Premier League Champions,\" \"Crystal Palace are in the Premier League,\" \"Tottenham are in Champions League,\" \"Serena Williams is a top 8 tennis player.\"</li> <li>Entertainment: \"Taylor Swift is the most streamed artist on Spotify.\"</li> <li>Economics: \"CPI inflation is greater than 3%.\"</li> <li>Politics: \"Nigel Farage is Prime Minister,\" \"Labour have a majority in Parliament,\" \"JD Vance is President.\"</li> <li>Space: \"There are people on Mars,\" \"There are people on the Moon.\"</li> <li>BTC Mining Threshold: \"BTC &gt;= $50,000.\"</li> <li>Weather: \"New York Cooling Days over/under X.\"</li> </ul>"},{"location":"V2/#perpetual-vs-expiring-markets","title":"Perpetual vs. Expiring Markets","text":""},{"location":"V2/#challenges-of-expiring-markets","title":"Challenges of Expiring Markets","text":"<p>Expiring markets require users to repurchase contracts each cycle, incurring fees and preventing sustained positions. They focus on specific milestones rather than ongoing states or longevity.</p> <p>For example:</p> <ul> <li>Betting on \"Will Newcastle United win the Premier League?\" requires annual repurchasing, ignoring the team\u2019s long-term trajectory.</li> <li>Markets like \"Keir Starmer is Prime Minister\" or \"Taylor Swift is the most streamed artist\" don\u2019t allow speculation on the duration of their tenure or dominance.</li> <li>A market like \"Serena Williams is a top 8 tennis player\" would focus on breaking into the top 8 for a single season, not her career-long performance.</li> </ul>"},{"location":"V2/#how-ppts-solve-these-issues","title":"How PPTs Solve These Issues","text":"<p>PPTs create fluid, perpetual markets that: - Allow a single position to cover all future cycles, capturing long-term trends or careers. - Reward holders with dividends during \"true\" periods. - Reflect evolving probabilities through dynamic pricing.</p>"},{"location":"V2/#key-mechanics","title":"Key Mechanics","text":""},{"location":"V2/#token-structure","title":"Token Structure","text":"<ul> <li>T: Bullish position (e.g., \"Yes, Newcastle is champion\").</li> <li>\\(\\overline{T}\\): Bearish position (e.g., \"No, Newcastle is not champion\").</li> <li>Pricing: Constant sum mechanism (\\(P_T + P_{\\overline{T}} = 1\\) USDC) enables minting/burning for arbitrage.</li> </ul>"},{"location":"V2/#outcome-evaluation","title":"Outcome Evaluation","text":"<ul> <li>Binary Outcomes (V1): Conditions are evaluated as \"true\" or \"false\" (e.g., annually for sports).</li> <li>Bounded Outcomes (V2): Future iterations will support more complex, bounded outcomes.</li> <li>Oracle-Based Resolution: Verifiable via oracles like UMA.</li> </ul>"},{"location":"V2/#dividend-mechanism","title":"Dividend Mechanism","text":"<ul> <li>Dividends (in USDC) are paid only when the condition is \"true,\" based on a predefined rubric.</li> <li>Tokens persist indefinitely; yields toggle based on oracle outcomes, with prices reflecting long-term expectations.</li> </ul>"},{"location":"V2/#benefits","title":"Benefits","text":"<ul> <li>Long-Term Positions: Holders can maintain positions without repurchasing.</li> <li>Dividend Rewards: Sustained success generates ongoing yields.</li> <li>Market Efficiency: Prices adapt to new information, supporting arbitrage opportunities.</li> </ul>"},{"location":"V2/#example-newcastle-united-premier-league-champions","title":"Example: Newcastle United Premier League Champions","text":""},{"location":"V2/#outcome","title":"Outcome","text":"<p>Evaluated annually post-season: \"Is Newcastle United the current Premier League champion?\"</p>"},{"location":"V2/#tokens","title":"Tokens","text":"<ul> <li>T: Yes, Newcastle is champion.</li> <li>\\(\\overline{T}\\): No, Newcastle is not champion.</li> </ul>"},{"location":"V2/#yields","title":"Yields","text":"<ul> <li>If \"Yes,\" T holders receive yield \\(r\\) (or proportional); \\(\\overline{T}\\) holders receive 0.</li> <li>If \"No,\" \\(\\overline{T}\\) holders receive yield; T holders receive 0.</li> </ul>"},{"location":"V2/#market-dynamics","title":"Market Dynamics","text":"<ul> <li>Initial State: T at 0.03 USDC (low odds), \\(\\overline{T}\\) at 0.97 USDC.</li> <li>On Success: T price surges (e.g., to 0.8 USDC); T holders earn dividends.</li> <li>Long-Term Potential: A $100 investment in T may yield nothing for years but could generate $500/year in dividends upon success, plus capital gains.</li> </ul>"},{"location":"V2/#advantage-over-expiring-markets","title":"Advantage Over Expiring Markets","text":"<p>Unlike Polymarket, where users repurchase contracts each season, PPTs allow supporters to buy and hold a single position covering all future seasons, capturing long-term trends.</p>"},{"location":"footballperps/","title":"Football Perps Specification","text":""},{"location":"footballperps/#overview","title":"Overview","text":"<p>FootballPerps is the flagship product of PredictionPerps and the pioneer in a groundbreaking new asset class - Perpetual Prediction Markets! FootballPerps enables users to buy and sell perpetual positions on the performance of football teams.</p>"},{"location":"footballperps/#purpose-of-perpetual-prediction-markets","title":"Purpose of Perpetual Prediction Markets","text":"<ul> <li>A fun new mechanism for speculation.</li> <li>Removes centralisation from prediction markets.</li> <li>Introduce a perpetual asset class.</li> <li>Create a new crypto primitive that can be built upon.</li> <li>Allow the full range of DeFi products to be used in conjunction with prediction markets.</li> <li>Allow Centralised Exchanges to sell prediction tokens.</li> </ul>"},{"location":"footballperps/#predictionperps-roadmap","title":"PredictionPerps Roadmap","text":"<ul> <li>Integrate FootballPerps with the DeFi ecosystem including leveraged perpetuals, order books, and additional derivatives.</li> <li>Develop Perpetual Prediction Markets in other sports, events, or asset classes, creatinag a scalable, versatile ecosystem for PredictionPerps\u2019 future products.</li> </ul>"},{"location":"footballperps/#how-it-works","title":"How It Works","text":"<ul> <li>Take a Position: Buy bullish or bearish shares on football teams using USDC. These shares reflect your view on whether a team\u2019s performance will rise or fall, allowing profits from buying low and selling high.</li> <li>Earn Daily Rewards: Receive native FootballPerps tokens daily based on your team\u2019s recent game results. Stronger performance rewards bullish holders, while weaker performance benefits bearish holders, driving dynamic price shifts and enabling profit through token accumulation.</li> <li>No Loss from Interest: Tokens are backed by interest generated through Aave, ensuring users don\u2019t lose out, unlike traditional prediction markets.</li> <li>Powered by DeFi: Uniswap liquidity pools and Aave ensure a stable, efficient market, with the FootballPerps frontend optimizing trades, especially for large purchases.</li> <li>Distributed and Timeless: As a distributed protocol, shares never expire and can be traded across the entire crypto ecosystem, maximizing access and liquidity.</li> <li>Premier League and Championship: Starts with markets for all Premier League teams.</li> </ul> <p>FootballPerps blends the excitement of football with decentralized finance, creating boundless opportunities for speculation and innovation.</p>"},{"location":"footballperps/#components","title":"Components","text":"<ul> <li>Shares: Users can hold bullish or bearish shares representing their position on a football team\u2019s performance, purchased using USDC or USSD via FootballPerps-managed interactions with Uniswap liquidity pools.</li> <li>Funding Mechanism: FootballPerps distributes native perp payment tokens daily based on team performance metrics, backed by interest generated on USDC held by FootballPerps through Aave.</li> <li>Team Performance Tracking: Tracks rolling cumulative point scores over the last 38 games for Premier League teams (with adjustment for Championship teams).</li> <li>Perp Payment Tokens: Native tokens distributed daily to share holders, backed by interest on USDC held by FootballPerps, with potential market floatation and additional utility (e.g., burning for governance tokens).</li> <li>USSD Stablecoin: A stablecoin pegged 1:1 with USDC through minting and burning mechanisms.</li> <li>Liquidity Pools: Two liquidity pools (bullish USSD and bearish USSD) on Uniswap provide synthetic liquidity for trading bullish and bearish shares, utilized by FootballPerps to facilitate trades, with imbalances equalized by arbitrage bots.</li> <li>Frontend Algorithm: An algorithm that optimizes the buy/sell path for users, providing the best execution (especially for large purchases) by leveraging four bidirectional operations to execute trades through FootballPerps, without direct user access to Uniswap liquidity pools:</li> <li>USDC&lt;-&gt;USSD: Contract-based minting or burning of USSD to maintain a 1:1 peg with USDC.</li> <li>USSD&lt;-&gt;bullish,bearish pair: Minting or burning a pair of bullish and bearish shares for 1 USSD.</li> <li>USSD&lt;-&gt;bullish pool: Swapping USSD for bullish shares (or vice versa) via the Uniswap bullish USSD pool.</li> <li>USSD&lt;-&gt;bearish pool: Swapping USSD for bearish shares (or vice versa) via the Uniswap bearish USSD pool.</li> <li>Further components TBD: Based on Championship adjustment details, token management, and platform implementation.</li> </ul>"},{"location":"footballperps/#functionality","title":"Functionality","text":"<ul> <li>Position Types:</li> <li>Users can take perpetual bullish (expecting team performance to rise) or bearish (expecting team performance to decline) positions on football teams.</li> <li>Positions are represented as shares, split into bullish and bearish categories, similar to Polymarket\u2019s share system.</li> <li>Users purchase bullish or bearish shares using USDC, which can be converted to USSD for FootballPerps-managed interactions with Uniswap liquidity pools.</li> <li>Funding Mechanism:</li> <li>For Premier League teams, FootballPerps uses a rolling cumulative point score from a team\u2019s last 38 games. The bullish ratio is calculated as the cumulative point score divided by 114 (38 games \u00d7 3 points per game). The bearish ratio is calculated as 1 minus the bullish ratio.</li> <li>For Championship teams, a discount factor (e.g., 1/5) is applied to points to reflect their lower value compared to Premier League points.</li> <li>The bearish ratio is capped at a maximum of 0.93 (equivalent to a minimum bullish ratio of 0.07, or approximately 8 points in the Premier League and 40 points in the Championship after discounting), preventing teams in terminal decline from draining FootballPerps liquidity.</li> <li>Each day, holders of bullish shares receive perp payment tokens proportional to the bullish ratio.</li> <li>Each day, holders of bearish shares receive perp payment tokens proportional to the bearish ratio.</li> <li>NB: For teams relegated to the Championship, FootballPerps may use a 46-game rolling window (reflecting the Championship\u2019s season length) instead of a 38-game window, with adjustments needed to account for the different league structure (details TBD).</li> <li>For teams relegated from the Championship, tracking of games ceases, as their discounted points cannot exceed the 0.07 bullish ratio threshold.</li> <li>Perp Payment Tokens:</li> <li>Tokens are native to FootballPerps and backed by the interest generated on USDC held by FootballPerps through Aave, establishing a floor price.</li> <li>Tokens may be floated on the market, possibly introducing additional utility, such as burning tokens to acquire governance tokens.</li> <li>Details on token distribution mechanics and governance token functionality TBD.</li> <li>Interest Generation:</li> <li>FootballPerps holds USDC paid by users to open bullish or bearish positions.</li> <li>Interest on USDC is generated using Aave, which backs the perp payment tokens.</li> <li>Details on Aave integration, security, and reliability mechanisms TBD.</li> <li>USSD Stablecoin and Liquidity Pools:</li> <li>USSD is a stablecoin pegged 1:1 with USDC through minting and burning mechanisms.</li> <li>At t=0, two liquidity pools are created on Uniswap: bullish USSD and bearish USSD. The pools are initialized with a depth (D) and a weighting factor (W) to set the starting price. For example, with D = 10,000 and W = 0.8, the bullish pool contains 10,000 bullish shares against 8,000 USSD, and the bearish pool contains 10,000 bearish shares against 2,000 USSD, establishing synthetic liquidity.</li> <li>A pair of bullish and bearish tokens can be minted or burned for 1 USSD, capping the price of bullish and bearish shares between 0 and 1.</li> <li>Users buy or sell shares through FootballPerps, which utilizes Uniswap\u2019s bullish and bearish USSD liquidity pools to execute trades. Direct interaction with Uniswap pools is suboptimal, while the FootballPerps frontend provides optimal execution, especially for large purchases.</li> <li>The Uniswap liquidity pools are open to the broader crypto ecosystem, allowing anyone to buy tokens directly, with imbalances quickly equalized by arbitrage bots.</li> <li>A frontend algorithm optimizes the buy/sell path for users by leveraging four bidirectional operations:<ul> <li>USDC&lt;-&gt;USSD: Contract-based minting or burning of USSD to maintain a 1:1 peg with USDC.</li> <li>USSD&lt;-&gt;bullish,bearish pair: Minting or burning a pair of bullish and bearish shares for 1 USSD.</li> <li>USSD&lt;-&gt;bullish pool: Swapping USSD for bullish shares (or vice versa) via the Uniswap bullish USSD pool.</li> <li>USSD&lt;-&gt;bearish pool: Swapping USSD for bearish shares (or vice versa) via the Uniswap bearish USSD pool.</li> </ul> </li> <li>Arbitrage prevention is handled through optimized mechanisms via the frontend, ensuring efficient trading.</li> </ul>"},{"location":"footballperps/#scope","title":"Scope","text":"<ul> <li>FootballPerps supports positions on teams in the English Premier League and the Championship, with initial markets covering current Premier League teams.</li> <li>FootballPerps accommodates teams relegated from the Premier League, allowing positions on non-Premier League teams over time.</li> </ul>"},{"location":"test/","title":"Test Chart (chartjs fence)","text":"<pre><code>{\n  \"type\": \"line\",\n  \"data\": {\n    \"labels\": [0, 1],\n    \"datasets\": [{\n      \"label\": \"Test\",\n      \"data\": [0, 1],\n      \"borderColor\": \"#FF6384\",\n      \"fill\": false\n    }]\n  },\n  \"options\": {\n    \"responsive\": true,\n    \"plugins\": { \"legend\": { \"position\": \"top\" } }\n  }\n}\n</code></pre>"},{"location":"sections/10RebasingSketch/","title":"Rebasing Mechanism Sketch","text":""},{"location":"sections/10RebasingSketch/#introduction","title":"Introduction","text":"<p>This document outlines a rebasing vault smart contract in Solidity. Users deposit an underlying token (T) to receive a rebasing token (aT). The aT balance grows via periodic rebases, but new deposits remain fixed until activated at the next <code>rebase()</code> call. The rate at each checkpoint (<code>rebase_id = n</code>) applies to the period from <code>n-1</code> to <code>n</code>.</p> <p>Key Goals: - Support variable rates per rebase period. - Efficient: No iteration over users or deposits in <code>rebase()</code>. - User balances split into activated (rebasing, transferable) and pending (fixed until activation, non-transferable). - Use a cumulative index with historical snapshots for accurate accounting.</p> <p>Assumptions: - Rebase rate is provided externally (complex calculation, not detailed). - Scale factor: 1e18 for fixed-point math. - ERC20-based with overrides for <code>balanceOf</code>, <code>totalSupply</code>, <code>transfer</code>, etc. - Withdrawals distribute underlying T proportionally (vault accrues yield).</p>"},{"location":"sections/10RebasingSketch/#core-concepts","title":"Core Concepts","text":""},{"location":"sections/10RebasingSketch/#cumulative-index","title":"Cumulative Index","text":"<ul> <li>Global multiplier tracking growth since inception.</li> <li>Starts at <code>1e18</code>.</li> <li>Updated in <code>rebase()</code>: <code>new_index = old_index * (1e18 + rate) / 1e18</code>.</li> <li>Represents compounded rates from all rebases.</li> </ul>"},{"location":"sections/10RebasingSketch/#rebase-id-and-history","title":"Rebase ID and History","text":"<ul> <li><code>current_rebase_id</code>: Starts at 0, increments per <code>rebase()</code>.</li> <li><code>cumulative_index_history[rebase_id]</code>: Stores <code>cumulative_index</code> after each rebase.</li> <li>Rate from <code>x</code> to <code>y</code>: <code>(cumulative_index_history[y] * 1e18 / cumulative_index_history[x]) - 1e18</code>.</li> </ul>"},{"location":"sections/10RebasingSketch/#user-balance-parts","title":"User Balance Parts","text":"<p>Each user has two balance components (no arrays): 1. Activated Part (Part 1):    - Stored as <code>user_effective_shares</code> (normalized shares).    - Balance: <code>user_effective_shares * cumulative_index / 1e18</code>.    - Grows with every rebase, reflecting all rates post-activation.    - Transferable to other addresses. 2. Pending Part (Part 2):    - Stored as <code>user_pending_base</code> (raw amount) with <code>user_pending_entry_id</code> (activation rebase_id).    - Fixed if <code>user_pending_entry_id &gt; current_rebase_id</code>.    - If activated (<code>entry_id &lt;= current_rebase_id</code>), balance = <code>user_pending_base * cumulative_index / cumulative_index_history[entry_id]</code>.    - Non-transferable; remains with depositor until merged.    - Multiple deposits before a rebase accumulate in the same pending part.</p>"},{"location":"sections/10RebasingSketch/#global-tracking","title":"Global Tracking","text":"<ul> <li><code>effective_shares</code>: Sum of all <code>user_effective_shares</code>.</li> <li><code>global_pending_base</code>: Total pending deposits (single <code>entry_id</code>).</li> <li><code>global_pending_entry_id</code>: Pending group ID (one cohort at a time).</li> </ul>"},{"location":"sections/10RebasingSketch/#rebase-process","title":"Rebase Process","text":"<ol> <li>Input: Rate for period from <code>current_rebase_id</code> to <code>current_rebase_id + 1</code> (external).</li> <li>Update Index: <code>cumulative_index = cumulative_index * (1e18 + rate) / 1e18</code>.</li> <li>Store History: Increment <code>current_rebase_id</code>, set <code>cumulative_index_history[current_rebase_id] = cumulative_index</code>.</li> <li>Activate Pending: If <code>global_pending_entry_id == current_rebase_id</code>:</li> <li>Add <code>global_pending_base * 1e18 / cumulative_index</code> to <code>effective_shares</code>.</li> <li>Reset <code>global_pending_base = 0</code>, <code>global_pending_entry_id = 0</code>.</li> <li>Effects: Activated balances grow by rate; pending deposits activate without prior gains.</li> </ol> <p>Efficiency: O(1), no user loops.</p>"},{"location":"sections/10RebasingSketch/#rate-handling","title":"Rate Handling","text":"<ul> <li>Rate at Checkpoint n: Applies to period from <code>n-1</code> to <code>n</code>, used in <code>rebase()</code> to update <code>cumulative_index</code>.</li> <li>Querying Rates: Rate from <code>x</code> to <code>y</code> (y &gt; x): <code>(cumulative_index_history[y] * 1e18 / cumulative_index_history[x]) - 1e18</code>.</li> <li>Example:</li> <li>Rebase 1 (rate = 0.05e18): <code>history[1] = 1.05e18</code>.</li> <li>Rebase 2 (rate = 0.03e18): <code>history[2] = 1.05e18 * 1.03 = 1.0815e18</code>.</li> <li>Rate at checkpoint 2 (from 1 to 2): <code>(1.0815e18 / 1.05e18) - 1 = 0.03</code>.</li> </ul>"},{"location":"sections/10RebasingSketch/#user-interactions","title":"User Interactions","text":""},{"location":"sections/10RebasingSketch/#deposit","title":"Deposit","text":"<ol> <li>Merge pending if <code>user_pending_entry_id &lt;= current_rebase_id</code> (see Merge).</li> <li>Transfer T to vault.</li> <li>Set <code>entry_id = current_rebase_id + 1</code>.</li> <li>Add <code>amount</code> to <code>user_pending_base</code> (accumulate if same <code>entry_id</code>).</li> <li>Set <code>user_pending_entry_id = entry_id</code> if unset.</li> <li>Update globals: Add to <code>global_pending_base</code>, set <code>global_pending_entry_id</code> if needed.</li> <li>Mint aT equal to <code>amount</code>.</li> </ol> <p>Note: New deposits are fixed and non-transferable until next rebase.</p>"},{"location":"sections/10RebasingSketch/#withdraw","title":"Withdraw","text":"<ol> <li>Merge pending if activated.</li> <li>Compute total balance = activated + pending (fixed or rebased).</li> <li>Require amount &lt;= total.</li> <li>Pro-rata reduce <code>user_effective_shares</code> and <code>user_pending_base</code>.</li> <li>Update globals: Subtract from <code>effective_shares</code>, <code>global_pending_base</code> if applicable.</li> <li>Burn aT, transfer proportional T (based on <code>totalSupply</code>).</li> </ol>"},{"location":"sections/10RebasingSketch/#transfer","title":"Transfer","text":"<ol> <li>Merge pending for sender and recipient if <code>user_pending_entry_id &lt;= current_rebase_id</code>.</li> <li>Compute sender's total balance (activated + pending), require amount &lt;= total.</li> <li>Calculate activated balance: <code>user_effective_shares[sender] * cumulative_index / 1e18</code>.</li> <li>Determine transferable amount:</li> <li>Only the activated part is transferable.</li> <li>If amount &lt;= activated balance, use only activated.</li> <li>If amount &gt; activated balance but &lt;= total, fail (pending is non-transferable).</li> <li>Reduce sender\u2019s <code>user_effective_shares</code> by <code>amount * 1e18 / cumulative_index</code>.</li> <li>Add to recipient\u2019s <code>user_effective_shares</code> (same amount).</li> <li>Update global <code>effective_shares</code> (no net change).</li> <li>Pending Note: Sender\u2019s <code>user_pending_base</code> and <code>user_pending_entry_id</code> remain unchanged (non-transferable). Recipient\u2019s pending part is unaffected.</li> <li>Emit Transfer event.</li> </ol> <p>Transfer Clarification: Only activated balances (rebasing, from <code>user_effective_shares</code>) can be transferred. Pending balances (fixed, non-rebasing) stay with the sender until activated and merged, ensuring pending deposits are tied to the original depositor.</p>"},{"location":"sections/10RebasingSketch/#merge-internal","title":"Merge (Internal)","text":"<ul> <li>If <code>user_pending_entry_id &lt;= current_rebase_id</code>:</li> <li>Convert: <code>delta_shares = user_pending_base * 1e18 / cumulative_index_history[user_pending_entry_id]</code>.</li> <li>Add to <code>user_effective_shares</code> and <code>effective_shares</code>.</li> <li>Clear <code>user_pending_base</code>, <code>user_pending_entry_id</code>.</li> </ul>"},{"location":"sections/10RebasingSketch/#balance-calculation-balanceof","title":"Balance Calculation (balanceOf)","text":"<ul> <li>Activated: <code>user_effective_shares * cumulative_index / 1e18</code>.</li> <li>Pending:</li> <li>If <code>entry_id &gt; current_rebase_id</code>: <code>user_pending_base</code> (fixed).</li> <li>Else: <code>user_pending_base * cumulative_index / cumulative_index_history[entry_id]</code>.</li> <li>Total: Sum of both.</li> </ul>"},{"location":"sections/10RebasingSketch/#total-supply","title":"Total Supply","text":"<ul> <li>Activated: <code>effective_shares * cumulative_index / 1e18</code>.</li> <li>Pending: <code>global_pending_base</code> if <code>global_pending_entry_id &gt; current_rebase_id</code>, else 0.</li> <li>Total: Sum.</li> </ul>"},{"location":"sections/10RebasingSketch/#efficiency-and-scalability","title":"Efficiency and Scalability","text":"<ul> <li>Storage: Per-user: 3 slots. Global: Scalars + <code>cumulative_index_history</code> (grows with rebases).</li> <li>Gas:</li> <li><code>rebase()</code>: O(1).</li> <li>User ops: O(1), at most one merge.</li> <li>Views: O(1).</li> <li>No Iteration: Uses aggregates and history mapping.</li> <li>Scalability: Handles many users/deposits efficiently.</li> </ul>"},{"location":"sections/10RebasingSketch/#edge-cases","title":"Edge Cases","text":"<ul> <li>First rebase: <code>rebase_id = 0</code> initializes correctly.</li> <li>No deposits: Skips activation.</li> <li>Multiple deposits: Accumulate in pending.</li> <li>Transfers: Only activated part moves; pending stays with sender.</li> <li>Zero rate: No effect.</li> </ul> <p>This design ensures efficient rebasing with variable rates, proper handling of non-transferable pending deposits, and clear accounting.</p>"},{"location":"sections/1introduction/","title":"1introduction","text":""},{"location":"sections/1introduction/#introduction","title":"Introduction","text":"<p>Perpetual Bounded Phenomena (PBP)</p> <p>Perpetual Bounded Phenomena are formed from a perpetual series of discrete events which have bounded outcomes. </p> <p>Examples Include:</p> <ul> <li>Temperatures</li> <li>Poll percentages</li> <li>League points</li> <li>Popularity</li> <li>Market share</li> </ul> <p>In this work, we first formalise PBPs before showing how they can be tokenized through Perpetually Bounded Tokens.</p>"},{"location":"sections/2phenomenon/","title":"2phenomenon","text":""},{"location":"sections/2phenomenon/#the-phenomena","title":"The Phenomena","text":"<p>A Perpetual Bounded Phenomenon (PBP) arises from a sequence of discrete events with bounded outcomes.</p> <p>Formally, a PBP is a process mapping natural numbers to a bounded interval:</p> \\[ f: \\mathbb{N} \\to [a, b] \\] <p>where</p> \\[ a \\leq f(t) \\leq b \\quad \\text{for all discrete time steps } t \\in \\mathbb{N}. \\] <p>Each step \\( t \\) produces an outcome:</p> \\[ X_t \\in \\{0, 1, \\dots, m\\}. \\] <p>The cumulative value over a window of length \\( n \\) is:</p> \\[ S = \\sum_{k=0}^{n-1} X_{t-k}, \\quad 0 \\leq S \\leq m n. \\] <p>A complementary measure captures the shortfall from the maximum:</p> \\[ \\overline{S} = m n - S. \\] <p>Thus, every PBP yields a pair \\( (S, \\overline{S}) \\), representing achievement versus missed potential.</p>"},{"location":"sections/3PBP_examples/","title":"3PBP examples","text":""},{"location":"sections/3PBP_examples/#pbp-examples","title":"PBP Examples","text":""},{"location":"sections/3PBP_examples/#example-1-reform-uk-voting-intention-in-political-polls","title":"Example 1: Reform UK Voting Intention in Political Polls","text":"<p>This PBP models the percentage of voters intending to vote for Reform UK in weekly political polls. Each poll is a time step \\( t \\), with the outcome being the percentage of respondents supporting Reform UK, reported in increments of 0.1%, so:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 99.8, 99.9, 100\\} \\] <p>with maximum \\( m = 100 \\). The interval is defined by \\( a = 0 \\) (no support) and \\( b = 100 \\) (full support). Since each poll is a single event (\\( n = 1 \\)), the value \\( S \\) is the outcome of the last poll:</p> \\[ S = X_t, \\quad 0 \\leq S \\leq 100. \\] <p>The complementary measure, \\( \\overline{S} = 100 - S \\), represents the percentage of voters not supporting Reform UK. For example, if a poll shows 26.3% support for Reform UK, then:</p> \\[ \\overline{S} = 100 - 26.3 = 73.7 \\] <p>This pair \\( (26.3, 73.7) \\) reflects Reform UK\u2019s voter support versus the portion of voters favoring other parties or none.</p>"},{"location":"sections/3PBP_examples/#example-2-liverpools-points-in-the-english-premier-league","title":"Example 2: Liverpool\u2019s Points in the English Premier League","text":"<p>This PBP models the points scored by Liverpool in their last 38 matches in the English Premier League. Each match is a time step \\( t \\), with Liverpool earning points: 0 for a loss, 1 for a draw, or 3 for a win, so the outcome is:</p> \\[ X_t \\in \\{0, 1, 3\\} \\] <p>with maximum \\( m = 3 \\). The interval is defined by \\( a = 0 \\) (loss) and \\( b = 3 \\) (win). Over 38 matches (\\( n = 38 \\)), total points \\( S \\) are:</p> \\[ S = \\sum_{k=0}^{37} X_{t-k}, \\quad 0 \\leq S \\leq 3 \\cdot 38 = 114. \\] <p>The complementary measure, \\( \\overline{S} = 114 - S \\), represents unearned points. For example, if Liverpool scores 80 points, then:</p> \\[ \\overline{S} = 114 - 80 = 34 \\] <p>This pair \\( (80, 34) \\) reflects Liverpool\u2019s points earned versus points missed.</p>"},{"location":"sections/3PBP_examples/#example-3-cooling-degree-days-in-new-york","title":"Example 3: Cooling Degree Days in New York","text":""},{"location":"sections/3PBP_examples/#cooling-degree-days-cdd-definition","title":"Cooling Degree Days (CDD) Definition","text":"<p>Cooling Degree Days (CDD) measure the demand for cooling based on how much warmer the average daily temperature is compared to a baseline of 18\u00b0C. For a given day, CDD is calculated as the difference between the average daily temperature and 18\u00b0C, or zero if the temperature is 18\u00b0C or cooler. This quantifies the energy needed for air conditioning in warmer climates.</p> <p>This PBP models the total Cooling Degree Days (CDD) in New York over a rolling 30-day period. Each day is a time step \\( t \\), with the outcome being the CDD, calculated as \\( X_t = \\max(0, T_t - 18) \\), where \\( T_t \\) is the average daily temperature in \u00b0C, capped at 30 CDD per day to reflect realistic temperatures. Thus:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 29.8, 29.9, 30\\} \\] <p>with maximum \\( m = 30 \\). The interval is defined by \\( a = 0 \\) (no cooling needed) and \\( b = 30 \\) (maximum daily CDD). Over a 30-day window (\\( n = 30 \\)), total CDD \\( S \\) is:</p> \\[ S = \\sum_{k=0}^{29} X_{t-k}, \\quad 0 \\leq S \\leq 30 \\cdot 30 = 900. \\] <p>The complementary measure, \\( \\overline{S} = 900 - S \\), represents the shortfall from the maximum possible CDD. For example, if the total CDD over 30 days is 150, then:</p> \\[ \\overline{S} = 900 - 150 = 750 \\] <p>This pair \\( (150, 750) \\) reflects the cooling demand versus the unused cooling capacity over the period.</p>"},{"location":"sections/3PBP_examples/#note-on-cyclic-pbps","title":"Note on Cyclic PBPs","text":"<p>Some PBPs feature significant gaps between cycles of events, during which no new outcomes occur, but the values of \\( S \\) and \\( \\overline{S} \\) remain defined and fixed. For example, in the Liverpool Premier League case (Example 2), points are accumulated during the season\u2019s matches, but between seasons, no matches occur, and the values of \\( S \\) and \\( \\overline{S} \\) persist until the next season begins. Similarly, a PBP can track metrics over a specific period each year, such as Cooling Degree Days for August, with values updating during the period and remaining constant until the next cycle, as shown in Example 4.</p>"},{"location":"sections/3PBP_examples/#example-4-cooling-degree-days-in-new-york-for-august","title":"Example 4: Cooling Degree Days in New York for August","text":"<p>This PBP models the total Cooling Degree Days (CDD) in New York for the month of August, a fixed 31-day period each year. Each day in August is a time step \\( t \\), with the outcome being the CDD, calculated as \\( X_t = \\max(0, T_t - 18) \\), where \\( T_t \\) is the average daily temperature in \u00b0C, capped at 30 CDD per day. Thus:</p> \\[ X_t \\in \\{0, 0.1, 0.2, \\dots, 29.8, 29.9, 30\\} \\] <p>with maximum \\( m = 30 \\). The interval is defined by \\( a = 0 \\) (no cooling needed) and \\( b = 30 \\) (maximum daily CDD). Over the 31 days of August (\\( n = 31 \\)), total CDD \\( S \\) is:</p> \\[ S = \\sum_{k=0}^{30} X_{t-k}, \\quad 0 \\leq S \\leq 30 \\cdot 31 = 930. \\] <p>The complementary measure, \\( \\overline{S} = 930 - S \\), represents the shortfall from the maximum possible CDD. For example, if the total CDD for August is 200, then:</p> \\[ \\overline{S} = 930 - 200 = 730 \\] <p>This pair \\( (200, 730) \\) reflects the cooling demand for August versus the unused cooling capacity. After August, \\( S \\) and \\( \\overline{S} \\) remain fixed until the next August, illustrating a PBP with a yearly cycle and gaps between event periods.</p>"},{"location":"sections/4why_tokenize/","title":"4why tokenize","text":""},{"location":"sections/4why_tokenize/#tokenizing-principals","title":"Tokenizing Principals","text":""},{"location":"sections/4why_tokenize/#tokens-t-and-overlinet","title":"Tokens \\( T \\) and \\( \\overline{T} \\)","text":"<pre><code>graph TD\n    S[\"S\"] -.-&gt;|peg mechanism| T((T))\n    Sbar[\"S\u0305\"] -.-&gt;|peg mechanism| Tbar((T\u0305))\n    style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n    style S fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n    style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n    style Sbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n</code></pre>"},{"location":"sections/4why_tokenize/#constant-price-formula","title":"Constant Price Formula","text":"<p>To preserve the complementary dynamics inherent in \\( S \\) and \\( \\overline{S} \\), we fix the prices of our tokens to a constant.</p> \\[ P_T + P_{\\overline{T}} = 1 \\]"},{"location":"sections/4why_tokenize/#price-units","title":"Price Units","text":"<p>The constant price formula can be tied to any asset as needed. We envision this system primarily being priced in stablecoins, such as USDT or USDC. In this paper, we use USDC as shorthand for the pricing asset of choice.</p>"},{"location":"sections/4why_tokenize/#enforcement-of-constant-price-formula","title":"Enforcement of Constant Price Formula","text":"<p>The constant price relationship is enforced by allowing 1 \\( T \\) and 1 \\( \\overline{T} \\) to be minted or burned at any time for 1 USDC.</p> <pre><code>graph TD\n        USDC((USDC)) --&gt; T((T))\n        USDC((USDC)) --&gt; Tbar((T\u0305))\n        style USDC fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff\n        style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n        style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n</code></pre> <pre><code>graph TD\n        T((T)) --&gt; USDC((USDC))\n        Tbar((T\u0305)) --&gt; USDC((USDC))\n        style USDC fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff\n        style T fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff\n        style Tbar fill:#FF5722,stroke:#333,stroke-width:2px,color:#fff\n</code></pre>"},{"location":"sections/5peg_mechanism/","title":"5peg mechanism","text":""},{"location":"sections/5peg_mechanism/#peg-mechanism-linking-tokens-to-performance","title":"Peg Mechanism: Linking Tokens to Performance","text":"<p>The peg mechanism ties the value of token \\(T\\) to the expected future performance of an underlying phenomenon \\(S\\). Below are the key variables:</p> <ul> <li>\\(r\\): Daily USDC yield</li> <li>\\(YT\\): Yield for token \\(T\\)</li> <li>\\(Y\\overline{T}\\): Yield for token \\(\\overline{T}\\)</li> </ul> <p>Each \\(T\\) and \\(\\overline{T}\\) pair is minted with USDC. USDC is deposited into an interest-bearing protocol generating a daily yield \\(r\\). This yield is split between \\(YT\\) and \\(Y\\overline{T}\\) based on \\(S\\), as evaluated by a fixed market rubric, such that:</p> \\[ YT + Y\\overline{T} = r \\] <pre><code>flowchart LR\n    S --&gt; Rubric\n    Rubric --&gt; Tyield[\"YT\"]\n    Rubric --&gt; Tbaryield[\"YT bar\"]\n    USDC --&gt; yield[\"r\"]\n    yield --&gt; Rubric\n</code></pre>"},{"location":"sections/5peg_mechanism/#rubrics","title":"Rubrics","text":"<p>Definitions:</p> <ul> <li>\\(\\rho_T\\): Ratio of \\(r\\) received by \\(T\\).</li> <li>\\(\\rho_{\\bar{T}}\\): Ratio of \\(r\\) received by \\(\\bar{T}\\).</li> </ul> <p>Thus:</p> <ul> <li>\\(Y_T = r \\cdot \\rho_T\\)</li> <li>\\(Y_{\\bar{T}} = r \\cdot \\rho_{\\bar{T}}\\)</li> </ul> <p>The constraint for the function is:</p> <ul> <li>Ratios must sum to 1:</li> <li>\\(\\rho_T(S) + \\rho_{\\bar{T}}(S) = 1\\)</li> </ul>"},{"location":"sections/5peg_mechanism/#what-does-price-mean","title":"What Does Price Mean?","text":"<ul> <li>\\(P(T)\\): Present value of token \\(T\\)\u2019s future yields (\\(YT\\)).</li> <li>\\(P(\\overline{T})\\): Present value of token \\(\\overline{T}\\)\u2019s yields (\\(Y\\overline{T}\\)).</li> </ul> <p>i.e.:</p> \\[ P(T) = \\sum_{t=1}^{\\infty} \\frac{YT_t}{(1 + r_t)^t} \\] \\[ P(\\overline{T}) = \\sum_{t=1}^{\\infty} \\frac{Y\\overline{T}_t}{(1 + r_t)^t} \\] <p>Linear Rubric:</p> <p>There are infinitely many pairs of \\(\\rho_T\\) and \\(\\rho_{\\bar{T}}\\) functions that satisfy the rubric conditions. We anticipate the most widely used will be the linear mapping:</p> <ul> <li>\\(\\rho_T(S) = \\frac{S}{S_{max}}\\)</li> <li>\\(\\rho_{\\bar{T}}(S) = 1 - \\frac{S}{S_{max}}\\)</li> </ul>"},{"location":"sections/5peg_mechanism/#price-under-the-linear-rubric","title":"Price under the linear Rubric","text":"<p>The price of token \\( T \\), denoted \\( P(T) \\), is derived by substituting the yield relation \\( YT_t = \\frac{S_t}{S_{\\max}} \\cdot r_t \\) into the price formula:</p> \\[ P(T) = \\sum_{t=1}^{\\infty} \\frac{\\frac{S_t}{S_{\\max}} \\cdot r_t}{(1 + r_t)^t} = \\frac{1}{S_{\\max}} \\cdot \\sum_{t=1}^{\\infty} \\frac{S_t \\cdot r_t}{(1 + r_t)^t} \\]"},{"location":"sections/5peg_mechanism/#yield-distribution","title":"Yield Distribution","text":"<p>The peg is maintained through daily yield distributions from the USDC yield \\(r\\), as described earlier. The yields are allocated to \\(T\\) and \\(\\overline{T}\\) holders based on the performance of \\(S\\) relative to the maximum possible performance \\(S_{max}\\), using the linear mapping defined in the rubric:</p> \\[ Y_T = r \\cdot \\frac{S}{S_{max}}, \\quad Y_{\\overline{T}} = r \\cdot \\frac{S_{max} - S}{S_{max}} \\] <p>This ensures the total daily yield is fully distributed:</p> \\[ Y_T + Y_{\\overline{T}} = r \\] <p>The better \\(S\\) performs, the larger the share of the daily yield \\(T\\) holders receive, and vice versa for \\(\\overline{T}\\).</p>"},{"location":"sections/6applications/","title":"6applications","text":""},{"location":"sections/6applications/#applications","title":"Applications","text":""},{"location":"sections/6applications/#1-reform-uk-voting-intention-in-weekly-poll","title":"1. Reform UK Voting Intention in Weekly Poll","text":"<p>Weekly poll using one of the main pollsters. Used for political forecasting and hedging.</p> <p>Events: </p> <ul> <li>Weekly poll percentage for Reform UK, in 0.1% increments \\(X_t \\in \\{0, 0.1, \\dots, 100\\}, m = 100\\).</li> </ul> <p>Value:</p> <ul> <li>\\(S_t = X_t\\) (0\u2013100).</li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 100 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{100}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{100}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between polls</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on the performance of Reform UK</li> </ul> <p>Peformance Outline: </p> <ul> <li>If YouGov reports 26.3% support (\\(S_t = 26.3\\))</li> <li>then \\(\\overline{S}_t = 73.7\\)</li> <li>\\(\\rho_T = 0.263\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.737\\). </li> <li>\\(T\\) holders (bullish on Reform UK) get ~26.3% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~73.7%.</li> </ul> <p>Application</p> <ul> <li>Analysts hedge campaign risks</li> <li>Users speculate on performance</li> <li>Each new poll updates ratios.</li> </ul>"},{"location":"sections/6applications/#2-liverpools-points-in-the-premier-league","title":"2. Liverpool\u2019s Points in the Premier League","text":"<p>Tracks Liverpool\u2019s points over a rolling 38 matches period.</p> <p>Events: </p> <ul> <li>Match points, in increments of 0, 1, or 3 for loss, draw, or win (\\(X_t \\in \\{0, 1, 3\\}, m = 3\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{37} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 114\\) </li> <li>\\(n = 38\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 114 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{114}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{114}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between matches</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on Liverpool\u2019s performance</li> </ul> <p>Peformance Outline: </p> <ul> <li>If Liverpool has scored 80 points in the last rolling 38 games (\\(S_t = 80\\))</li> <li>then \\(\\overline{S}_t = 114 - 80 = 34\\)</li> <li>\\(\\rho_T \\approx 0.702\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.298\\). </li> <li>\\(T\\) holders (bullish on Liverpool) get ~70.2% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~29.8%.</li> </ul> <p>Application</p> <ul> <li>Fans speculate on team performance</li> <li>Institutions hedge exposure</li> <li>Each new match updates ratios.</li> </ul>"},{"location":"sections/6applications/#3-cooling-degree-days-in-new-york-rolling-30-days","title":"3. Cooling Degree Days in New York (Rolling 30 Days)","text":"<p>Tracks cooling demand over a rolling 30-day period using NOAA data for energy cost hedging.</p> <p>Events: </p> <ul> <li>Daily CDD, \\(X_t = \\max(0, T_t - 18)\\), in \u00b0C, capped at 30 (\\(X_t \\in \\{0, 0.1, \\dots, 30\\}, m = 30\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{29} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 900\\) </li> <li>\\(n = 30\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 900 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{900}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{900}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) update daily with new temperature data</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on cooling demand</li> </ul> <p>Peformance Outline: </p> <ul> <li>If NOAA reports 150 CDD over 30 days (\\(S_t = 150\\))</li> <li>then \\(\\overline{S}_t = 900 - 150 = 750\\)</li> <li>\\(\\rho_T \\approx 0.167\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.833\\). </li> <li>\\(T\\) holders (bullish on high cooling demand) get ~16.7% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~83.3%.</li> </ul> <p>Application</p> <ul> <li>Energy firms hedge heatwave costs</li> <li>Speculators trade on weather forecasts</li> <li>Each new daily temperature updates ratios.</li> </ul>"},{"location":"sections/6applications/#4-cooling-degree-days-in-new-york-for-august","title":"4. Cooling Degree Days in New York for August","text":"<p>Tracks cooling demand for August using NOAA data for seasonal hedging.</p> <p>Events: </p> <ul> <li>Daily CDD, \\(X_t = \\max(0, T_t - 18)\\), in \u00b0C, capped at 30 (\\(X_t \\in \\{0, 0.1, \\dots, 30\\}, m = 30\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = \\sum_{k=0}^{30} X_{t-k}\\) </li> <li>\\(0 \\leq S_t \\leq 930\\) </li> <li>\\(n = 31\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 930 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{930}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{930}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) adjust daily in August, fixed otherwise</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on August cooling demand</li> </ul> <p>Peformance Outline: </p> <ul> <li>If NOAA reports 200 CDD for August (\\(S_t = 200\\))</li> <li>then \\(\\overline{S}_t = 930 - 200 = 730\\)</li> <li>\\(\\rho_T \\approx 0.215\\)</li> <li>\\(\\rho_{\\overline{T}} \\approx 0.785\\). </li> <li>\\(T\\) holders (bullish on high cooling demand) get ~21.5% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~78.5%.</li> </ul> <p>Application</p> <ul> <li>Energy retailers hedge summer demand</li> <li>Speculators take positions on August weather</li> <li>Each new daily temperature in August updates ratios.</li> </ul>"},{"location":"sections/6applications/#5-inflation-rate","title":"5. Inflation Rate","text":"<p>Tracks quarterly inflation rates using U.S. Bureau of Labor Statistics CPI data for economic hedging.</p> <p>Events: </p> <ul> <li>Quarterly inflation rate, in 0.1% increments (\\(X_t \\in \\{0, 0.1, \\dots, 10\\}, m = 10\\)).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = X_t\\) </li> <li>\\(0 \\leq S_t \\leq 10\\)</li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 10 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = \\tfrac{S_t}{10}\\), \\(\\rho_{\\overline{T}} = \\tfrac{\\overline{S}_t}{10}\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) remain fixed between quarterly reports</li> </ul> <p>Price Meaning:</p> <ul> <li>P(T) reflects a discounted long term opinion on inflation trends</li> </ul> <p>Peformance Outline: </p> <ul> <li>If CPI reports 3.2% inflation (\\(S_t = 3.2\\))</li> <li>then \\(\\overline{S}_t = 10 - 3.2 = 6.8\\)</li> <li>\\(\\rho_T = 0.32\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.68\\). </li> <li>\\(T\\) holders (bullish on rising inflation) get ~32% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~68%.</li> </ul> <p>Application</p> <ul> <li>Investors hedge inflation costs</li> <li>Speculators take positions on economic stability</li> <li>Each new quarterly report updates ratios.</li> </ul>"},{"location":"sections/6applications/#6-self-referencing-popularity-index-for-taylor-swift","title":"6. Self-Referencing Popularity Index for Taylor Swift","text":"<p>Tracks public opinion on Taylor Swift's anticipated future popularity through a self-referencing asset, useful for sentiment analysis and cultural hedging.</p> <p>Events: </p> <ul> <li>No external events; self-referencing based on market price of \\(T\\)</li> <li>\\(X_t \\in \\{0, 0.01, \\dots, 1\\}, m = 100\\).</li> </ul> <p>Value:  </p> <ul> <li>\\(S_t = P(T)\\) </li> <li>\\(0 \\leq S_t \\leq 1\\) </li> <li>\\(n = 1\\) </li> </ul> <p>Complement: </p> <ul> <li>\\(\\overline{S}_t = 100 - S_t\\).</li> </ul> <p>Daily Payout Ratios: </p> <ul> <li>\\(\\rho_T = {S_t} = P(T)\\)</li> <li>\\(\\rho_{\\overline{T}} = {\\overline{S}_t} = 1 - P(T)\\)</li> </ul> <p>Behaviour: </p> <ul> <li>\\(\\rho_T\\) and \\(\\rho_{\\overline{T}}\\) update dynamically with changes in \\(P(T)\\), creating a feedback loop</li> </ul> <p>Price Meaning:</p> <ul> <li>\\(P(T)\\) reflects a discounted anticipation of Taylor Swift\u2019s future popularity</li> </ul> <p>Peformance Outline: </p> <ul> <li>If the current market price \\(P(T) = 0.85\\) (\\(S_t = 0.85\\))</li> <li>then \\(\\overline{S}_t = 1 - 0.85 = 0.15\\)</li> <li>\\(\\rho_T = 0.85\\)</li> <li>\\(\\rho_{\\overline{T}} = 0.15\\). </li> <li>\\(T\\) holders (bullish on Taylor Swift\u2019s future popularity) get ~85% of \\(r_t\\)</li> <li>\\(\\overline{T}\\) holders ~15%.</li> </ul> <p>Application</p> <ul> <li>Fans and media speculate on future cultural relevance</li> <li>Brands hedge endorsement risks</li> <li>Market dynamics drive updates through trading activity.</li> </ul>"},{"location":"sections/8new_ideas/","title":"New Ideas for Tokenizing Perpetual Bounded Phenomena","text":""},{"location":"sections/8new_ideas/#1-simplifying-with-annual-binary-outcomes","title":"1. Simplifying with Annual Binary Outcomes","text":"<p>To make development easier and the system more understandable, shift from continuous or frequent updates to annual binary outcomes. Instead of tracking rolling windows or frequent events, focus on yearly yes/no results for specific milestones.</p>"},{"location":"sections/8new_ideas/#key-changes","title":"Key Changes:","text":"<ul> <li>Binary Nature: Outcomes are binary (e.g., achieved or not achieved) and evaluated annually.</li> <li>Examples in Football:</li> <li>Liverpool wins the Premier League.</li> <li>Liverpool qualifies for Champions League.</li> <li>Liverpool qualifies for Europe (Champions or Europa League).</li> <li>Liverpool remains in the Premier League.</li> <li>Dividend Payouts: Dividends are paid based on the current status of the outcome. If the binary condition is met (e.g., team achieves the milestone), token holders receive yields; otherwise, no yields until the next evaluation.</li> <li>Long-Term Holding Incentive: Users can buy tokens for unlikely or long-shot outcomes (e.g., a lower-division team like Northampton Town reaching the Premier League). These tokens may yield nothing for years but could generate significant annual dividends (e.g., turning a $100 investment into $500/year in yields) once the outcome is achieved.</li> </ul>"},{"location":"sections/8new_ideas/#benefits","title":"Benefits:","text":"<ul> <li>Fewer oracle events (annual updates only).</li> <li>Simpler to implement and explain, reducing complexity compared to perpetual or rolling PBPs.</li> </ul> <p>This approach maintains the perpetual aspect but ties yields to discrete, annual checkpoints, making it more accessible for users and developers.</p>"},{"location":"sections/8new_ideas/#2-claimable-rewards","title":"2. Claimable Rewards","text":"<p>Native yield issuance without claiming poses challenges, especially with multiple tokens yielding in the same stablecoin (e.g., USDC). To address this, introduce claimable rewards to simplify yield distribution.</p>"},{"location":"sections/8new_ideas/#key-points","title":"Key Points:","text":"<ul> <li>Claimable Yields: Yields are not automatically distributed but must be claimed by token holders. This avoids building complex systems for handling yields across many tokens in the same asset.</li> <li>Implementation: Yields are accumulated in USDC (or a yield-bearing version like ppUSDC) and can be claimed by holders of T or \\(\\overline{T}\\) based on the performance rubric.</li> </ul>"},{"location":"sections/8new_ideas/#benefits_1","title":"Benefits:","text":"<ul> <li>Simplifies yield management for users and reduces system complexity.</li> <li>Ensures scalability when managing multiple token pairs.</li> </ul>"},{"location":"sections/8new_ideas/#3-rebasing-tokens-as-an-additional-development","title":"3. Rebasing Tokens as an Additional Development","text":"<p>As an additional feature to support users who prefer automated yield handling, introduce rebasing tokens for auto-compounding yields on top of the base system.</p>"},{"location":"sections/8new_ideas/#key-points_1","title":"Key Points:","text":"<ul> <li>Rebasing Tokens:</li> <li>Users deposit base tokens (T or \\(\\overline{T}\\)) into a rebasing contract to receive rebasing versions (e.g., aT for auto-compounding T).</li> <li>The contract holds the base tokens and accumulates claimable interest (in USDC or ppUSDC).</li> <li>Deposits and withdrawals of T or \\(\\overline{T}\\) trigger a swap on Uniswap to convert accumulated interest (USDC or \\(\\overline{T}\\)) into the deposited token type (e.g., depositing T triggers swapping \\(\\overline{T}\\) or USDC to T). This ensures the contract maintains a balanced pool for aT holders while leveraging Uniswap\u2019s market pricing.</li> <li>Deposit and Withdrawal Handling:<ul> <li>Deposits: Users deposit T or \\(\\overline{T}\\), and the contract mints aT based on a share price (<code>total_underlying / total_aT_supply</code>). The share price accounts for held T, \\(\\overline{T}\\) (valued at Uniswap\u2019s current price), and USDC (valued as mintable T + \\(\\overline{T}\\) sold on Uniswap). Deposits trigger a Uniswap swap to convert any \\(\\overline{T}\\) or USDC to T (or vice versa for \\(\\overline{T}\\) deposits), maintaining pool balance.</li> <li>Withdrawals: Redeeming aT returns T or \\(\\overline{T}\\) based on the share price. If insufficient T is available, the contract swaps \\(\\overline{T}\\) or USDC to T on Uniswap to fulfill the withdrawal.</li> <li>This prevents overpayment for new depositors by ensuring they receive a fair share of the contract\u2019s current value, adjusted for Uniswap\u2019s market rates.</li> </ul> </li> <li>The contract periodically claims USDC yields, splits them into T and \\(\\overline{T}\\), and uses Uniswap swaps to align holdings with deposited token types.</li> </ul>"},{"location":"sections/8new_ideas/#benefits_2","title":"Benefits:","text":"<ul> <li>Enables auto-compounding via rebasing for hands-off users, simplifying the user experience.</li> <li>Simplifies valuation by relying on Uniswap\u2019s market pricing, avoiding complex internal pricing algorithms.</li> </ul>"},{"location":"sections/8new_ideas/#4-internal-liquidity-as-a-positive-externality","title":"4. Internal Liquidity as a Positive Externality","text":"<p>The rebasing contract, by facilitating the conversion of T to \\(\\overline{T}\\) (or vice versa) via Uniswap swaps, also serves as a liquidity provider, creating a positive externality for the system.</p>"},{"location":"sections/8new_ideas/#key-points_2","title":"Key Points:","text":"<ul> <li>Liquidity Provision:</li> <li>The rebasing contract supports swaps between T and \\(\\overline{T}\\) by leveraging Uniswap for conversions, triggered by deposits or withdrawals. For example, depositing T may require swapping \\(\\overline{T}\\) or USDC to T on Uniswap to maintain pool balance.</li> <li>General Principle: When a swap is needed, the contract uses Uniswap\u2019s current market price (potentially with a TWAP for stability) to execute trades. This ensures liquidity for users while aligning the contract\u2019s holdings with user deposits.</li> <li>This creates a balanced, automated market within the contract, improving the liquidity of the system.</li> <li>Positive Externality: The need to manage complementary tokens (T and \\(\\overline{T}\\)) inherently provides liquidity to the system by facilitating Uniswap-based trades, enhancing market depth and accessibility.</li> </ul>"},{"location":"sections/8new_ideas/#benefits_3","title":"Benefits:","text":"<ul> <li>Enhances liquidity through Uniswap integration, leveraging external market efficiency.</li> <li>Creates a self-sustaining system where token conversion supports overall market efficiency.</li> </ul>"},{"location":"sections/8new_ideas/#handling-deposits-and-withdrawals-with-uniswap-integration","title":"Handling Deposits and Withdrawals with Uniswap Integration","text":"<p>To address the concern about overpayment when depositing into the rebasing contract (e.g., if significant interest has accumulated), the system uses a share-based model with Uniswap swaps to ensure fairness:</p> <ul> <li>Deposit Process:</li> <li>On T deposit, the contract claims accumulated USDC yields and swaps for T and \\(\\overline{T}\\).</li> <li>The contract swaps \\(\\overline{T}\\) to T on Uniswap.</li> <li>This updates user balances of aT</li> <li> <p>Mint aT = deposited T</p> </li> <li> <p>Withdrawal Process:</p> </li> <li>Claim accumulated ppUSDC</li> <li>Update balances of aT</li> <li>Burn aT being withdrawn</li> <li> <p>transfer amount of T equalt to aT being withdrawn to the user.</p> </li> <li> <p>Benefits of Uniswap Integration:</p> </li> <li>Fairness: Using Uniswap\u2019s market price (or TWAP) ensures new depositors don\u2019t receive disproportionate value from accumulated interest, preventing overpayment.</li> <li>Simplicity: Eliminates the need for a complex internal pricing algorithm, relying on Uniswap\u2019s established liquidity and pricing</li> <li>Liquidity Boost: Swaps triggered by deposits/withdrawals add trading volume to Uniswap pools, enhancing overall system liquidity.</li> <li>Trade-Off: Uniswap prices may not always be optimal (e.g., slippage or market volatility), but TWAP usage and sufficient pool depth can mitigate this. It\u2019s a practical trade-off for simplicity and reliability.</li> </ul> <p>This approach streamlines the rebasing contract by leveraging Uniswap for pricing and liquidity, ensuring fair deposits/withdrawals while maintaining the system\u2019s core mechanics.</p>"},{"location":"sections/9new_ideas2/","title":"Token Rebasing System Specification","text":"<p>This document outlines the design for a token rebasing system integrated with binary event resolution using UMA bonds and Uniswap V2 pools. The system simplifies event settlement and incentivizes frequent rebalancing through a dual-token mechanism with <code>T</code>, <code>T-bar</code>, <code>aT</code>, and <code>aT-bar</code> tokens, managed by a controller contract.</p>"},{"location":"sections/9new_ideas2/#binary-event-resolution","title":"Binary Event Resolution","text":""},{"location":"sections/9new_ideas2/#overview","title":"Overview","text":"<p>The system reduces complex phenomena to binary events with long-term outcomes, settled via UMA bonds for simplified implementation.</p>"},{"location":"sections/9new_ideas2/#key-points","title":"Key Points","text":"<ol> <li>Event Structure:</li> <li>Binary events are defined with clear, verifiable outcomes.</li> <li>Example: \"The most recent football season ended with the last match day on May 11th, 2025.\"</li> <li>Derived statement: \"Liverpool won the Premier League Football season that ended on May 11th, 2025.\"</li> <li>UMA Integration:</li> <li>Binary events are pushed to UMA for resolution, leveraging UMA bonds to ensure reliable settlement.</li> </ol>"},{"location":"sections/9new_ideas2/#rebasing-token-mechanism","title":"Rebasing Token Mechanism","text":""},{"location":"sections/9new_ideas2/#core-concepts","title":"Core Concepts","text":"<p>The rebasing system uses two primary tokens, <code>T</code> and <code>T-bar</code>, with their respective rebasing tokens <code>aT</code> and <code>aT-bar</code>. USDC serves as the reward and exchange currency, with Uniswap V2 pools facilitating liquidity and rebalancing. A controller contract manages the minting and distribution of tokens during rebalancing.</p>"},{"location":"sections/9new_ideas2/#token-mechanics","title":"Token Mechanics","text":"<ol> <li>Rewards:</li> <li>Rewards are claimable in USDC for holders of token <code>T</code> and <code>T-bar</code>.</li> <li>Uniswap V2 pools exist for:<ul> <li>USDC/<code>T</code></li> <li>USDC/<code>T-bar</code></li> </ul> </li> <li>Exchange rates:<ul> <li>1 USDC is exchangeable for 1 <code>T</code> or 1 <code>T-bar</code>.</li> <li>Burning 1 <code>T</code> and 1 <code>T-bar</code> yields 1 USDC.</li> </ul> </li> <li>Deposits and Withdrawals:</li> <li>Deposit <code>T</code> to receive <code>aT</code> at a 1:1 ratio.</li> <li>Deposit <code>T-bar</code> to receive <code>aT-bar</code> at a 1:1 ratio.</li> <li>Burn <code>aT</code> to receive <code>T</code> at a 1:1 ratio.</li> <li>Burn <code>aT-bar</code> to receive <code>T-bar</code> at a 1:1 ratio.</li> </ol>"},{"location":"sections/9new_ideas2/#rebalance-process","title":"Rebalance Process","text":"<p>The <code>Rebalance()</code> function manages the rebasing process between the <code>aT</code> and <code>aT-bar</code> contracts, utilizing Uniswap V2 TWAP and the <code>T/T-bar</code> controller contract. The function can be called by anyone, with incentives to increase call frequency as locked value grows.</p> <ol> <li>USDC Claim and Transfer:</li> <li>The <code>aT</code> contract claims USDC and transfers it to the controller.</li> <li>The <code>aT-bar</code> contract claims USDC and transfers it to the controller.</li> <li>TWAP Calculation:</li> <li>The <code>aT</code> contract uses TWAP since the last rebalance to calculate the amount of <code>T</code> it should receive for its USDC (denoted as value <code>b</code>).</li> <li>The <code>aT-bar</code> contract uses TWAP since the last rebalance to calculate the amount of <code>T-bar</code> it should receive for its USDC (denoted as value <code>c</code>).</li> <li>Minting and Rebasing:</li> <li>The controller mints <code>min(b, c)</code> pairs of <code>T</code> and <code>T-bar</code> using the USDC it holds, depositing claimed USDC into the <code>T/T-bar</code> controller contract.</li> <li>Minted <code>T</code> is sent to the <code>aT</code> contract, and minted <code>T-bar</code> is sent to the <code>aT-bar</code> contract.</li> <li>After minting, either the <code>aT</code> or <code>aT-bar</code> contract retains residual USDC, as only the minimum of <code>b</code> and <code>c</code> is minted.</li> <li>Rebalancing with TWAP Threshold:</li> <li>The contract rebases against Uniswap V2 using TWAP, triggered when the TWAP deviates by a predefined threshold.</li> <li>If the TWAP threshold is not met, the contract records a new TWAP checkpoint for the next rebalance and performs a partial rebase without executing a Uniswap swap.</li> <li>Incentives for Rebase Calls:</li> <li>The <code>Rebalance()</code> function is permissionless, allowing anyone to call it and earn a reward. The reward is a percentage of the total USDC claimed by <code>aT</code> and <code>aT-bar</code> contracts during the rebalance. A 1% reward is likely sufficient to incentivize frequent calls. Initially, the dev team will deploy a bot to call <code>Rebalance()</code> regularly, ensuring consistent operation. As the total locked value in the system increases, the USDC reward will incentivize additional external users to trigger the function more frequently, resulting in smoother and more continuous rebasing.</li> <li>Deposit Pending Period:</li> <li>When a user deposits <code>T</code> to receive <code>aT</code> (or <code>T-bar</code> to receive <code>aT-bar</code>), the deposit is non-transferable during the period before the next rebalance, referred to as the \"Pending Period.\" However, the deposit can be withdrawn during this period.</li> <li>Rebasing for that specific user deposit does not begin until the respective contract (<code>aT</code> or <code>aT-bar</code>) is fully rebased (i.e., no claimable USDC remains). This means the user may miss the first rebase period (or part thereof) for their deposit.</li> </ol>"},{"location":"sections/9new_ideas2/#additional-notes","title":"Additional Notes","text":"<ul> <li>A full specification for the deposit rebase delay and Pending Period is available separately.</li> <li>The system ensures continuous rebalancing to maintain stability, with incentives designed to encourage frequent user-driven rebase calls, especially as the locked value grows.</li> </ul>"}]}