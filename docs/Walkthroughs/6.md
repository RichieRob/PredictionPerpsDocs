---
title: LMSR — Math → Code by Action (Buy/Sell · Back/Lay)
description: Exactly how the four trading actions map from the LMSR math (Δ state cost) into Solidity (quotes, execution, and O(1) updates).
---

# LMSR — Math → Code by Action

> Goal: for each action (**Buy Back**, **Buy Lay**, **Sell Back**, **Sell Lay**), show the math you know from the LMSR doc (cost of *changing state*) and the exact Solidity that implements it.

**Companion docs**
- Math: [**LMSR as O(1)**](./LMSRasO1.md)
- Execution: [**Purchase Flow — LMSR**](../Flows/PurchaseToken/PurchaseFlowLMSR.md)
- Walkthrough: [**Pricing Walkthrough — Fruit**](../Walkthroughs/PricingWalkthroughFruit.md)

**Key contracts/libs**
- `LMSRMarketMaker.sol`
- `AMMLibraries/LMSRQuoteLib.sol` (quotes)
- `AMMLibraries/LMSRExecutionLib.sol` (buys/sells)
- `AMMLibraries/LMSRUpdateLib.sol` (O(1) state update)
- `AMMLibraries/LMSRViewLib.sol` (prices & Z)
- `AMMLibraries/LMSRHelpersLib.sol` (denominator, listing)
- `AMMLibraries/LMSRMathLib.sol` (exp + fixed‑point helpers)

---

## 0) Symbols you’ll see (from the math doc)

- \(p_i\) — current **Back** price for outcome *i*
- \(t\) — token amount (positive size of the trade)
- \(b\) — liquidity depth
- **Cost of state change**: \(m = C(q + \Delta) - C(q)\)

> **On-chain scales**: prices & internals at **1e18**; USDC **1e6**; \(b\) uses sd59x18.  
> Price denominator in code: `denom = S_tradables + R_reserve` (both **1e18**).

---

## 1) BUY · BACK(i)

### Math (cost of change)
\( m = b \cdot \ln\big( 1 - p_i + p_i \, e^{t/b} \big) \)

### Quote path (no fee)
```solidity
// LMSRQuoteLib.quoteBuyInternal(..., isBack=true, t)
int256 pWad = (self.R[marketId][slot] * WAD) / denom(self, marketId);
int256 eTB  = LMSRMathLib.expRatioOverB(self.b[marketId], int256(t)); // e^{+t/b}
int256 termWad = WAD - pWad + pWad.wmul(eTB);
int256 mSigned = (self.b[marketId] * termWad.ln()) / WAD; // -> m (1e6)
```

## State Update from the maths document

### State Update (from the math)

We use the global–local decomposition \(q_i = U_{\text{all}} + u_i\) with
\(G = e^{U_{\text{all}}/b}\) and \(R_i = e^{u_i/b}\).

For **BUY · BACK(i)** the math update is:
- \(\Delta U_{\text{rest}} = 0\)
- \(\Delta U_{k} = +t\)  (only the traded outcome \(k=i\) gets a local bump)

Resulting state transitions:

\[
\begin{aligned}
G' &= G \cdot e^{\Delta U_{\text{rest}}/b}
    = G \cdot e^{0}
    = G, \\[6pt]
R_k' &= R_k \cdot e^{(\Delta U_k - \Delta U_{\text{rest}})/b}
     = R_k \cdot e^{t/b}, \\[6pt]
S_{\text{tradables}}' &= S_{\text{tradables}} - R_k + R_k'. \\[6pt]
\end{aligned}
\]

The **price denominator** is

\[
D = S_{\text{tradables}} + R_{\text{reserve}},
\quad
D' = S_{\text{tradables}}' + R_{\text{reserve}}
\]

(\(R_{\text{reserve}}\) is unchanged by trades).

Updated prices:

\[
p_k' = \frac{R_k'}{D'}, 
\qquad
p_j' = \frac{R_j}{D'} \ \ (j \neq k).
\]

**Intuition:** \(R_k\) scales by \(e^{t/b}\) while the global factor \(G\) stays fixed;
the denominator \(D'\) grows (because \(S_{\text{tradables}}\) grows), so \(p_k\) rises and the
other listed prices fall proportionally via the shared denominator.


### Implementation of state Update

```solidity
// LMSRUpdateLib.applyUpdateInternal(... isBack=true, isBuy=true)
dU_rest = 0;            // global
dU_k    = +t;           // local to i
G      *= exp(dU_rest/b);
R_k    *= exp((dU_k - dU_rest)/b);   // = exp(+t/b)
S_tradables += (R_k_new - R_k_old);  // denom = S_tradables + R_reserve
```

Result: \(p_i\) increases; others decrease via the shared denominator.

---