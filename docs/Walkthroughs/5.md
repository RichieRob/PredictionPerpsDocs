---
title: LMSR Math → Solidity Implementation
description: Explains how each part of the LMSR math maps to the actual Solidity implementation in the O(1) market maker.
---

# LMSR Math → Solidity Implementation

> A readable, practical bridge between the **LMSR math** in [LMSR as O(1)](LMSRasO1.md)  
> and the **Solidity code** that actually executes trades.

This guide follows the *life of a trade* — how the mathematical formula  
\( C(q + Δq) - C(q) \) becomes executable code, updating only three variables:  
**G**, **Rᵢ**, and **S**.

---

## 1 · The Trade Equation: `C(q + Δq) − C(q)`

In the math, every trade represents a *change of state*:

\[
m = C(q + Δq) − C(q)
\]

This difference is the **cost of the trade** — the amount of USDC a trader pays or receives.

We never compute `C(q)` itself — only its difference.  
In LMSR this becomes:

\[
m = b \, \ln \frac{Z_{new}}{Z_{old}}.
\]

### Implementation

```solidity
// LMSRQuoteLib.quoteBuyInternal(...)
termWad = WAD - pWad + pWad.wmul(eTB);
mSigned = (self.b[marketId] * termWad.ln()) / WAD;
```

This line *is literally*:

\[
m = b \ln(1 - p + p e^{t/b})
\]

— the discrete implementation of \( C(q + Δq) - C(q) \).

---

## 2 · Avoiding Full Recalculation of the Exponential Sum

In theory, prices depend on the **partition function**:

\[
Z = \sum_i e^{q_i / b}.
\]

Naively, that would require looping over all outcomes after every trade.

To make this **O(1)**, we decompose each \( q_i \) into global and local parts:

\[
q_i = U_{all} + u_i.
\]

Then we factor the exponential:

\[
e^{q_i/b} = e^{U_{all}/b} e^{u_i/b}.
\]

### Implementation

```solidity
G = exp(U_all / b);      // global multiplier
R[i] = exp(u_i / b);     // local multiplier per outcome
S_tradables = Σ R[i];    // sum of listed slots
R_reserve = reserve mass;
```

Hence, the partition function becomes:

\[
Z = G \cdot (S_{tradables} + R_{reserve}).
\]

This is cached and updated incrementally after every trade.

---

## 3 · Deriving Prices from Cached Values

The LMSR instantaneous price of outcome *i* is:

\[
p_i = \frac{e^{q_i/b}}{Z} = \frac{R_i}{S_{tradables} + R_{reserve}}.
\]

### Implementation

```solidity
function getBackPriceWadInternal(...) returns (uint256) {
    return (self.R[marketId][slot] * WAD)
         / LMSRHelpersLib.denom(self, marketId);
}
```

The helper function `denom()` returns:

\[
S = S_{tradables} + R_{reserve},
\]

the live cached denominator replacing \( \sum_i e^{q_i/b} \).

---

## 4 · How a Trade Updates State in O(1)

When a trade occurs, only **one** outcome’s local component changes.  
The global component may also shift, depending on trade type (BACK or LAY).

### Mathematical Form

| Step | Math | Description |
|------|------|--------------|
| Global multiplier | \( G' = G \, e^{ΔU_{rest}/b} \) | Shared shift for all outcomes |
| Local multiplier | \( R_k' = R_k \, e^{(ΔU_k−ΔU_{rest})/b} \) | Adjustment to the traded slot |
| Sum update | \( S' = S − R_k + R_k' \) | Cached running total |

### Implementation

```solidity
int256 e_rest  = LMSRMathLib.expRatioOverB(self.b[marketId], dU_rest);
int256 e_local = LMSRMathLib.expRatioOverB(self.b[marketId], dU_k - dU_rest);

self.G[marketId] = self.G[marketId].wmul(e_rest);
int256 Ri_new = self.R[marketId][slot].wmul(e_local);
self.R[marketId][slot] = Ri_new;
self.S_tradables[marketId] =
    self.S_tradables[marketId] - Ri_old + Ri_new;
```

No loops — just three updates per trade.

---

## 5 · The Denominator as Cached Z

Everywhere in the code, the denominator \( S + R_{reserve} \) replaces the full exponential sum.

### Math

\[
Z = G \cdot (S + R_{reserve}).
\]

### Code

```solidity
function denom(self, marketId)
    internal view returns (uint256) {
    return self.S_tradables[marketId]
         + self.R_reserve[marketId];
}
```

and

```solidity
function getZInternal(...) returns (uint256) {
    return self.G[marketId].wmul(denom(self, marketId));
}
```

This makes every quote and price retrieval O(1).

---

## 6 · Setting `b` from Market Liability

The liquidity parameter `b` defines how sensitive prices are to trade size.

Mathematically:

\[
b = \frac{liability_{USDC}}{\ln(n)}.
\]

Implementation:

```solidity
function calculateB(uint256 liabilityUSDC, uint256 n)
    internal pure returns (int256) {
    int256 lnNWad = PRBMathSD59x18.ln(int256(n) * 1e18);
    return (int256(liabilityUSDC) * 1e18) / lnNWad;
}
```

This ensures that the maximum loss of the market maker equals its initial (synthetic) liquidity.

---

## 7 · Initialization Summary

During market creation:

1. **Set b** from liability and number of outcomes.  
2. **Normalize priors** so listed outcomes + reserve sum to `1e18`.  
3. **Store**:
   - `R[slot]` for each outcome  
   - `S_tradables = ΣR`  
   - `R_reserve` for the “Other” outcome  
   - `G = 1e18` (neutral global)  
   - Mappings `ledgerId ↔ slot`

After initialization, prices immediately reflect the starting weights.

---

## 8 · Summary Table

| Concept | Math Expression | Implementation | Stored As |
|----------|-----------------|----------------|-----------|
| Trade cost | \( m = b \ln(Z_{new}/Z_{old}) \) | `quoteBuyInternal`, `quoteSellInternal` | — |
| Global factor | \( G = e^{U_{all}/b} \) | O(1) cached multiplier | `G[marketId]` |
| Local factor | \( R_i = e^{u_i/b} \) | Per‑slot multiplier | `R[marketId][slot]` |
| Denominator | \( S = S_{tradables} + R_{reserve} \) | Sum of all outcomes | `denom(self, marketId)` |
| Price (Back) | \( p_i = R_i / (S_{tradables} + R_{reserve}) \) | `getBackPriceWadInternal` | — |
| Liquidity depth | \( b = liability / \ln(n) \) | `calculateB(...)` | `b[marketId]` |

---

## 9 · Summary

- The AMM never computes \(C(q)\) directly — only the **difference** between two states.  
- The heavy exponential sum is factored into three scalars: **G**, **Rᵢ**, and **S**.  
- Prices, costs, and updates all reduce to a few cached multiplications.  
- The denominator `(S_tradables + R_reserve)` is the live stand‑in for \( \sum_i e^{q_i/b} \).  
- Initialization links the *math* parameters (b, priors) to concrete on‑chain state.

---

For the original derivations, see:  
→ [**LMSR as O(1)**](LMSRasO1.md)  
For a numerical example, see:  
→ [**Pricing Walkthrough — Fruit Market**](../Walkthroughs/PricingWalkthroughFruit.md)
