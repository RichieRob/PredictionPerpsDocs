---
title: LMSR Math → Contract Mapping
description: A practical guide that connects the LMSR formulas to the exact Solidity state, functions, and update paths in the LMSR AMM.
---

# LMSR Math → Contract Mapping

> **Goal**: make it crystal clear how the **math** (LMSR) is implemented in the **contract**.  
> **Audience**: anyone reading the LMSR math doc who wants to see where each piece lives on-chain.

**Companion docs**  
- Math: [**LMSR as O(1)**](./LMSRasO1.md) *(name may differ—use your actual path)*  
- Walkthrough: [**Pricing Walkthrough — Fruit Market**](../Walkthroughs/PricingWalkthroughFruit.md)  
- Flows: [**Market Initialisation**](../Flows/MarketInitialisation.md), [**Purchase Flow — LMSR**](../Flows/PurchaseToken/PurchaseFlowLMSR.md)

**Contract & Libraries (key files)**  
- `contracts/AMM/LMSRMarketMaker.sol`  
- `contracts/AMM/AMMLibraries/LMSRInitLib.sol` *(init & normalization → sets b, R, G, reserve)*  
- `contracts/AMM/AMMLibraries/LMSRQuoteLib.sol` *(quotes: BACK & true LAY)*  
- `contracts/AMM/AMMLibraries/LMSRUpdateLib.sol` *(O(1) state updates: G, R_k, S)*  
- `contracts/AMM/AMMLibraries/LMSRHelpersLib.sol` *(denominator, listing check)*  
- `contracts/AMM/AMMLibraries/LMSRViewLib.sol` *(prices, Z, reserve, listing view)*  
- `contracts/AMM/AMMLibraries/LMSRTwapO1Lib.sol` *(O(1) TWAP accumulator)*  
- `contracts/AMM/AMMLibraries/LMSRMathLib.sol` *(exp ratio & 1e18 math helpers)*

---

## 1) Symbols → Storage (Cheat Sheet)

| Math symbol | Meaning | Contract storage / getter | Scale | Notes |
|---|---|---|---|---|
| **b** | Liquidity depth parameter | `b[marketId]` |   1e18 | Set by `LMSRInitLib.calculateB(liabilityUSDC, n) = liability / ln(n)` |
| **qᵢ** | Shares for outcome *i* | Not stored directly | — | Implemented via O(1) decomposition: `qᵢ = U_all + uᵢ` |
| **U_all** | Global component of all qᵢ | Not stored directly | — | Cached via `G = exp(U_all / b)` |
| **G** | `exp(U_all / b)` | `G[marketId]` |   1e18 | Updated multiplicatively in `LMSRUpdateLib.applyUpdateInternal` |
| **uᵢ** | Local deviation for outcome *i* | Not stored directly | — | Cached via `Rᵢ = exp(uᵢ / b)` |
| **Rᵢ** | `exp(uᵢ / b)` per listed slot | `R[marketId][slot]` |   1e18 | One value per **AMM slot** (listed outcome) |
| **S** | `∑ᵢ Rᵢ` (listed only) | `S_tradables[marketId]` |   1e18 | Running sum of listed `Rᵢ` values |
| **R_reserve** | Non‑tradable reserve mass | `R_reserve[marketId]` |   1e18 | Holds “Other”; can be split into a new listing |
| **denom** | `S + R_reserve` | via `LMSRHelpersLib.denom(self, marketId)` |   1e18 | Price denominator; must be `> 0` |
| **Z** | `∑ᵢ e^{qᵢ/b} = G · (S + R_reserve)` | `LMSRViewLib.getZInternal` |   1e18 | Partition function |
| **pᵢ** | `e^{qᵢ/b}/Z = Rᵢ / (S + R_reserve)` | `LMSRViewLib.getBackPriceWadInternal` | **1e18** | Back price of listed outcome *i* |
| **1 − pᵢ** | True LAY(not‑i) price | `WAD - getBackPriceWadInternal(...)` | **1e18** | Complement of the back price |
| **price(Other)** | Reserve “Other” price | `LMSRViewLib.getReservePriceWadInternal` | **1e18** | `R_reserve / (S + R_reserve)` |

> **Scale conventions**
> - Prices, `G`, `Rᵢ`, `S`, `R_reserve`, `Z` → **1e18** fixed‑point.  
> - USDC amounts in quotes/exec → **1e6**.  
> - `b` uses **sd59x18** via PRBMath (effectively 1e18 scale).

---

## 2) Initialization: where math becomes state

### 2.1 Setting **b** from “liability”
Math: `b = liabilityUSDC / ln(n)`  
Code (in `LMSRInitLib`):

```solidity
// sd59x18 math: ln(n) and scaling
function calculateB(uint256 liabilityUSDC, uint256 _numInitial) internal pure returns (int256 _b) {
    int256 numWad = int256(_numInitial) * int256(LMSRMarketMaker.WAD);  // n in 1e18
    int256 lnNWad = PRBMathSD59x18.ln(numWad);                          // ln(n) in 1e18
    _b = (int256(liabilityUSDC) * int256(LMSRMarketMaker.WAD)) / lnNWad;
}
```

### 2.2 Priors and normalization (Rᵢ & reserve)
Math: choose initial prices (incl. “Other”), sum to 1.0.  
Code: `_normalizeToWadTotal(...)` (short‑circuits if already 1e18 total; otherwise scales positions + reserve to sum ≈ `1e18`, with dust tolerance).

Stores:
- `R[marketId][slot] = rᵢ` (1e18)  
- `S_tradables[marketId] = ∑ rᵢ`  
- `R_reserve[marketId] = reserve_final`  
- `G[marketId] = 1e18` (neutral global)  
- mapping **ledger id ↔ slot** (1‑based sentinel for “listed” check)

---

## 3) Prices: `pᵢ = Rᵢ / (S + R_reserve)`

Math: `pᵢ = e^{qᵢ/b}/Z = Rᵢ / (S + R_reserve)`

Code (in `LMSRViewLib`):
```solidity
function getBackPriceWadInternal(...) returns (uint256) {
    uint256 slot = LMSRHelpersLib.requireListed(self, marketId, ledgerPositionId);
    return uint256((self.R[marketId][slot] * WAD) / LMSRHelpersLib.denom(self, marketId));
}

function getLayPriceWadInternal(...) returns (uint256) {
    return WAD - getBackPriceWadInternal(...);
}

function getReservePriceWadInternal(...) returns (uint256) {
    return uint256((self.R_reserve[marketId] * WAD) / LMSRHelpersLib.denom(self, marketId));
}
```

> **Why it’s O(1)**: prices only need `Rᵢ` (one slot) and the pre‑cached `denom = S + R_reserve`.

---

## 4) Quotes (closed‑form): BACK & true LAY

From the math doc (Hanson 2003):  
- **BACK buy (size t)**: `m = b · ln(1 − p + p·e^{t/b})`  
- **LAY(not‑i) buy (size t)**: `m = b · ln(p + (1 − p)·e^{t/b})`

Code (in `LMSRQuoteLib` → `quoteBuyInternal` / `quoteSellInternal`):
```solidity
// mNoFee (1e6) using p in 1e18 and b in sd59x18
if (isBack)      termWad = WAD - pWad + pWad.wmul(eTB);      // e^{+t/b}
else             termWad = pWad + (WAD - pWad).wmul(eTB);

mSigned = (self.b[marketId] * termWad.ln()) / WAD;
```

**Exact USDC‑in → tokens out** (closed‑form inverse): `quoteBuyForUSDCInternal`  
- BACK:  `t = b · ln( 1 + (exp(m/b) − 1)/p )`  
- true LAY: `t = b · ln( (exp(m/b) − p)/(1 − p) )`

The library also handles **fees** in the wrapper functions.

---

## 5) O(1) State Updates (global/local shifts)

Math (from the decomposition):  
- Keep `Z = G · (S + R_reserve)`; update local `R_k` and global `G`.  
- For trade of size `t` on slot `k`, define:
  - BACK buy:  `(ΔU_rest, ΔU_k) = (0, +t)`  
  - BACK sell: `(0, −t)`  
  - LAY  buy:  `(+t, 0)` *(true not‑k)*  
  - LAY  sell: `(−t, 0)`

Then:
- `G ← G · exp(ΔU_rest / b)`  
- `R_k ← R_k · exp((ΔU_k − ΔU_rest)/b)`  
- `S ← S − R_k_old + R_k_new`

Code (in `LMSRUpdateLib.applyUpdateInternal`):
```solidity
int256 e_rest  = LMSRMathLib.expRatioOverB(self.b[marketId], dU_rest);
int256 e_local = LMSRMathLib.expRatioOverB(self.b[marketId], dU_k - dU_rest);

self.G[marketId]      = self.G[marketId].wmul(e_rest);
int256 Ri_new         = self.R[marketId][slot].wmul(e_local);
self.R[marketId][slot]= Ri_new;
self.S_tradables[...] = self.S_tradables[...] - Ri_old + Ri_new;
```

> **Takeaway**: This is the exact embodiment of the O(1) math in the code. No loop over outcomes.

---

## 6) Execution Flow (Buy/Sell) and TWAP

**Execution** (`LMSRExecutionLib`):  
1. `requireListed` → slot lookup (ledger id ↔ slot)  
2. TWAP accrue **before** price change (`LMSRTwapO1Lib.updateBeforePriceChange`)  
3. Quote (closed‑form), fee handling, slippage check  
4. Ledger mint/burn + USDC pull/push (`ILedger.processBuy` / `processSell`)  
5. **O(1) update** (`LMSRUpdateLib.applyUpdateInternal`)  
6. TWAP baseline **after** price change (`updateAfterPriceChange`)  
7. Emit `Trade` and `PriceUpdated` events

**TWAP** (`LMSRTwapO1Lib`) is an **O(1)** accumulator:  
- Global time anchor `twapJ` advances proportional to Δt / denom  
- Per‑slot cumulative: `twapCum[slot] += price(slot) × Δt`  
- Off‑chain: `TWAP = (cum₁ − cum₀) / (t₁ − t₀)`

---

## 7) Expansion: listing & splitting

Two ways to add a position:

1) **`listPositionInternal`** — append a *new* slot with prior `Rᵢ`  
   - Shifts all prices because `S` changes.

2) **`splitFromReserveInternal`** — move `α` of `R_reserve` into a *new* slot  
   - Keeps `S + R_reserve` unchanged ⇒ **price continuity** for existing listings.

Both update the slot mapping:
- `slotOf[marketId][ledgerId] = slot + 1` *(1‑based to use `0` as “not listed”)*  
- `ledgerIdOfSlot[marketId][slot] = ledgerId`

---

## 8) Common Pitfalls (and where the code guards them)

- **Scale mixups**: prices & R/G/S are **1e18**; quotes use **1e6** USDC; `b` is **sd59x18**.  
- **denom = 0**: guarded in `LMSRHelpersLib.denom`.  
- **Unlisted id**: `requireListed` returns slot; 1‑based sentinel prevents false positives.  
- **Reserve semantics**: in fixed markets, reserve must be `0`; in expanding, reserve must be `> 0` (checked in init & normalize).  
- **Normalization dust**: `_normalizeToWadTotal` reverts if `|sum − 1e18| > DUST_TOLERANCE` (no “patching”).

---

## 9) Minimal Cross‑Reference

- **Prices** → `LMSRViewLib.getBackPriceWadInternal`, `getLayPriceWadInternal`, `getReservePriceWadInternal`  
- **Quotes** → `LMSRQuoteLib.quoteBuyInternal`, `quoteSellInternal`, `quoteBuyForUSDCInternal`  
- **O(1) Update** → `LMSRUpdateLib.applyUpdateInternal`  
- **Init** → `LMSRInitLib.initMarketInternal`, `calculateB`, `_normalizeToWadTotal`  
- **Expansion** → `LMSRExpansionLib.listPositionInternal`, `splitFromReserveInternal`  
- **TWAP** → `LMSRTwapO1Lib` (before/after & views)  
- **Helpers** → `LMSRHelpersLib.denom`, `requireListed`

---

## 10) TL;DR: From Formula to Code

- `pᵢ = e^{qᵢ/b}/Z` → `pᵢ = Rᵢ / (S + R_reserve)` → **`getBackPriceWadInternal`**  
- `Z = ∑ e^{qᵢ/b}` → `Z = G · (S + R_reserve)` → **`getZInternal`**  
- BACK/LAY costs & inverse are **exact closed‑forms** → **`LMSRQuoteLib`**  
- O(1) updates of `G`, `R_k`, `S` implement the math shifts → **`LMSRUpdateLib`**  
- Initialization maps priors to `R`/`reserve`, sets `b` from liability → **`LMSRInitLib`**

That’s the bridge: every formula in the math doc has a single, obvious home in code.
