---
title: LMSR Math → Contract Mapping (Strict Symbols)
description: Connects symbols defined in *LMSR as O(1)* to their exact Solidity state and functions.
---

# LMSR Math → Contract Mapping (Strict Symbols)

> This page **only** maps symbols that appear in the math document **“LMSR as O(1)”** to where they live in the contract code.
>
> Companion: see the math itself in **LMSR as O(1)**. This page is the bridge to Solidity.

**Key contract files**
- `contracts/AMM/LMSRMarketMaker.sol`
- `contracts/AMM/AMMLibraries/LMSRInitLib.sol`
- `contracts/AMM/AMMLibraries/LMSRQuoteLib.sol`
- `contracts/AMM/AMMLibraries/LMSRUpdateLib.sol`
- `contracts/AMM/AMMLibraries/LMSRHelpersLib.sol`
- `contracts/AMM/AMMLibraries/LMSRViewLib.sol`
- `contracts/AMM/AMMLibraries/LMSRTwapO1Lib.sol`
- `contracts/AMM/AMMLibraries/LMSRMathLib.sol`

---

## 1) Symbols from the Math Doc → Where in Contract

| **Math Symbol** | **Meaning (as in the math doc)** | **Where in Contract** | **Scale** | **Notes** |
|---|---|---|---|---|
| **C(\mathbf{q})** | Cost function | Not stored; realized via quote/execution math in `LMSRQuoteLib` | USDC 1e6 | Trade cost `m = C(q+\Delta)-C(q)` is computed by closed forms. |
| **\mathbf{q} = (q_1,\ldots,q_n)** | Outstanding shares vector | Not stored directly | — | Represented via decomposition: `q_i = U_all + u_i`. |
| **b** | Liquidity parameter | `b[marketId]` (set in `LMSRInitLib.calculateB`) | sd59x18 (≈1e18) | Computed as `b = liabilityUSDC / ln(n)`. |
| **Z(\mathbf{q}) = \sum_i e^{q_i/b}** | Partition function | `LMSRViewLib.getZInternal(self, marketId)` | 1e18 | Implemented as `Z = G · (S + R_reserve)`. |
| **p_i = e^{q_i/b}/Z** | Instant price of outcome *i* (BACK) | `LMSRViewLib.getBackPriceWadInternal(self, marketId, ledgerId)` | 1e18 | Uses cached `R_i` and denominator `(S + R_reserve)`. |
| **1 - p_i** | True LAY(not‑i) price | `WAD - getBackPriceWadInternal(...)` | 1e18 | Exact complement. |
| **U_all** | Global component of all `q_i` | Not stored directly | — | Cached as `G = exp(U_all / b)`. |
| **G = e^{U_all/b}** | Global multiplier | `G[marketId]` | 1e18 | Updated multiplicatively in O(1) updates. |
| **u_i** | Local deviation for outcome *i* | Not stored directly | — | Cached as `R_i = exp(u_i / b)`. |
| **R_i = e^{u_i/b}** | Local multiplier per outcome | `R[marketId][slot]` | 1e18 | One per **listed** AMM slot. |
| **S = \sum_i R_i** | Running sum in math (all outcomes) | **Contract denom:** `S_tradables + R_reserve` via `LMSRHelpersLib.denom(self, marketId)` | 1e18 | Math `S` = all `R_i`. Contract splits into listed `S_tradables` plus `R_reserve` (“Other”). |
| **\Delta** | Trade delta vector | Not stored; implicit per call | — | Realized as `(\Delta U_{rest}, \Delta U_k)` updates (see below). |
| **m** | Spend/proceeds of a trade | Returned by quotes / used in execution | USDC 1e6 | `m` from closed forms in `LMSRQuoteLib` (pre‑fee), wrappers add/subtract fee. |
| **t** | Token quantity traded | Passed as arg / returned | 1e6 (token units) | Used in `quoteBuy`, `quoteSell`, and inverse `quoteBuyForUSDC`. |

> **About `S` vs `denom`**: In the math, `S = \sum_i R_i` includes **all** outcomes. In the contract, we store `S_tradables` (listed outcomes only) and a separate `R_reserve`. Everywhere prices are computed, the **denominator** is `S_tradables + R_reserve`, exposed via `LMSRHelpersLib.denom(...)`.

---

## 2) Closed‑Form Formulas → Exact Library Calls

### 2.1 BACK (buy size `t`)
- Math: \( m = b\ln(1 - p + p\,e^{t/b}) \)
- Code: `LMSRQuoteLib.quoteBuyInternal(self, marketId, ledgerId, /*isBack=*/true, t)`

### 2.2 LAY(not‑i) (buy size `t`)
- Math: \( m = b\ln(p + (1 - p)\,e^{t/b}) \)
- Code: `LMSRQuoteLib.quoteBuyInternal(self, marketId, ledgerId, /*isBack=*/false, t)`

### 2.3 BACK inverse (exact USDC → tokens)
- Math: \( t = b\ln\big(1 + (e^{m/b}-1)/p\big) \)
- Code: `LMSRQuoteLib.quoteBuyForUSDCInternal(self, marketId, ledgerId, /*isBack=*/true, mFinal)`

### 2.4 LAY inverse (exact USDC → tokens)
- Math: \( t = b\ln\big((e^{m/b} - p)/(1 - p)\big) \)
- Code: `LMSRQuoteLib.quoteBuyForUSDCInternal(self, marketId, ledgerId, /*isBack=*/false, mFinal)`

### 2.5 Sells (size `t`)
- Math: replace `t` with `−t` in the same forms
- Code: `LMSRQuoteLib.quoteSellInternal(self, marketId, ledgerId, isBack, t)`

---

## 3) O(1) Update Rules → State Mutations

Math (from decomposition): update **global** and **local** with two scalars per trade.

| **Trade** | **Math deltas** | **Code path** |
|---|---|---|
| BACK **buy** | (\(\Delta U_{rest}, \Delta U_k\)) = (0, +t) | `LMSRUpdateLib.applyUpdateInternal(..., isBack=true, isBuy=true, t)` |
| BACK **sell** | (0, −t) | `applyUpdateInternal(..., true, false, t)` |
| LAY **buy** | (+t, 0) | `applyUpdateInternal(..., false, true, t)` |
| LAY **sell** | (−t, 0) | `applyUpdateInternal(..., false, false, t)` |

**Contract mutations (per trade)**  
- `G ← G · exp(ΔU_rest / b)`  
- `R_k ← R_k · exp((ΔU_k − ΔU_rest)/b)`  
- `S_tradables ← S_tradables − R_k_old + R_k_new`  
- Price denominator used everywhere: **`denom = S_tradables + R_reserve`**

---

## 4) Initialization & Normalization

- **Set `b`**: `b = liabilityUSDC / ln(n)` → `LMSRInitLib.calculateB(...)`  
- **Normalize priors** to **sum = 1e18** (or short‑circuit if already 1e18): `_normalizeToWadTotal(...)`  
- **Store**: `R[slot]`, `S_tradables = ∑R`, `R_reserve`, `G = 1e18`, mappings `ledgerId ↔ slot`

---

## 5) Prices, Z, Reserve (from math)

- **Price**: \( p_i = e^{q_i/b}/Z = R_i / (S + R_{reserve}) \)  
  → `getBackPriceWadInternal(...)`  
- **Reserve price**: \( R_{reserve}/(S + R_{reserve}) \)  
  → `getReservePriceWadInternal(...)`  
- **Partition function**: \( Z = G · (S + R_{reserve}) \)  
  → `getZInternal(...)`

---

## 6) Execution & TWAP (context for the math)

- **Execution**: `LMSRExecutionLib` calls quotes, moves funds via `ILedger`, then applies the **O(1)** update.  
- **TWAP**: `LMSRTwapO1Lib` accrues \(\sum p_i \Delta t\) per slot using a global time anchor → O(1) per trade.

---

### TL;DR

- Every symbol from the math doc has a single, concrete home in code.  
- Math **S** (all outcomes) ↔ contract **denom** = `S_tradables + R_reserve`.  
- Prices and costs use **closed‑form** expressions; state updates are **O(1)** via `(G, R_k, S_tradables)`.

