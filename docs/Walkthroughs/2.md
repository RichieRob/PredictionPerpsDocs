---
title: Pricing Walkthrough — Fruit Market
description: Step-by-step, numbers-driven walkthrough showing how prices move in practice for the Fruit Market initialized in MarketInitialisation.md, using 10,000 USDC of synthetic liquidity.
---

# Pricing Walkthrough — Fruit Market

> **Audience**: traders, reviewers, and devs who want to *see* prices move in practice.  
> **Pre-reqs**: skim these first:  
> • [**Market Initialisation**](../Flows/MarketInitialisation.md) — the fruit market we’ll use here.  
> • [**LMSR Purchase Flow**](../Flows/PurchaseToken/PurchaseFlowLMSR.md) — where pricing is applied.  
> • [**Ledger Purchase Flow**](../Flows/PurchaseToken/PurchaseFlowLedger.md) — how USDC/ISC moves and minting happens.  
> • [**Synthetic Liquidity — Overview**](../FullReadMe/Accounting/SyntheticLiquidity/SyntheticOverview.md).

---

## 1 · Scenario Setup (from *MarketInitialisation.md*)

* **Market**: *Fruit* (`marketId = 0`)
* **Positions (Back tokens)**: `Apple (APL)`, `Banana (BAN)`, `Cucumber (CUC)`, `Dragon Fruit (DRF)`, and the implicit `Other (OTH)` reserve position.
* **Initial prices** (see [Market Initialisation](../Flows/MarketInitialisation.md)) (Back):  
  Apple **0.4**, Banana **0.10**, Cucumber **0.30**, Dragon Fruit **0.10**, and Other **0.10** *(reserve not tokenised)*.
* **Synthetic Liquidity (ISC depth)**: **10,000 USDC** for the designated MM on this market.
* **AMM**: LMSR with O(1) updates (global/local decomposition). See [AMM notes](../FullReadMe/AMM.md).

---

## 2 · How Pricing Works (at a glance)

We use a standard LMSR cost function:

* **Cost**: \( C(\mathbf{q}) = b \cdot \ln(\sum_i e^{q_i/b}) \)
* **Instant price** for outcome *i*: \( p_i = \frac{e^{q_i/b}}{\sum_j e^{q_j/b}} \)
* **Spend S on outcome i** → find \(\Delta q_i\) such that \( C(q_i + \Delta q_i) - C(q) = S \).

---

### Deriving **b** from the “liability”

In this protocol, **b** is calculated directly from the *liabilityUSDC* input at initialization.  
That liability represents the **maximum liability** the market maker could incur. Maximum liability can equal the seeded **synthetic liquidity**.

So if we are starting a market with 0 real USDC and 10,000 USDC of synthetic liquidity, and we have 4 listed fruits:

```solidity
function calculateB(uint256 liabilityUSDC, uint256 _numInitial)
    internal
    pure
    returns (int256 _b)
{
    int256 numWad = int256(_numInitial) * int256(LMSRMarketMaker.WAD);  // n in 1e18
    int256 lnNWad = PRBMathSD59x18.ln(numWad);                          // ln(n) in 1e18
    _b = (int256(liabilityUSDC) * int256(LMSRMarketMaker.WAD)) / lnNWad; // result in sd59x18
}
```

For our market:

\[
b = \frac{10{,}000 \times 10^{18}}{\ln(4)} \approx 7{,}213.5 \times 10^{18}
\]

Thus **10,000 USDC** is *not* `b` itself — it defines the **maximum bounded loss**, from which `b` is mathematically derived.

> This ensures liquidity depth scales naturally with the market’s number of outcomes and risk exposure.

---

## 3 · Walkthrough — A Short Trading Session

Below we run a sequence of realistic trades and show how prices move. Each step lists **before/after** price vectors including the implicit `Other` price.

### Legend

* **State**: \(\mathbf{p} = [p_{APL}, p_{BAN}, p_{CUC}, p_{DRF}, p_{OTH}]\) — Back prices that sum to 1.0.  
* **Call**: The on-chain function used.  
* **Effect**: Intuition using the O(1) LMSR global/local shift notation.

---

### Trade 1 — Buy Back **Apple** with 1,000 USDC

**Before**: `p ≈ [0.40, 0.10, 0.30, 0.10, 0.10]`

**Call**:
```solidity
LMSRMarketMaker.buyForUSDC(
  /* marketId */      0,
  /* positionId */    APL_ID,
  /* isBack */        true,
  /* usdcIn */        1_000e6,
  /* tMax */          0,
  /* minTokensOut */  X,
  /* usePermit2 */    true,
  /* permitBlob */    PERMIT2_SINGLE
);
```

**Effect (intuition)**: raises *Apple*’s log-quantity \(q_{APL}\) by \(\Delta q\). Prices tilt toward Apple; others, including *Other*, drop slightly.  
**After**: `p ≈ [0.44, 0.095, 0.285, 0.095, 0.085]` *(illustrative)*

---

### Trade 2 — Buy Back **Cucumber** with 2,500 USDC

**Before**: `p ≈ [0.44, 0.095, 0.285, 0.095, 0.085]`  
**Call**: `buyForUSDC(0, CUC_ID, true, 2_500e6, ...)`  
**Effect**: strong shift toward *Cucumber*; Apple relaxes; *Other* absorbs some reduction.  
**After**: `p ≈ [0.40, 0.090, 0.33, 0.088, 0.092]` *(illustrative)*

---

### Trade 3 — Buy **Lay** on **Banana** with 1,200 USDC

**Before**: `p ≈ [0.40, 0.090, 0.33, 0.088, 0.092]`  
**Call**: `buyForUSDC(0, BAN_ID, /* isBack = */ false, 1_200e6, ...)`  
**Effect**: Lay(Banana) increases, which (dually) lowers Back(Banana) price and shifts some weight to others, including *Other*.  
**After**: `p ≈ [0.41, 0.080, 0.335, 0.085, 0.090]` *(illustrative)*

---

### Trade 4 — Buy Back **Dragon Fruit** with 800 USDC

**Before**: `p ≈ [0.41, 0.080, 0.335, 0.085, 0.090]`  
**Call**: `buyForUSDC(0, DRF_ID, true, 800e6, ...)`  
**Effect**: nudges DRF upward from a thin base; mild pull from others and *Other*.  
**After**: `p ≈ [0.405, 0.078, 0.328, 0.095, 0.094]` *(illustrative)*

---

### Trade 5 — Buy **Lay** on **Apple** with 3,000 USDC

**Before**: `p ≈ [0.405, 0.078, 0.328, 0.095, 0.094]`  
**Call**: `buyForUSDC(0, APL_ID, /* isBack = */ false, 3_000e6, ...)`  
**Effect**: pushes back against Apple’s dominance; redistributes mass to others and *Other*.  
**After**: `p ≈ [0.36, 0.085, 0.345, 0.095, 0.115]` *(illustrative)*

---

## 4 · Reading the Moves

* **Depth matters.** With **b** derived from the 10 000 USDC input, 1–3 k USDC trades create *noticeable* but not extreme moves. Larger `b` ⇒ smoother prices.  
* **Listed vs Reserve.** Prices shown are for **listed** outcomes plus the implicit *Other*. The *Other* component adjusts dynamically to keep the total = 1.0.  
* **Back vs Lay symmetry.** Back buys add to an outcome’s log-quantity; Lay buys reduce it (and vice-versa for sells), with global shifts maintaining normalization.

> For the exact global/local shift logic, see the O(1) notes in [**AMM**](../FullReadMe/AMM.md) and the implementation in `LMSRMarketMaker` (plus helpers).

---

## 5 · Verifying On-Chain (dev checklist)

1. **Quote first** (slippage):  
   ```solidity
   (uint256 tOut) = amm.quoteBuyForUSDC(0, POS_ID, isBack, usdcIn, 0);
   ```
2. **Submit trade** with `minTokensOut`.  
3. **Inspect events**: pre/post TWAP, quantities, and price emissions.  
4. **Ledger invariants** hold: balances adjust; mint ERC-1155 (Back/Lay) to the trader; solvency checks pass.  
   See: [Ledger Purchase Flow](../Flows/PurchaseToken/PurchaseFlowLedger.md).

---

## 6 · Appendix — Reproducible Math

If you want the **exact** numbers for the sequence above:

* Use **b** as calculated from the 10 000 USDC ISC input,
* Initialize \(q\) so that \(p = [0.40, 0.10, 0.30, 0.10, 0.10]\),
* For each trade, solve \( C(q + \Delta q) - C(q) = S \) for the target outcome and compute the new \(p\).

> We keep this walkthrough human-readable. For ground-truth, run the same trades against the contract or a local simulator and paste the price vectors into the “After” slots above.

---

## READ MORE

* [Market Initialisation](../Flows/MarketInitialisation.md)
* [Purchase Flow — Overview](../Flows/PurchaseToken/PurchaseFlowOverview.md)
* [Purchase Flow — LMSR](../Flows/PurchaseToken/PurchaseFlowLMSR.md)
* [Purchase Flow — Ledger](../Flows/PurchaseToken/PurchaseFlowLedger.md)
* [Synthetic Liquidity — Overview](../FullReadMe/Accounting/SyntheticLiquidity/SyntheticOverview.md)
* [Ledger Accounting (standard)](../FullReadMe/Accounting/StandardLiquidity/LedgerAccounting.md)

