## Stored State (What we keep, why it exists, and how it maps to the math)

This AMM stores a **minimal set of cached variables** that make LMSR updates O(1).  
They correspond directly to the global–local decomposition from the math doc:
\(q_i = U_{\text{all}} + u_i\), with \(G = e^{U_{\text{all}}/b}\) and \(R_i = e^{u_i/b}\).

> **Scale conventions**  
> - Prices, \(R_i\), \(G\), sums → **1e18**  
> - USDC (m, quotes/exec) → **1e6**  
> - \(b\) → **sd59x18** (PRBMath)

### A) Core pricing state (per market)

| Name (code) | Meaning | Math mapping | Scale | Notes |
|---|---|---|---|---|
| `b[marketId]` | Liquidity depth | \(b\) | 1e18 (sd59x18) | Set from liability: \(b = \text{liability}/\ln(n)\). |
| `G[marketId]` | Global factor \(e^{U_{\text{all}}/b}\) | \(G\) | 1e18 | Multiplies the whole partition; **trades may scale this if \(\Delta U_{\text{rest}}\neq 0\)**. |
| `R[marketId][slot]` | Local base mass per listed outcome | \(R_i = e^{u_i/b}\) | 1e18 | One entry per **listed** position (AMM slot). |
| `S_tradables[marketId]` | Sum of listed masses | \(\sum_i R_i\) over listed | 1e18 | Kept as a running sum for O(1) denom updates. |
| `R_reserve[marketId]` | Non-tradable reserve (“Other”) mass | \(R_{\text{reserve}}\) | 1e18 | Only changes when **splitting from reserve** (expansion). |
| **Denominator** (via `denom(...)`) | Price denominator | \(D = S_{\text{tradables}} + R_{\text{reserve}}\) | 1e18 | Used in all price reads: \(p_i = R_i / D\). |
| **Partition** (via `getZInternal`) | Partition function | \(Z = G \cdot D\) | 1e18 | Mirrors \(\sum_i e^{q_i/b}\) from the math. |

**Prices (views):**
- Back: \(p_i = \dfrac{R_i}{D}\) → `getBackPriceWadInternal`
- Lay (true not-i): \(1 - p_i\) → `getLayPriceWadInternal`
- Reserve (“Other”): \(\dfrac{R_{\text{reserve}}}{D}\) → `getReservePriceWadInternal`

### B) Listing & indexing (per market)

| Name (code) | Meaning | Notes |
|---|---|---|
| `slotOf[marketId][ledgerPositionId]` | Ledger id → AMM slot | 1-based sentinel (`0` = not listed). |
| `ledgerIdOfSlot[marketId][slot]` | AMM slot → Ledger id | UI helpers & audits. |
| `numOutcomes[marketId]` | Count of listed slots | Equals `R[marketId].length`. |
| `isExpanding[marketId]` | Reserve split mode | If `true`, you can split reserve into new listings with price continuity. |

### C) Per-market config & guards

| Name (code) | Meaning | Notes |
|---|---|---|
| `initialized[marketId]` | One-time init guard | Prevents re-init. |
| `FEE_BPS` | Fee bps | Quoted via wrappers; core math is net of fees. |

> **Optional analytics**: TWAP accumulators (`LMSRTwapO1Lib`) keep O(1) time-weighted price integrals without touching pricing state.

---

## Initialization snapshot (how the math becomes state)

1. **Compute depth**:  
   \( b \leftarrow \text{calculateB}(\text{liabilityUSDC}, n) = \dfrac{\text{liability}}{\ln(n)} \).

2. **Normalize priors** (already-WAD or normalized to 1e18 total):  
   - Listed: set `R[i] = r_i` (1e18 each), accumulate `S_tradables = \sum r_i`.  
   - Reserve: set `R_reserve` (1e18).  
   - Set `G = 1e18` (neutral global; prices depend only on \(R_i/D\) at genesis).

3. **Wire listings**: fill `slotOf` / `ledgerIdOfSlot`, set `numOutcomes`, set `isExpanding`.

> After init, **prices are just the priors**: \(p_i = R_i / (S_{\text{tradables}} + R_{\text{reserve}})\).

---

## State updates (what changes on each action)

All trades are expressed as **global** and **local** shifts of the math variables:
- Global shift \(\Delta U_{\text{rest}}\) affects **everyone** → scales `G`.
- Local shift \(\Delta U_k\) affects **only the traded slot** → scales `R_k`.

We apply O(1) updates (no loops):

\[
\begin{aligned}
G' &= G \cdot e^{\Delta U_{\text{rest}}/b} \\
R_k' &= R_k \cdot e^{(\Delta U_k - \Delta U_{\text{rest}})/b} \\
S_{\text{tradables}}' &= S_{\text{tradables}} - R_k + R_k' \\
D' &= S_{\text{tradables}}' + R_{\text{reserve}}
\end{aligned}
\]

**Action → shifts:**

| Action | \(\Delta U_{\text{rest}}\) | \(\Delta U_k\) | Intuition |
|---|---:|---:|---|
| **Buy · Back(i)** | 0 | \(+t\) | Boost only \(R_i\) by \(e^{+t/b}\); denom grows via \(S\). |
| **Sell · Back(i)** | 0 | \(-t\) | Shrink only \(R_i\) by \(e^{-t/b}\); denom shrinks via \(S\). |
| **Buy · Lay(not-i)** | \(+t\) | 0 | Global up; local \(i\) held flat ⇒ others gain share vs \(i\). |
| **Sell · Lay(not-i)** | \(-t\) | 0 | Global down; local \(i\) held flat ⇒ \(i\) gains share vs others. |

> The **denominator** is always \(D = S_{\text{tradables}} + R_{\text{reserve}}\).  
> Reserve only changes on **expansion** (splits): move \(\alpha\) of `R_reserve` into a new `R_k`, keeping \(D\) **constant** → price continuity.

---

## Invariants & sanity checks

- \(D > 0\) (enforced by `denom(...)`).  
- \(0 < p_i < 1\) for listed; reserve price is \(\in (0,1)\) if `R_reserve > 0`.  
- Fees are applied outside the core math (quote wrappers / execution layer).  
- Normalization tolerates only tiny dust; otherwise reverts.  
- Slot mapping is 1-based to avoid false “listed” positives.
