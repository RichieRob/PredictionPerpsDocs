# Purchase Position Flow — Overview (Permit2 Flow + Example)

This page explains what happens when a trader purchases a position using **Permit2**, with the **Ledger as the spender that pulls USDC** from the trader (as per your implementation). No prior `approve()` tx is required.

---

## 1 · The Participants

**User (Trader)**  
**AMM (LMSRMarketMaker)** — entry point for trades  
**Ledger** — pulls funds via Permit2 and enforces solvency  
**Market Maker (DMM)** — supplies real + synthetic (ISC) liquidity  
**PositionToken1155** — mints/burns Back and Lay tokens

---

## 2 · Front-End Sequence (Permit2; *Ledger is spender*)

1. **Quote (READ)**  
   ```solidity
   LMSRMarketMaker.quoteBuyForUSDC(
       marketId,
       positionId,
       /* isBack */ true,
       cashIn,
       0 // tMax (ignored)
   ) → tOut
   ```

2. **Sign Permit2 (off-chain)**  
   Build and sign a `PermitSingle` where:  
   - `token = USDC`  
   - `amount = cashIn`  
   - `spender = Ledger`   ← **important: Ledger is the spender**  
   - `expiration / sigDeadline / nonce`

3. **Encode Permit Payload**  
   ABI-encode `{ PermitSingle, signature }` → `bytes permitBlob`.

4. **Execute Trade (ON-CHAIN)**  
   ```solidity
   LMSRMarketMaker.buyForUSDC(
       marketId,
       positionId,
       /* isBack */ true,
       cashIn,
       0,             // tMax (unused)
       minTokensOut,  // slippage guard
       true,          // usePermit2
       permitBlob     // passed through to the Ledger
   )
   ```

---

## 3 · How the Permit Flows (Ledger pulls funds)

```
Trader
  │
  │  (1) buyForUSDC(..., usePermit2=true, permitBlob)
  ▼
AMM (LMSRMarketMaker)
  │  forwards permitBlob into the Ledger’s execution path
  │
  ▼
Ledger
  │  calls Permit2.permitTransferFrom( trader → Ledger, amount, permitBlob )
  │  → USDC arrives in Ledger
  │  updates tilt / freeCollateral / ISC (solvency)
  │  mints ERC-1155 Back/Lay to trader (via PositionToken1155)
  │  updates LMSR state; emits events
```

> In your code, this happens inside `DepositWithdrawLib.depositFromTraderWithPermit2(...)`, which calls:  
> `IPermit2.permitTransferFrom(permit2Calldata, trader, address(this), amount)` — **Ledger is the spender and recipient.**

---

## 4 · Worked Example (Back Buy)

Market: **A, B, C, D**  DMM ISC = 100 real freeCollateral = 0

### Before Trade

| Variable | Value |
|-----------|------:|
| freeCollateral (real) | 0 |
| syntheticFree (ISC)   | 100 |
| tilt[A..D]            | 0 each |
| Back prices           | A 0.40  B 0.30  C 0.20  D 0.10 (Σ = 1.00) |

---

### Trader Intent
Buy **Back A** for **5 USDC**.

1. `quoteBuyForUSDC(marketId, A, true, 5)` → `sharesOut ≈ 12.345679`  
2. Sign Permit2 where **spender = Ledger**, `amount = 5`  
3. Call `buyForUSDC(..., usePermit2 = true, permitBlob)`

---

### After Trade (illustrative)

| Variable | Before | Δ | After |
|-----------|------:|--:|------:|
| freeCollateral (real) | 0 | 0 | 0 |
| syntheticFree (ISC) | 100 | −12.35 | 87.65 |
| tilt[A] | 0 | −12.35 | −12.35 |
| tilt[B,C,D] | 0 | 0 | 0 |

Back A price ≈ 0.46; others fall; Σ ≈ 1.00.  
Trader holds 12.345679 Back A tokens.

---

## 5 · Contract Responsibilities

| Layer | Role |
|-------|------|
| **AMM** | Entry point; forwards permit payload; orchestrates call sequence and LMSR updates. |
| **Ledger** | **Spender** in Permit2; pulls USDC; updates solvency (tilt, freeCollateral, ISC); instructs mint. |
| **PositionToken1155** | Mints ERC-1155 Back/Lay to trader. |
| **Permit2 (External)** | Verifies signature and performs the transfer. |

---

## 6 · Quick Call Summary

```text
1) Trader → quoteBuyForUSDC()
2) Trader → sign Permit2 (spender = Ledger, amount = USDC-in)
3) Trader → AMM.buyForUSDC(..., usePermit2=true, permitBlob)
4) Ledger → Permit2.permitTransferFrom(trader → Ledger)
5) Ledger → update solvency, mint ERC-1155
6) AMM/Ledger → update LMSR state; emit events
```

This version matches your repo’s actual flow: **the Ledger is the Permit2 spender and pulls USDC from the trader**, with the AMM passing the signed permit data through.
